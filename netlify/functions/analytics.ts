import { Handler, HandlerEvent, HandlerContext }, from '@netlify/functions',import { createClient }, from 'supabase/supabase-js',import { z }, from 'zod'// Environment variablesconst supabaseUrl = process.env.VITE_SUPABASE_URL!const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!const supabase = createClient(supabaseUrl, supabaseServiceKey)// Request validation schemasconst AnalyticsEventSchema = z.object({  userId: z.string().uuid(,  featureUsed: z.string().min(1,  sessionDuration: z.number().int().min(0).optional(,  interactionCount: z.number().int().min(0).optional(,  crisisPreventedCount: z.number().int().min(0).optional().default(0,  safetyPlanAccessedCount: z.number().int().min(0).optional().default(0,  breathingExercisesUsed: z.number().int().min(0).optional().default(0,  pageLoadTime: z.number().int().min(0).optional(,  aiResponseTime: z.number().int().min(0).optional(})const NotificationSchema = z.object({  userId: z.string().uuid(,  notificationType: z.enum([]crisis_alert, 'mood_reminder', 'check_in', 'peer_message', 'system']),',  deliveryMethod: z.enum([]push, 'email', 'in_app']),',  title: z.string().optional(,  message: z.string().optional(})const DashboardRequestSchema = z.object({  days: z.number().int().min(1).max(365).optional().default(30,  userRole: z.enum([]admin, 'therapist', 'helper', 'user']).optional(),'})interface AnalyticsResponse {  success: boolean  data?: any  error?: string}export const handler: Handler = async (event: HandlerEvent, context: HandlerContext => {}  // CORS headers  const headers = {    'Access-Control-Allow-Origin': ',',    'Access-Control-Allow-Headers': 'Content-Type, Authorization',',    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS','  }  // Handle preflight requests  if (event.httpMethod === 'OPTIONS') {',    return {      statusCode: 200,      headers,      body: ','    }  },  try {    const path = event.path.replace('netlify/functions/analytics', ')',    const method = event.httpMethod    switch (true) {      case method === 'POST' && path === 'track':,        return await trackEvent(event, headers            case method === 'POST' && path === 'notification':,        return await trackNotification(event, headers            case method === 'PUT' && path.startsWith('notification/'):,        return await updateNotificationStatus(event, headers            case method === 'GET' && path.startsWith('user/'):,        return await getUserAnalytics(event, headers            case method === 'POST' && path === 'dashboard':,        return await getAnalyticsDashboard(event, headers            case method === 'GET' && path.startsWith('notifications/'):,        return await getNotificationAnalytics(event, headers            case method === 'GET' && path === 'features':,        return await getFeatureUsageStats(event, headers            case method === 'GET' && path.startsWith('export/'):,        return await exportAnalyticsData(event, headers            case method === 'GET' && path === 'performance':,        return await getPerformanceMetrics(event, headers            case method === 'GET' && path === 'crisis-metrics':,        return await getCrisisMetrics(event, headers            default:        return {          statusCode: 404,          headers,          body: JSON.stringify( error: 'Endpoint, not found' }),'        }    }  }, catch (error) {    console.error('Analytics function error:', error)',    return {      statusCode: 500,      headers,      body: JSON.stringify(         success: false,         error: 'Internal, server error',',        message: error instanceof Error ? error.message : 'Unknown error'      })    }  }},async function trackEvent(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const validatedData = AnalyticsEventSchema.parse(body)    const { data: analyticsEvent, error } = await supabase      .from('user_analytics')'      .insert({        user_id: validatedDatauserId,        feature_used: validatedDatafeatureUsed,        session_duration: validatedDatasessionDuration,        interaction_count: validatedDatainteractionCount,        crisis_prevented_count: validatedDatacrisisPreventedCount,        safety_plan_accessed_count: validatedDatasafetyPlanAccessedCount,        breathing_exercises_used: validatedDatabreathingExercisesUsed,        page_load_time: validatedDatapageLoadTime,        ai_response_time: validatedDataaiResponseTime      })      .select()      .single()    if (error) throw error    const response: AnalyticsResponse = {      success: true,      data: {        eventId: analyticsEventid,        featureUsed: validatedDatafeatureUsed,        timestamp: analyticsEventcreated_at      }    },    return {      statusCode: 201,      headers,      body: JSON.stringify(response    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Invalid analytics event data'       })    }  }},async function trackNotification(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const validatedData = NotificationSchema.parse(body)    const { data: notification, error } = await supabase      .from('notification_logs')'      .insert({        user_id: validatedDatauserId,        notification_type: validatedDatanotificationType,        delivery_method: validatedDatadeliveryMethod,        title: validatedDatatitle,        message: validatedDatamessage,        status: 'sent,'      })      .select()      .single()    if (error) throw error    return {      statusCode: 201,      headers,      body: JSON.stringify(        success: true,        data: {          notificationId: notificationid,          status: 'sent,',          timestamp: notificationcreated_at        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Invalid notification data'       })    }  }},async function updateNotificationStatus(event: HandlerEvent, headers: Recordstring, string){  try {    const pathParts = event.path.split(')',    const notificationId = pathParts[]athParts.length - 1]    if (!notificationId) {      throw new Error('Notification ID is required')'    },    const body = JSON.parse(event.body || '}')',    const { status, opened, actionTaken } = body    const { data: updatedNotification, error } = await supabase      .from('notification_logs')'      .update({         status: status || 'delivered',',        opened: opened ?? false,        action_taken: actionTaken ?? false       })      .eq('id', notificationId)'      .select()      .single()    if (error) throw error    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          notificationId,          status: updatedNotificationstatus,          opened: updatedNotificationopened,          actionTaken: updatedNotificationaction_taken        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to update notification status'       })    }  }},async function getUserAnalytics(event: HandlerEvent, headers: Recordstring, string){  try {    const pathParts = event.path.split(')',    const userId = pathParts[]athParts.length - 1]    if (!userId) {      throw new Error('User ID is required')'    },    const queryParams = event.queryStringParameters || {},    const days = parseInt(queryParams.days || '30')',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    const { data: analytics, error } = await supabase      .from('user_analytics')'      .select(')'      .eq('user_id', userId)'      .gte('date', startDate.toISOString().split('T')]])'      .order('date', { ascending: false })',    if (error) throw error    // Process analytics data    const summary = {      totalSessions: analyticslength,      totalSessionTime: analytics.reduce(sum, entry) => sum + (entry.session_duration || 0), 0),      averageSessionTime: 0,      featuresUsed: aggregateFeatureUsage(analytics,      crisisInterventions: {        prevented: analytics.reduce(sum, entry) => sum + entry.crisis_prevented_count, 0),        safetyPlanAccessed: analytics.reduce(sum, entry) => sum + entry.safety_plan_accessed_count, 0),        breathingExercises: analytics.reduce(sum, entry) => sum + entry.breathing_exercises_used, 0)      },      performance: {        averagePageLoad: calculateAverageanalytics, 'page_load_time'),',        averageAIResponse: calculateAverageanalytics, 'ai_response_time'),'      },      dailyUsage: aggregateDailyUsage(analytics    },    summary.averageSessionTime = summary.totalSessions > 0       ? Math.round(summary.totalSessionTime / summary.totalSessions)       : 0    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          summary,          timeframe: ``days}, days`        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch user analytics'       })    }  }},async function getAnalyticsDashboard(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const { days, userRole } = DashboardRequestSchema.parse(body)    // Check if user has permission to view dashboard (admin/therapist only)    if (userRole && ![]admin', 'therapist'].includes(userRole)) {',      return {        statusCode: 403,        headers,        body: JSON.stringify(           success: false,           error: 'Insufficient, permissions to view analytics dashboard'         })      }    },    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    // Get user metrics    const userMetrics = await getUserMetrics(startDate)        // Get crisis metrics    const crisisMetrics = await getCrisisMetricsForDashboard(startDate)        // Get wellness metrics    const wellnessMetrics = await getWellnessMetrics(startDate)        // Get engagement metrics    const engagementMetrics = await getEngagementMetrics(startDate)        // Get performance metrics    const performanceMetrics = await getPerformanceMetricsForDashboard(startDate)    const dashboard = {      userMetrics,      crisisMetrics,      wellnessMetrics,      engagementMetrics,      performanceMetrics,      timeframe: ``days}, days`,      generatedAt: new Date().toISOString()    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: dashboard      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to generate analytics dashboard'       })    }  }},async function getNotificationAnalytics(event: HandlerEvent, headers: Recordstring, string){  try {    const pathParts = event.path.split(')',    const userId = pathParts[]athParts.length - 1]    const queryParams = event.queryStringParameters || {},    const days = parseInt(queryParams.days || '30')',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    let query = supabase      .from('notification_logs')'      .select(')'      .gte('created_at', startDate.toISOString())',    if (userId && userId !== 'all') {',      query = query.eq('user_id', userId)'    },    const { data: notifications, error } = await query    if (error) throw error    const analytics = {      totalNotifications: notificationslength,      deliveryBreakdown: aggregateByFieldnotifications, 'delivery_method'),',      typeBreakdown: aggregateByFieldnotifications, 'notification_type'),',      statusBreakdown: aggregateByFieldnotifications, 'status'),',      openRate: calculateRatenotifications, 'opened'),',      actionRate: calculateRatenotifications, 'action_taken'),',      dailyVolume: aggregateNotificationsByDate(notifications    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          analytics,          timeframe: ``days}, days`        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch notification analytics'       })    }  }},async function getFeatureUsageStats(event: HandlerEvent, headers: Recordstring, string){  try {    const queryParams = event.queryStringParameters || {},    const days = parseInt(queryParams.days || '30')',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    const { data: analytics, error } = await supabase      .from('user_analytics')'      .select('feature_used, interaction_count, session_duration')      .gte('date', startDate.toISOString().split('T')]])',    if (error) throw error    const featureStats = new Map<string, {      totalUses: number      totalInteractions: number      totalTime: number      averageSessionTime: number    }>()    analytics.forEach(entry => {}      const current = featureStats.get(entry.feature_used) || {        totalUses: 0,        totalInteractions: 0,        totalTime: 0,        averageSessionTime: 0      },      current.totalUses++      current.totalInteractions += entry.interaction_count || 0      current.totalTime += entry.session_duration || 0      featureStats.set(entry.feature_used, current)    })    // Calculate averages    const stats = Array.from(featureStats.entries()).map(([]eature, data]) => ({      feature,      ...data,      averageSessionTime: datatotalUses > 0 ? Math.round(data.totalTime / data.totalUses) : 0    }))    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          featureStats: stats.sort(a, b) => b.totalUses - a.totalUses),          timeframe: ``days}, days`        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch feature usage stats'       })    }  }},async function exportAnalyticsData(event: HandlerEvent, headers: Recordstring, string){  try {    const pathParts = event.path.split(')',    const userId = pathParts[]athParts.length - 1]    const queryParams = event.queryStringParameters || {},    const days = parseInt(queryParams.days || '30')',    const format = queryParams.format || 'json',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    let query = supabase      .from('user_analytics')'      .select(')'      .gte('date', startDate.toISOString().split('T')]])'      .order('date', { ascending: false })',    if (userId && userId !== 'all') {',      query = query.eq('user_id', userId)'    },    const { data: analytics, error } = await query    if (error) throw error    if (format === 'csv') {',      const csvData = convertToCSV(analytics)      return {        statusCode: 200,        headers: {          ...headers,          'Content-Type': 'text/csv',',          'Content-Disposition': 'attachmen; filename='analytics-export.csv","        },        body: csvData      }    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          analytics,          exportedAt: new Date().toISOString(),          timeframe: ``days}, days`,          format        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to export analytics data'       })    }  }},async function getPerformanceMetrics(event: HandlerEvent, headers: Recordstring, string){  try {    const queryParams = event.queryStringParameters || {},    const days = parseInt(queryParams.days || '7')',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    const { data: analytics, error } = await supabase      .from('user_analytics')'      .select('page_load_time, ai_response_time, created_at')      .gte('date', startDate.toISOString().split('T')]])',    if (error) throw error    const metrics = {      averagePageLoadTime: calculateAverageanalytics, 'page_load_time'),',      averageAIResponseTime: calculateAverageanalytics, 'ai_response_time'),',      pageLoadP95: calculatePercentileanalytics, 'page_load_time', 95),',      aiResponseP95: calculatePercentileanalytics, 'ai_response_time', 95),',      totalSamples: analyticslength,      timeframe: ``days}, days`    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: metrics      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch performance metrics'       })    }  }},async function getCrisisMetrics(event: HandlerEvent, headers: Recordstring, string){  try {    const queryParams = event.queryStringParameters || {},    const days = parseInt(queryParams.days || '30')',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    const { data: crisisEvents, error } = await supabase      .from('crisis_events')'      .select('severity, trigger_type, resolved, created_at, response_time_seconds')      .gte('created_at', startDate.toISOString())',    if (error) throw error    const metrics = {      totalCrisisEvents: crisisEventslength,      resolvedCrises: crisisEvents.filtere => e.resolved).length,      averageResponseTime: calculateAveragecrisisEvents, 'response_time_seconds'),',      crisisByTrigger: aggregateByFieldcrisisEvents, 'trigger_type'),',      crisisBySeverity: aggregateByFieldcrisisEvents, 'severity'),',      resolutionRate: crisisEventslength > 0 ?         Math.round((crisisEvents.filter(e => e.resolved).length / crisisEvents.length) * 100) : 0,      dailyCrisisVolume: aggregateCrisisByDate(crisisEvents    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          metrics,          timeframe: ``days}, days`        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch crisis metrics'       })    }  }}// Helper functionsasync function getUserMetrics(startDate: Date  const { data: allUsers } = await supabase    .from('users)'    .select('id, created_at, is_anonymous, last_seen'),  const { data: activeUsers } = await supabase    .from('users')'    .select('id')    .gte('last_seen', startDate.toISOString())',  const totalUsers = allUsers?.length || 0  const activeUsersCount = activeUsers?.length || 0  const anonymousUsers = allUsers?.filter(u => u.is_anonymous).length || 0  return {    totalUsers,    activeUsers: activeUsersCount,    anonymousUsers,    retentionRate: totalUsers > 0 ? Math.round((activeUsersCount / totalUsers) * 100) : 0  }},async function getCrisisMetricsForDashboard(startDate: Date  const { data: crisisEvents } = await supabase    .from('crisis_events)'    .select('severity, trigger_type, resolved, response_time_seconds')    .gte('created_at', startDate.toISOString())',  const totalEvents = crisisEvents?.length || 0  const resolvedEvents = crisisEvents?.filter(e => e.resolved).length || 0  const avgResponseTime = calculateAverage(crisisEvents || [], 'response_time_seconds')',  return {    totalCrisisEvents: totalEvents,    resolvedCrises: resolvedEvents,    averageResponseTime: avgResponseTime,    crisisByTrigger: aggregateByFieldcrisisEvents || [], 'trigger_type'),',    crisisBySeverity: aggregateByFieldcrisisEvents || [], 'severity'),'  }},async function getWellnessMetrics(startDate: Date  const { data: moodEntries } = await supabase    .from('mood_entries)'    .select('mood_score')    .gte('created_at', startDate.toISOString())',  const totalEntries = moodEntries?.length || 0  const averageMood = totalEntries > 0     ? moodEntries!.reduce((sum, entry) => sum + entry.mood_score, 0) / totalEntries     : 0  return {    totalMoodEntries: totalEntries,    averageMoodScore: Math.roundaverageMood * 10) / 10,    moodTrends: { improving: 0, declining: 0, stable: 0 }, // Would need trend calculation  }},async function getEngagementMetrics(startDate: Date  const { data: analytics } = await supabase    .from('user_analytics)'    .select(')'    .gte('date', startDate.toISOString().split('T')]])',  const { data: chatMessages } = await supabase    .from('chat_messages')'    .select('id')    .gte('created_at', startDate.toISOString())',  const dailyActiveUsers = new Set(analytics?.map(a => a.user_id)).size || 0  const totalSessionTime = analytics?.reduce((sum, a) => sum + (a.session_duration || 0), 0) || 0  const averageSessionDuration = analytics?.length ? Math.round(totalSessionTime / analytics.length) : 0  return {    dailyActiveUsers,    averageSessionDuration,    featureUsage: aggregateFeatureUsageanalytics || []),    chatInteractions: chatMessages?length || 0  }},async function getPerformanceMetricsForDashboard(startDate: Date  const { data: analytics } = await supabase    .from('user_analytics)'    .select('page_load_time, ai_response_time')    .gte('date', startDate.toISOString().split('T')]])',  return {    averagePageLoadTime: calculateAverageanalytics || [], 'page_load_time'),',    averageAIResponseTime: calculateAverageanalytics || [], 'ai_response_time'),',    systemUptime: 999, // Would integrate with monitoring service  }},function aggregateFeatureUsage(data: any[)Record<string, number> {  const usage = new Map<string, number>()    data.forEach(entry => {}    usage.set(entry.feature_used, (usage.get(entry.feature_used) || 0) + 1)  })  return Object.fromEntries(usage},function calculateAverage(data: any, ]ield: string)number {  const values = data.map(item => item[]ield]).filter(val => val !== null && val !== undefined)  return values.length > 0 ? Math.round(values.reduce((sum, val) => sum + val, 0) / values.length)  0},function calculatePercentile(data: any, ]ield: string, percentile: number)number {  const values = data.map(item => item[]ield]).filter(val => val !== null && val !== undefined).sort((a, b) => a - b)  if (values.length === 0) return 0    const index = Math.ceil((percentile / 100) * values.length) - 1  return values[]ath.max(0, index)},function aggregateDailyUsage(data: any[ {  const dailyUsage = new Map<string, number>()data.forEach(entry => {}    dailyUsage.set(entry.date, (dailyUsage.get(entry.date) || 0) + 1)  })  return Array.from(dailyUsage.entries()).map(([]ate, count]) => ({ date count }))},function aggregateByField(data: any, ]ield: string)Record<string, number> {  const aggregation = new Map<string, number>()    data.forEach(item => {}    const value = item[]ield]    if (value) {      aggregation.set(value, (aggregation.get(value) || 0) + 1)    }  })  return Object.fromEntries(aggregation},function calculateRate(data: any, ]ield: string)number {  const total = data.length  const positive = data.filter(item => item[]ield] === true).length  return total > 0 ? Math.round((positive / total) * 100)  0},function aggregateNotificationsByDate(data: any[ {  const dailyVolume = new Map<string, number>()data.forEach(notification => {}    const date = new Date(notification.created_at).toISOString().split('T')]]',    dailyVolume.set(date, (dailyVolume.get(date) || 0) + 1)  })  return Array.from(dailyVolume.entries()).map(([]ate, count]) => ({ date count }))},function aggregateCrisisByDate(data: any[ {  const dailyVolume = new Map<string, number>()data.forEach(crisis => {}    const date = new Date(crisis.created_at).toISOString().split('T')]]',    dailyVolume.set(date, (dailyVolume.get(date) || 0) + 1)  })  return Array.from(dailyVolume.entries()).map(([]ate, count]) => ({ date count }))},function convertToCSV(data: any[)string {  if (data.length === 0) return '  const headers = Object.keys(data[]])  const csvRows = []    headers.join(','),'    ...data.map(row =>       headers.map(header => {}        const value = row[]eader]        return typeof value === 'string' ? ``${value.replace(/"/g, "}"` ` value","      }).join(',')'    )  ]  return csvRows.join('n'}