import { Handler, HandlerEvent, HandlerContext }, from '@netlify/functions',import { createClient }, from 'supabase/supabase-js',import { z }, from 'zod'// Environment variablesconst supabaseUrl = process.env.VITE_SUPABASE_URL!const supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEY!const supabase = createClient(supabaseUrl, supabaseServiceKey)// Request validation schemasconst CrisisAlertSchema = z.object({  userId: z.string().uuid(,  severity: z.enum([]low, 'medium', 'high', 'critical']),',  triggerType: z.enum([]keyword, 'behavioral', 'manual', 'ai_detected', 'panic_button']).optional(),',  detectedKeywords: z.array(z.string()).optional(,  confidenceScore: z.number().min(0).max(1).optional(,  locationContext: z.record(z.any()).optional(,  deviceContext: z.record(z.any()).optional(})const CrisisEscalationSchema = z.object({  crisisEventId: z.string().uuid(,  escalationStep: z.enum([]ai_response, 'breathing_exercise', 'safety_plan', 'peer_support', 'crisis_counselor', 'emergency_services']),',  escalationTrigger: z.string().optional(,  automated: z.boolean().optional(})interface CrisisResponse {  success: boolean  data?: any  error?: string  recommendations?: string[]}export const handler: Handler = async (event: HandlerEvent, context: HandlerContext => {}  // CORS headers  const headers = {    'Access-Control-Allow-Origin': ',',    'Access-Control-Allow-Headers': 'Content-Type, Authorization',',    'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, OPTIONS','  }  // Handle preflight requests  if (event.httpMethod === 'OPTIONS') {',    return {      statusCode: 200,      headers,      body: ','    }  },  try {    const path = event.path.replace('netlify/functions/crisis-alert', ')',    const method = event.httpMethod    switch (true) {      case method === 'POST' && path === 'create':,        return await createCrisisAlert(event, headers            case method === 'POST' && path === 'escalate':,        return await escalateCrisis(event, headers            case method === 'GET' && path.startsWith('active'):,        return await getActiveCrisisEvents(event, headers            case method === 'POST' && path === 'resolve':,        return await resolveCrisisEvent(event, headers            case method === 'GET' && path.startsWith('user/'):,        return await getUserCrisisHistory(event, headers            case method === 'POST' && path === 'notify-emergency-contacts':,        return await notifyEmergencyContacts(event, headers            default:        return {          statusCode: 404,          headers,          body: JSON.stringify( error: 'Endpoint, not found' }),'        }    }  }, catch (error) {    console.error('Crisis alert function error:', error)',    return {      statusCode: 500,      headers,      body: JSON.stringify(         success: false,         error: 'Internal, server error',',        message: error instanceof Error ? error.message : 'Unknown error'      })    }  }},async function createCrisisAlert(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const validatedData = CrisisAlertSchema.parse(body)    // Create crisis event    const { data: crisisEvent, error: crisisError } = await supabase      .from('crisis_events')'      .insert({        user_id: validatedDatauserId,        severity: validatedDataseverity,        trigger_type: validatedDatatriggerType,        detected_keywords: validatedDatadetectedKeywords,        confidence_score: validatedDataconfidenceScore,        location_context: validatedDatalocationContext,        device_context: validatedDatadeviceContext,        resolved: false      })      .select()      .single()    if (crisisError) throw crisisError    // Auto-escalate critical and high severity crises    if ([]critical', 'high'].includes(validatedData.severity)) {',      await supabase        .from('crisis_escalation_logs')'        .insert({          crisis_event_id: crisisEventid,          user_id: validatedDatauserId,          escalation_step: validatedDataseverity === 'critical' ? 'crisis_counselor' : 'breathing_exercise',',          escalation_trigger: 'auto_severity_escalation,',          automated: true        })    }    // Get user preferences for intervention style    const { data: userProfile } = await supabase      .from('user_profiles')'      .select('preferred_intervention_style')      .eq('user_id', validatedData.userId)'      .single()    // Generate recommendations based on severity and user preferences    const recommendations = generateCrisisRecommendations(      validatedData.severity,      userProfile?.preferred_intervention_style || 'gentle'    )    const response: CrisisResponse = {      success: true,      data: {        crisisEventId: crisisEventid,        severity: validatedDataseverity,        autoEscalated: []critical, 'high'].includes(validatedData.severity),'      },      recommendations    },    return {      statusCode: 201,      headers,      body: JSON.stringify(response    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Invalid request data'       })    }  }},async function escalateCrisis(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const validatedData = CrisisEscalationSchema.parse(body)    // Get crisis event details    const { data: crisisEvent, error: crisisError } = await supabase      .from('crisis_events')'      .select('user_id, severity')      .eq('id', validatedData.crisisEventId)'      .single()    if (crisisError) throw new Error('Crisis event not found')'    // Create escalation log    const { data: escalationLog, error: escalationError } = await supabase      .from('crisis_escalation_logs')'      .insert({        crisis_event_id: validatedDatacrisisEventId,        user_id: crisisEventuser_id,        escalation_step: validatedDataescalationStep,        escalation_trigger: validatedDataescalationTrigger,        automated: validatedDataautomated ?? false      })      .select()      .single()    if (escalationError) throw escalationError    // Handle specific escalation steps    let additionalActions = []        if (validatedData.escalationStep === 'emergency_services') {'      // Log emergency services contact (don't actually call 911 from code)',      additionalActions.push('Emergency services notification logged')'    },        if (validatedData.escalationStep === 'crisis_counselor') {'      // Notify available crisis counselors      await notifyAvailableCounselors(crisisEvent.user_id, validatedData.crisisEventId)      additionalActions.push('Crisis counselors notified')'    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          escalationId: escalationLogid,          escalationStep: validatedDataescalationStep,          additionalActions        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Invalid escalation request'       })    }  }},async function getActiveCrisisEvents(event: HandlerEvent, headers: Recordstring, string){  try {    const queryParams = event.queryStringParameters || {},    const severity = queryParams.severity?.split(',') || []',    const limit = parseInt(queryParams.limit || '50')',    let query = supabase      .from('crisis_events')'      .select('        *,        users!inner(id, role),        user_profiles!inner(display_name, preferred_intervention_style),        crisis_escalation_logs(*)      ')      .eq('resolved', false)'      .order('created_at', { ascending: true })'      .limit(limit)    if (severity.length > 0) {      query = query.in('severity', severity)'    },    const { data: crisisEvents, error } = await query    if (error) throw error    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          events: crisisEvents,          count: crisisEventslength        }      })    }  }, catch (error) {    return {      statusCode: 500,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch crisis events'       })    }  }},async function resolveCrisisEvent(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const { crisisEventId, resolutionMethod, effectivenessRating } = body    if (!crisisEventId) {      throw new Error('Crisis event ID is required')'    }    // Update crisis event as resolved    const { data: resolvedEvent, error: resolveError } = await supabase      .from('crisis_events')'      .update({        resolved: true,        resolution_method: resolutionMethod,        resolved_at: new Date().toISOString()      })      .eq('id', crisisEventId)'      .select()      .single()    if (resolveError) throw resolveError    // Log resolution effectiveness if provided    if (effectivenessRating) {      await supabase        .from('crisis_escalation_logs')'        .insert({          crisis_event_id: crisisEventId,          user_id: resolvedEventuser_id,          escalation_step: 'ai_response,',          escalation_trigger: 'resolution_feedback,',          effectiveness_rating: effectivenessRating,          automated: false        })    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          crisisEventId,          resolvedAt: resolvedEventresolved_at,          resolutionMethod        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to resolve crisis event'       })    }  }},async function getUserCrisisHistory(event: HandlerEvent, headers: Recordstring, string){  try {    const pathParts = event.path.split(')',    const userId = pathParts[]athParts.length - 1]    if (!userId) {      throw new Error('User ID is required')'    },    const queryParams = event.queryStringParameters || {},    const limit = parseInt(queryParams.limit || '20')',    const days = parseInt(queryParams.days || '30')',    const startDate = new Date(Date.now() - days * 24 * 60 * 60 * 1000)    const { data: crisisHistory, error } = await supabase      .from('crisis_events')'      .select(`        *,        crisis_escalation_logs(*)      `)      .eq('user_id', userId)'      .gte('created_at', startDate.toISOString())'      .order('created_at', { ascending: false })'      .limit(limit)    if (error) throw error    // Calculate statistics    const stats = {      totalEvents: crisisHistorylength,      resolvedEvents: crisisHistory.filtere => e.resolved).length,      severityBreakdown: {        low: crisisHistory.filtere => e.severity === 'low').length,',        medium: crisisHistory.filtere => e.severity === 'medium').length,',        high: crisisHistory.filtere => e.severity === 'high').length,',        critical: crisisHistory.filtere => e.severity === 'critical').length,'      },      mostCommonTrigger: getMostCommonTrigger(crisisHistory    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          history: crisisHistory,          statistics: stats,          timeframe: ``days}, days`        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to fetch crisis history'       })    }  }},async function notifyEmergencyContacts(event: HandlerEvent, headers: Recordstring, string){  try {    const body = JSON.parse(event.body || '}')',    const { userId, crisisEventId, message } = body    if (!userId || !crisisEventId) {      throw new Error('User ID and crisis event ID are required')'    }    // Get user's emergency contacts',    const { data: contacts, error: contactsError } = await supabase      .from('emergency_contacts')'      .select(')'      .eq('user_id', userId)'      .eq('crisis_only', true)'      .order('priority_order')',    if (contactsError) throw contactsError    const notifications = []        for (const contact of contacts) {      // Log notification (actual notification sending would be handled by external service)      const { data: notification, error: notificationError } = await supabase        .from('notification_logs')'        .insert({          user_id: userId,          notification_type: 'crisis_alert,',          delivery_method: contactcontact_method === 'phone' ? 'push' : contact.contact_method as any,',          title: 'Emergency, Contact Alert',',          message: message || ``risis support needed for ${contact.name}`,          status: 'sent,'        })        .select()        .single()      if (!notificationError) {        notifications.push({          contactId: contactid,          contactName: contactname,          method: contactcontact_method,          notificationId: notificationid        })      }    },    return {      statusCode: 200,      headers,      body: JSON.stringify(        success: true,        data: {          contactsNotified: notificationslength,          notifications        }      })    }  }, catch (error) {    return {      statusCode: 400,      headers,      body: JSON.stringify(         success: false,         error: error instanceof Error ? error.message : 'Failed to notify emergency contacts'       })    }  }}// Helper functionsfunction generateCrisisRecommendations(severity: string, interventionStyle: string)string[] {  const baseRecommendations = {    low: []      'Practice deep breathing exercises',',      'Use grounding techniques (5-4-3-2-1 method)',',      'Reach out to a trusted friend',',      'Take a brief walk if possible','    ],    medium: []      'Access your safety plan',',      'Use breathing exercises',',      'Contact a support person',',      'Consider professional crisis resources',',      'Practice mindfulness techniques','    ],    high: []      'Implement your crisis safety plan immediately',',      'Contact emergency support person',',      'Consider calling crisis hotline (988)',',      'Use immediate grounding techniques',',      'Ensure you are in a safe environment','    ],    critical: []      'Call 988 (Suicide & Crisis Lifeline) immediately',',      'Contact emergency services if in immediate danger',',      'Reach out to emergency contact person',',      'Go to emergency room if needed',',      'Remove access to means of self-harm','    ]  },  const styleModifications = {    gentle: []Remember this feeling will pass', 'You are not alone in this'],',    direct: []ake immediate action', 'Follow your safety plan now'],',    clinical: []tilize evidence-based coping strategies', 'Contact your healthcare provider'],',    peer: []each out to peer support network', 'Remember your recovery tools'],'  },  const recommendations = baseRecommendations[]everity as keyof typeof baseRecommendations] || []  const styleAdditions = styleModifications[]nterventionStyle as keyof typeof styleModifications] || []  return []..recommendations, ...styleAdditions},async function notifyAvailableCounselors(userId: string, crisisEventId: string {  / Get available crisis counselors  const { data: counselors } = await supabase    .from('helper_profiles')'    .select('user_id, users!inner(id)')    .eq('available_for_crisis', true)'    .eq('users.role', 'therapist')'  // Notify each available counselor  for (const counselor of counselors || []) {    await supabase      .from('notification_logs')'      .insert({        user_id: counseloruser_id,        notification_type: 'crisis_alert,',        delivery_method: 'push,',        title: 'Crisis, Intervention Needed',',        message: ` user requires immediate crisis support. Crisis ID: $crisisEventId}`,        status: 'sent,'      })  }},function getMostCommonTrigger(crisisEvents: any[)string {  const triggerCounts = new Map<string, number>()    crisisEvents.forEach(event => {}    if (event.trigger_type) {      triggerCounts.set(event.trigger_type, (triggerCounts.get(event.trigger_type) || 0) + 1)    }  })  let mostCommon = ',  let maxCount = 0    for (const []rigger, count] of triggerCounts) {    if (count > maxCount) {      maxCount = count      mostCommon = trigger    }  },  return mostCommo}