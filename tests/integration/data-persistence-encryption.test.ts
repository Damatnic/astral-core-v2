/** * DATA PERSISTENCE AND ENCRYPTION INTEGRATION TESTS * Tests data storage, encryption, offline persistence, and data recovery */import { describe, test, expect, beforeEach, afterEach, jest }, from '@jest/globals';'// Mock encryption serviceconst mockEncryptionService = {  encrypt: jest.fn(,  decrypt: jest.fn(,  generateKeyPair: jest.fn(,  generateAnonymousKeyPair: jest.fn(,  encryptSessionOnly: jest.fn(,  clearAnonymousData: jest.fn(,  hashData: jest.fn(,  verifyHash: jest.fn(};// Mock storage servicesconst mockLocalStorageService = {  setItem: jest.fn(,  getItem: jest.fn(,  removeItem: jest.fn(,  clear: jest.fn(,  getAllKeys: jest.fn(};const mockSecureStorageService = {  secureStore: jest.fn(,  secureRetrieve: jest.fn(,  secureRemove: jest.fn(,  rotateKeys: jest.fn(,  validateIntegrity: jest.fn(};const mockOfflineService = {  storeOfflineData: jest.fn(,  retrieveOfflineData: jest.fn(,  syncOnlineData: jest.fn(,  clearOfflineData: jest.fn(,  getOfflineStatus: jest.fn(};jest.mock('../../src/services/encryptionService', () => ({',  getEncryptionService: ( => mockEncryptionService}));jest.mock('../../src/services/localStorageService', () => ({',  localStorageService: mockLocalStorageService}));jest.mock('../../src/services/secureStorageService', () => ({',  secureStorageService: mockSecureStorageService}));jest.mock('../../src/services/offlineService', () => ({',  offlineService: mockOfflineService}));describe('Data Persistence and Encryption Integration Tests', () => {}',  beforeEach(() => {}    jest.clearAllMocks();    // Mock IndexedDB and localStorage    Object.defineProperty(window, 'localStorage', {',      value: {        getItem: jest.fn(,        setItem: jest.fn(,        removeItem: jest.fn(,        clear: jest.fn(,        length: 0,        key: jest.fn(      },      writable: true    });  });  describe('Data Encryption and Decryption', () => {}',    test('encrypts sensitive user data before storage', async () => {}',      const sensitiveData = {        journalEntry: "Im struggling with depression and anxiety",",        moodRating: 3,        personalNotes: "Feeling, hopeless about work situation",",        timestamp: Date.now(      };      const mockEncryptedData = {        encryptedContent: 'encrypted_journal_content_12345,',        encryptionKey: 'user_specific_key_789,',        algorithm: 'AES-256-GCM,',        timestamp: Date.now(      };      mockEncryptionService.encrypt.mockResolvedValue(mockEncryptedData);      const encrypted = await mockEncryptionService.encrypt(sensitiveData, 'user_123');',      expect(encrypted.encryptedContent).toBe('encrypted_journal_content_12345');',      expect(encrypted.algorithm).toBe('AES-256-GCM');',      expect(mockEncryptionService.encrypt).toHaveBeenCalledWith(sensitiveData, 'user_123');'    });    test('decrypts user data successfully', async () => {}',      const encryptedData = {        encryptedContent: 'encrypted_journal_content_12345,',        encryptionKey: 'user_specific_key_789,',        algorithm: 'AES-256-GCM,',        timestamp: Date.now( - 1000      };      const expectedDecryptedData = {        journalEntry: "Im struggling with depression and anxiety",",        moodRating: 3,        personalNotes: "Feeling hopeless about work situation",",        timestamp: Date.now( - 1000      };      mockEncryptionService.decrypt.mockResolvedValue(expectedDecryptedData);      const decrypted = await mockEncryptionService.decrypt(encryptedData, 'user_123');',      expect(decrypted.journalEntry).toContain('struggling with depression');',      expect(decrypted.moodRating).toBe(3);    });    test('handles encryption key rotation', async () => {}',      const userData = { mood: 5, notes: "Feeling, better today" }";",      const oldKey = 'old_encryption_key_456';',      const newKey = 'new_encryption_key_789';',      mockSecureStorageService.rotateKeys.mockResolvedValue({        success: true,        oldDataReencrypted: true,        newKeyGenerated: newKey,        rotationTimestamp: Date.now(      });      const rotation = await mockSecureStorageService.rotateKeys('user_123', oldKey);',      expect(rotation.success).toBe(true);      expect(rotation.oldDataReencrypted).toBe(true);      expect(rotation.newKeyGenerated).toBe(newKey);    });    test('verifies data integrity after storage', async () => {}',      const originalData = {        sessionData: "Therapy, session notes",",        checksum: "original_checksum_123      };      mockEncryptionService.hashData.mockReturnValue('hash_verification_456');',      mockEncryptionService.verifyHash.mockReturnValue(true);      const hash = mockEncryptionService.hashData(originalData);      const isValid = mockEncryptionService.verifyHash(originalData, hash);      expect(hash).toBe('hash_verification_456');',      expect(isValid).toBe(true);    });    test('detects data tampering', async () => {}',      const originalData = { mood: 5, notes: "Original, notes" };",      const tamperedData = { mood: 5, notes: "Tampered, notes" };",      const originalHash = 'original_hash_123';',      mockEncryptionService.verifyHash.mockReturnValue(false);      const isValid = mockEncryptionService.verifyHash(tamperedData, originalHash);      expect(isValid).toBe(false);    });  });  describe('Anonymous Session Data Handling', () => {}',    test('creates ephemeral key pair for anonymous sessions', async () => {}',      const mockKeyPair = {        publicKey: 'anon_public_key_abc123,',        privateKey: 'anon_private_key_xyz789,',        algorithm: 'RSA-2048,',        sessionId: 'anon_session_456,',        expiresAt: Date.now( + (2 * 60 * 60 * 1000) // 2 hours      };      mockEncryptionService.generateAnonymousKeyPair.mockResolvedValue(mockKeyPair);      const keyPair = await mockEncryptionService.generateAnonymousKeyPair();      expect(keyPair.publicKey).toContain('anon_public_key');',      expect(keyPair.privateKey).toContain('anon_private_key');',      expect(keyPair.expiresAt).toBeGreaterThan(Date.now());    });    test('encrypts anonymous session data with session-only keys', async () => {}',      const anonymousMessage="I", need help but want to stay anonymous";",      const sessionId = 'anon_session_789';',      mockEncryptionService.encryptSessionOnly.mockResolvedValue('session_encrypted_content_456');',      const encrypted = await mockEncryptionService.encryptSessionOnly(anonymousMessage, sessionId);      expect(encrypted).toBe('session_encrypted_content_456');',      expect(mockEncryptionService.encryptSessionOnly).toHaveBeenCalledWith(anonymousMessage, sessionId);    });    test('automatically clears anonymous data on session end', async () => {}',      const sessionId = 'anon_session_cleanup';',      mockEncryptionService.clearAnonymousData.mockResolvedValue({        sessionDataCleared: true,        keysDestroyed: true,        browserStorageCleared: true,        memoryCleared: true      });      const cleanup = await mockEncryptionService.clearAnonymousData(sessionId);      expect(cleanup.sessionDataCleared).toBe(true);      expect(cleanup.keysDestroyed).toBe(true);      expect(cleanup.browserStorageCleared).toBe(true);    });    test('prevents anonymous data persistence beyond session', async () => {}',      const anonymousData = {        messages: []nonymous message 1", "Anonymous message 2"],",        sessionId: 'anon_test_session      };      // Anonymous data should not be stored permanently      mockLocalStorageService.setItem.mockImplementation((key, value) => {}        if (key.includes('anon_') || key.includes('anonymous')) {',          throw new Error('Anonymous data cannot be persisted');'        },        return true;      });      expect(() => {}        mockLocalStorageService.setItem('anon_persistent_data', JSON.stringify(anonymousData));'      }).toThrow('Anonymous data cannot be persisted');'    });  });  describe('Offline Data Persistence', () => {}',    test('stores data offline for later sync', async () => {}',      const offlineData = {        type: 'mood_entry,',        mood: 7,        notes: "Feeling better after exercise",",        timestamp: Date.now(,        syncStatus: 'pending      };      mockOfflineService.storeOfflineData.mockResolvedValue({        stored: true,        offlineId: 'offline_entry_123,',        estimatedSyncTime: 'next_connection,',        storageUsed: '2.5KB      });      const stored = await mockOfflineService.storeOfflineData(offlineData);      expect(stored.stored).toBe(true);      expect(stored.offlineId).toBe('offline_entry_123');',      expect(stored.estimatedSyncTime).toBe('next_connection');'    });    test('retrieves offline data when connection restored', async () => {}',      const offlineEntries = []        {          id: 'offline_1,',          type: 'mood_entry,',          data: { mood: 6, notes: "Offline, entry 1" },",          timestamp: Date.now( - 3600000        },        {          id: 'offline_2, ',          type: 'journal_entry,',          data: { content: "Offline, journal entry" },",          timestamp: Date.now( - 1800000        }      ];      mockOfflineService.retrieveOfflineData.mockResolvedValue({        entries: offlineEntries,        totalEntries: 2,        oldestEntry: Date.now( - 3600000,        storageSize: '5.2KB      });      const retrieved = await mockOfflineService.retrieveOfflineData('user_123');',      expect(retrieved.entries).toHaveLength(2);      expect(retrieved.entries[]].type).toBe('mood_entry');',      expect(retrieved.totalEntries).toBe(2);    });    test('syncs offline data with server when online', async () => {}',      const syncData = {        userId: 'user_123,',        offlineEntries: []          { id: 'offline_1, type: 'mood_entry, data: { mood: 6 } },'          { id: 'offline_2, type: 'journal_entry, data: { content: 'Entry } }"        ]      };      mockOfflineService.syncOnlineData.mockResolvedValue({        syncSuccessful: true,        entriesSynced: 2,        conflictsResolved: 0,        syncDuration: 1234, // milliseconds        nextSyncScheduled: Date.now( + (30 * 60 * 1000) // 30 minutes      });      const sync = await mockOfflineService.syncOnlineData(syncData);      expect(sync.syncSuccessful).toBe(true);      expect(sync.entriesSynced).toBe(2);      expect(sync.conflictsResolved).toBe(0);    });    test('handles sync conflicts gracefully', async () => {}',      const conflictData = {        userId: 'user_123,',        offlineEntry: {           id: 'mood_entry_456, ',          mood: 5,           timestamp: Date.now( - 1000,          lastModified: Date.now( - 1000        },        serverEntry: {          id: 'mood_entry_456,',          mood: 7,          timestamp: Date.now( - 1000,           lastModified: Date.now( - 500 // More recent        }      };      mockOfflineService.syncOnlineData.mockResolvedValue({        syncSuccessful: true,        conflictsResolved: 1,        resolutionStrategy: 'server_wins, // More recent timestamp',        mergedEntry: {          id: 'mood_entry_456,',          mood: 7, // Server value kept          note: 'Conflict, resolved - server version was more recent'        }      });      const sync = await mockOfflineService.syncOnlineData(conflictData);      expect(sync.conflictsResolved).toBe(1);      expect(sync.resolutionStrategy).toBe('server_wins');',      expect(sync.mergedEntry.mood).toBe(7);    });  });  describe('Secure Storage Management', () => {}',    test('stores sensitive data with additional security layer', async () => {}',      const sensitiveUserData = {        therapistNotes: "Patient, discussed trauma history",",        emergencyContacts: []          { name: "Dr., Smith", phone: "555-0123 },"          { name: "Sister, phone: "555-0456 },"        ],        medicationInfo: "Taking, sertraline 50mg daily"      };      mockSecureStorageService.secureStore.mockResolvedValue({        stored: true,        secureId: 'secure_storage_789,',        encryptionLevel: 'military_grade,',        backupCreated: true,        accessControls: []user_authentication, 'biometric_verification']'      });      const stored = await mockSecureStorageService.secureStore(        'user_123', ',        'sensitive_medical_data', ',        sensitiveUserData      );      expect(stored.stored).toBe(true);      expect(stored.encryptionLevel).toBe('military_grade');',      expect(stored.accessControls).toContain('biometric_verification');'    });    test('retrieves secure data with proper authentication', async () => {}',      const authCredentials = {        userId: 'user_123,',        biometricHash: 'biometric_verification_hash,',        sessionToken: 'authenticated_session_token      };      mockSecureStorageService.secureRetrieve.mockResolvedValue({        retrieved: true,        data: {          therapistNotes: "Patient discussed trauma history",",          emergencyContacts: [ ]ame: "Dr Smith", phone: "555-0123 }]"        },        accessLogged: true,        lastAccessed: Date.now(      });      const retrieved = await mockSecureStorageService.secureRetrieve(        'secure_storage_789',',        authCredentials      );      expect(retrieved.retrieved).toBe(true);      expect(retrieved.data.therapistNotes).toContain('trauma history');',      expect(retrieved.accessLogged).toBe(true);    });    test('validates data integrity on retrieval', async () => {}',      const storageId = 'secure_storage_789';',      mockSecureStorageService.validateIntegrity.mockResolvedValue({        integrityValid: true,        checksumMatch: true,        encryptionIntact: true,        noTampering: true,        lastValidated: Date.now(      });      const validation = await mockSecureStorageService.validateIntegrity(storageId);      expect(validation.integrityValid).toBe(true);      expect(validation.checksumMatch).toBe(true);      expect(validation.noTampering).toBe(true);    });    test('handles secure data corruption gracefully', async () => {}',      const corruptedStorageId = 'corrupted_storage_456';',      mockSecureStorageService.validateIntegrity.mockResolvedValue({        integrityValid: false,        checksumMatch: false,        corruptionDetected: true,        backupAvailable: true,        recoveryOptions: []restore_from_backup, 'request_user_reentry']'      });      const validation = await mockSecureStorageService.validateIntegrity(corruptedStorageId);      expect(validation.integrityValid).toBe(false);      expect(validation.corruptionDetected).toBe(true);      expect(validation.backupAvailable).toBe(true);      expect(validation.recoveryOptions).toContain('restore_from_backup');'    });  });  describe('Data Backup and Recovery', () => {}',    test('creates encrypted backups of user data', async () => {}',      const userDataToBackup = {        userId: 'user_123,',        journalEntries: []          { id: 'entry_1, content: 'Journal, entry 1", date: "2024-01-01 },'          { id: 'entry_2, content: 'Journal entry 2", date: "2024-01-02 }'        ],        moodEntries: []          { id: 'mood_1, mood: 7, date: '2024-01-01 },'          { id: 'mood_2, mood: 5, date: '2024-01-02 },'        ],        preferences: { theme: 'dark, notifications: true },'      };      mockSecureStorageService.secureStore.mockResolvedValue({        backupId: 'backup_2024_001,',        encrypted: true,        compressed: true,        backupSize: '15.7KB,',        backupLocation: 'secure_cloud_storage,',        verificationHash: 'backup_verification_hash_456      });      const backup = await mockSecureStorageService.secureStore(        'user_123',',        'user_data_backup',',        userDataToBackup      );      expect(backup.backupId).toBe('backup_2024_001');',      expect(backup.encrypted).toBe(true);      expect(backup.verificationHash).toBeDefined();    });    test('restores user data from backup', async () => {}',      const backupId = 'backup_2024_001';',      const userCredentials = {        userId: 'user_123,',        encryptionKey: 'user_recovery_key      };      mockSecureStorageService.secureRetrieve.mockResolvedValue({        restored: true,        data: {          journalEntries: [ ]d: 'entry_1, content: 'Restored, entry" }],",          moodEntries: [ ]d: 'mood_1, mood: 7 }],',          preferences: { theme: 'dark },'        },        restorationTimestamp: Date.now(,        integrityVerified: true      });      const restoration = await mockSecureStorageService.secureRetrieve(        backupId,        userCredentials      );      expect(restoration.restored).toBe(true);      expect(restoration.data.journalEntries).toHaveLength(1);      expect(restoration.integrityVerified).toBe(true);    });    test('maintains backup versioning and history', async () => {}',      const backupHistory = {        userId: 'user_123,',        requestType: 'list_backups      };      mockSecureStorageService.secureRetrieve.mockResolvedValue({        backups: []          {            id: 'backup_2024_003,',            created: Date.now( - 86400000, // 1 day ago            size: '16.2KB,',            type: 'automatic          },          {            id: 'backup_2024_002, ',            created: Date.now( - 172800000, // 2 days ago            size: '15.8KB,',            type: 'manual          },          {            id: 'backup_2024_001,',            created: Date.now( - 259200000, // 3 days ago              size: '15.1KB,',            type: 'automatic          }        ],        retentionPolicy: '30_days,',        nextAutoBackup: Date.now( + 3600000 // 1 hour      });      const history = await mockSecureStorageService.secureRetrieve(        'backup_history',',        backupHistory      );      expect(history.backups).toHaveLength(3);      expect(history.backups[]].type).toBe('automatic');',      expect(history.retentionPolicy).toBe('30_days');'    });  });  describe('Storage Quota and Management', () => {}',    test('monitors storage usage and limits', async () => {}',      mockOfflineService.getOfflineStatus.mockResolvedValue({        storageUsed: '125.6MB,',        storageAvailable: '374.4MB, ',        storageLimit: '500MB,',        usagePercentage: 2512,        quotaWarning: false,        cleanupRecommended: false      });      const storage = await mockOfflineService.getOfflineStatus();      expect(storage.usagePercentage).toBeLessThan(50);      expect(storage.quotaWarning).toBe(false);      expect(storage.cleanupRecommended).toBe(false);    });    test('triggers cleanup when storage limit approached', async () => {}',      mockOfflineService.getOfflineStatus.mockResolvedValue({        storageUsed: '425.7MB,',        storageAvailable: '74.3MB,',        storageLimit: '500MB, ',        usagePercentage: 8514,        quotaWarning: true,        cleanupRecommended: true,        cleanupCandidates: []          'old_offline_entries',',          'cached_images',',          'temporary_session_data'        ]      });      mockOfflineService.clearOfflineData.mockResolvedValue({        cleanupPerformed: true,        dataRemoved: '150.3MB,',        entriesRemoved: 45,        newUsagePercentage: 5508      });      const status = await mockOfflineService.getOfflineStatus();      const cleanup = await mockOfflineService.clearOfflineData({        targets: statuscleanupCandidates,        preserveRecent: true      });      expect(status.quotaWarning).toBe(true);      expect(cleanup.cleanupPerformed).toBe(true);      expect(cleanup.newUsagePercentage).toBeLessThan(60);    });  });});