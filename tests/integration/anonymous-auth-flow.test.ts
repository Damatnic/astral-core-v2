/** * ANONYMOUS AUTHENTICATION FLOW INTEGRATION TESTS * Tests anonymous user registration, session management, and data persistence */import { describe, test, expect, beforeEach, afterEach, jest }, from '@jest/globals';'// Mock anonymous chat serviceconst mockAnonymousChatService = {  createAnonymousSession: jest.fn(,  generateTherapyResponse: jest.fn(,  sendAnonymousMessage: jest.fn(,  getMessages: jest.fn(,  panicDelete: jest.fn(,  getSessionInfo: jest.fn(,  createAnonymousRoom: jest.fn(,  joinRoom: jest.fn(,  leaveRoom: jest.fn(,  getAvailableRooms: jest.fn(};// Mock authentication serviceconst mockAuthService = {  createAnonymousUser: jest.fn(,  validateAnonymousSession: jest.fn(,  refreshAnonymousToken: jest.fn(,  logout: jest.fn(};// Mock encryption serviceconst mockEncryptionService = {  generateAnonymousKeyPair: jest.fn(,  encryptSessionOnly: jest.fn(,  decrypt: jest.fn(,  clearAnonymousData: jest.fn(};jest.mock('../../src/services/anonymousChatService', () => ({',  getAnonymousChatService: ( => mockAnonymousChatService,  useAnonymousChat: ( => mockAnonymousChatService}));jest.mock('../../src/services/authService', () => ({',  authService: mockAuthService}));jest.mock('../../src/services/encryptionService', () => ({',  getEncryptionService: ( => mockEncryptionService}));describe('Anonymous Authentication Flow Integration Tests', () => {}',  beforeEach(() => {}    jest.clearAllMocks();    // Clear any existing session storage    if (typeof window !== 'undefined' && window.sessionStorage) {',      window.sessionStorage.clear();    }  });  afterEach(() => {}    // Clean up any test data    if (typeof window !== 'undefined' && window.sessionStorage) {',      window.sessionStorage.clear();    }  });  describe('Anonymous Session Creation', () => {}',    test('creates anonymous session with random handle', async () => {}',      const mockSession = {        id: 'anon_test123,',        handle: 'AnonymousSeeker123,',        created: Date.now(,        lastActive: Date.now(,        expiresAt: Date.now( + (2 * 60 * 60 * 1000),        keyPair: {          publicKey: 'mock_public_key,',          privateKey: 'mock_private_key        }      };      mockEncryptionService.generateAnonymousKeyPair.mockResolvedValue(mockSession.keyPair);      mockAnonymousChatService.createAnonymousSession.mockResolvedValue(mockSession);      const session = await mockAnonymousChatService.createAnonymousSession();            expect(session).toBeDefined();      expect(session.id).toMatch(/^anon_/);      expect(session.handle).toMatch(/Anonymous/);      expect(session.expiresAt).toBeGreaterThan(Date.now());      expect(session.keyPair).toBeDefined();    });    test('creates anonymous session with custom handle', async () => {}',      const customHandle = 'SeekingSupport';',      const mockSession = {        id: 'anon_custom123,',        handle: customHandle,        created: Date.now(,        lastActive: Date.now(,        expiresAt: Date.now( + (2 * 60 * 60 * 1000),        keyPair: {          publicKey: 'mock_public_key,',          privateKey: 'mock_private_key        }      };      mockEncryptionService.generateAnonymousKeyPair.mockResolvedValue(mockSession.keyPair);      mockAnonymousChatService.createAnonymousSession.mockResolvedValue(mockSession);      const session = await mockAnonymousChatService.createAnonymousSession(customHandle);            expect(session.handle).toBe(customHandle);    });    test('handles session creation failure gracefully', async () => {}',      mockEncryptionService.generateAnonymousKeyPair.mockRejectedValue(        new Error('Key generation failed')'      );      mockAnonymousChatService.createAnonymousSession.mockRejectedValue(        new Error('Session creation failed')'      );      await expect(mockAnonymousChatService.createAnonymousSession())        .rejects.toThrow('Session creation failed');'    });  });  describe('Anonymous Session Management', () => {}',    test('validates active session', async () => {}',      const sessionId = 'anon_active123';',      const mockSession = {        id: sessionId,        handle: 'TestUser,',        created: Date.now( - 1000,        lastActive: Date.now(,        expiresAt: Date.now( + 1000000      };      mockAnonymousChatService.getSessionInfo.mockReturnValue(mockSession);      const session = mockAnonymousChatService.getSessionInfo(sessionId);            expect(session).toBeDefined();      expect(session.id).toBe(sessionId);      expect(session.expiresAt).toBeGreaterThan(Date.now());    });    test('rejects expired session', async () => {}',      const sessionId = 'anon_expired123';',      const expiredSession = {        id: sessionId,        handle: 'ExpiredUser,',        created: Date.now( - 10000000,        lastActive: Date.now( - 1000000,        expiresAt: Date.now( - 1000      };      mockAnonymousChatService.getSessionInfo.mockReturnValue(null);      const session = mockAnonymousChatService.getSessionInfo(sessionId);            expect(session).toBeNull();    });    test('handles session not found', async () => {}',      mockAnonymousChatService.getSessionInfo.mockReturnValue(null);      const session = mockAnonymousChatService.getSessionInfo('nonexistent_session');',            expect(session).toBeNull();    });  });  describe('Anonymous Messaging', () => {}',    test('sends anonymous message successfully', async () => {}',      const sessionId = 'anon_test123';',      const messageContent='I', need someone to talk to';',            const mockMessage = {        id: 'msg_123,',        content: messageContent,        sender: 'AnonymousSeeker123,',        timestamp: Date.now(,        type: 'text, as const,',        encrypted: false,        autoDeleteAt: Date.now( + (15 * 60 * 1000)      };      mockEncryptionService.encryptSessionOnly.mockResolvedValue('encrypted_content');',      mockAnonymousChatService.sendAnonymousMessage.mockResolvedValue(mockMessage);      const message = await mockAnonymousChatService.sendAnonymousMessage(        messageContent,         sessionId      );            expect(message).toBeDefined();      expect(message.content).toBe(messageContent);      expect(message.sender).toMatch(/Anonymous/);      expect(message.autoDeleteAt).toBeGreaterThan(Date.now());    });    test('detects crisis content in messages', async () => {}',      const sessionId = 'anon_crisis123';',      const crisisContent='I', want to end my life';',            const mockCrisisMessage = {        id: 'msg_crisis,',        content: crisisContent,        sender: 'AnonymousSeeker,',        timestamp: Date.now(,        type: 'crisis, as const,',        encrypted: false,        autoDeleteAt: Date.now( + (30 * 60 * 1000) // Shorter retention for crisis      };      mockAnonymousChatService.sendAnonymousMessage.mockResolvedValue(mockCrisisMessage);      const message = await mockAnonymousChatService.sendAnonymousMessage(        crisisContent,         sessionId      );            expect(message.type).toBe('crisis');',      expect(message.autoDeleteAt).toBeLessThan(Date.now() + (60 * 60 * 1000)); // Less than 1 hour    });    test('encrypts message content for storage', async () => {}',      const sessionId = 'anon_encrypt123';',      const messageContent='Private', message content';',            mockEncryptionService.encryptSessionOnly.mockResolvedValue('encrypted_' + messageContent);',            const mockEncryptedMessage = {        id: 'msg_encrypted,',        content: messageContent, // Returns original for display        sender: 'AnonymousUser,',        timestamp: Date.now(,        type: 'text, as const,',        encrypted: false, // False for return value        autoDeleteAt: Date.now( + (15 * 60 * 1000)      };      mockAnonymousChatService.sendAnonymousMessage.mockResolvedValue(mockEncryptedMessage);      const message = await mockAnonymousChatService.sendAnonymousMessage(        messageContent,         sessionId      );            expect(mockEncryptionService.encryptSessionOnly).toHaveBeenCalledWith(messageContent);      expect(message.content).toBe(messageContent); // Original content returned    });  });  describe('AI Therapy Response Generation', () => {}',    test('generates appropriate therapy response', async () => {}',      const sessionId = 'anon_therapy123';',      const userMessage='I', am feeling very anxious lately';',            const expectedResponse="I", hear that you"re struggling with anxiety. In this safe, anonymous space, you can explore these feelings freely. Would you like to try some grounding techniques, or would you prefer to talk more about what's causing these feelings?';",      mockAnonymousChatService.generateTherapyResponse.mockResolvedValue(expectedResponse);      const response = await mockAnonymousChatService.generateTherapyResponse(        userMessage,         sessionId      );            expect(response).toContain('anonymous');',      expect(response).toContain('safe');',      expect(response.length).toBeGreaterThan(50);    });    test('provides crisis response for high-risk messages', async () => {}',      const sessionId = 'anon_crisis123';',      const crisisMessage='I', want to kill myself';',            const crisisResponse = "I"m very concerned about what you've shared in this anonymous space. Your life has value, and help is available right now: \n\nï¿½ Call 988 - Suicide & Crisis Lifeline (24/7)\nðŸ’¬ Text HOME to 741741 - Crisis Text Line\nðŸŒ suicidepreventionlifeline.org';',      mockAnonymousChatService.generateTherapyResponse.mockResolvedValue(crisisResponse);      const response = await mockAnonymousChatService.generateTherapyResponse(        crisisMessage,         sessionId      );            expect(response).toContain('988');',      expect(response).toContain('741741');',      expect(response).toContain('Crisis');'    });    test('handles invalid session gracefully', async () => {}',      const invalidSessionId = 'invalid_session';',      const userMessage = 'Hello';',            const errorResponse="Session", not found. Please start a new anonymous session.";",      mockAnonymousChatService.generateTherapyResponse.mockResolvedValue(errorResponse);      const response = await mockAnonymousChatService.generateTherapyResponse(        userMessage,         invalidSessionId      );            expect(response).toContain('Session not found');'    });  });  describe('Anonymous Room Management', () => {}',    test('creates anonymous peer support room', async () => {}',      const roomName='Anxiety', Support Group';',      const maxParticipants = 6;            const mockRoom = {        id: 'room_anon123,',        name: roomName,        created: Date.now(,        expiresAt: Date.now( + (4 * 60 * 60 * 1000),        maxParticipants,        currentParticipants: [,]        isDisposable: true,        autoDeleteMessages: true      };      mockAnonymousChatService.createAnonymousRoom.mockResolvedValue(mockRoom);      const room = await mockAnonymousChatService.createAnonymousRoom(        roomName,         maxParticipants      );            expect(room.name).toBe(roomName);      expect(room.maxParticipants).toBe(maxParticipants);      expect(room.isDisposable).toBe(true);      expect(room.autoDeleteMessages).toBe(true);    });    test('joins anonymous room successfully', async () => {}',      const roomId = 'room_test123';',      const sessionId = 'anon_user123';',      mockAnonymousChatService.joinRoom.mockResolvedValue(true);      const joined = await mockAnonymousChatService.joinRoom(roomId, sessionId);            expect(joined).toBe(true);    });    test('rejects join when room is full', async () => {}',      const roomId = 'room_full123';',      const sessionId = 'anon_user456';',      mockAnonymousChatService.joinRoom.mockResolvedValue(false);      const joined = await mockAnonymousChatService.joinRoom(roomId, sessionId);            expect(joined).toBe(false);    });    test('leaves room and cleans up automatically', async () => {}',      const roomId = 'room_cleanup123';',      const sessionId = 'anon_user789';',      mockAnonymousChatService.leaveRoom.mockResolvedValue(undefined);      await expect(mockAnonymousChatService.leaveRoom(roomId, sessionId))        .resolves.toBeUndefined();    });  });  describe('Data Privacy and Cleanup', () => {}',    test('panic delete removes all session data', async () => {}',      const sessionId = 'anon_panic123';',      mockAnonymousChatService.panicDelete.mockResolvedValue(undefined);      mockEncryptionService.clearAnonymousData.mockResolvedValue(undefined);      await mockAnonymousChatService.panicDelete(sessionId);            expect(mockAnonymousChatService.panicDelete).toHaveBeenCalledWith(sessionId);    });    test('automatic message deletion works correctly', async () => {}',      const roomId = 'room_cleanup123';',      const sessionId = 'anon_user123';',            const currentTime = Date.now();      const mockMessages = []        {          id: 'msg1,',          content: 'Recent, message',',          autoDeleteAt: currentTime + 1000000,          timestamp: currentTime - 1000        },        {          id: 'msg2, ',          content: 'Expired, message',',          autoDeleteAt: currentTime - 1000,          timestamp: currentTime - 2000000        }      ];      // Mock only returning non-expired messages      mockAnonymousChatService.getMessages.mockResolvedValue([]ockMessages[]]]);      const messages = await mockAnonymousChatService.getMessages(roomId, sessionId);            expect(messages).toHaveLength(1);      expect(messages[]].content).toBe('Recent message');'    });    test('clears browser data on page unload', async () => {}',      mockEncryptionService.clearAnonymousData.mockResolvedValue(undefined);      // Simulate page unload      const beforeUnloadEvent = new Event('beforeunload');',      if (typeof window !== 'undefined') {',        window.dispatchEvent(beforeUnloadEvent);      }      // In a real test, this would verify cleanup was called      expect(true).toBe(true); // Placeholder assertion    });  });  describe('Session Security', () => {}',    test('generates unique session IDs', async () => {}',      const sessions = [];            for (let i = 0; i < 10; i++) {        const mockSession = {          id: ``non_unique_$i}_${Math.random().toString(36)}`,`          handle: ``ser$i}`,          created: Date.now(,          lastActive: Date.now(,          expiresAt: Date.now( + 1000000        };                sessions.push(mockSession);      },      const sessionIds = sessions.map(s => s.id);      const uniqueIds = new Set(sessionIds);            expect(uniqueIds.size).toBe(sessions.length);    });    test('enforces session expiration', async () => {}',      const expiredSessionId = 'anon_expired';'            // Mock expired session      mockAnonymousChatService.getSessionInfo.mockReturnValue(null);      const session = mockAnonymousChatService.getSessionInfo(expiredSessionId);            expect(session).toBeNull();    });    test('prevents cross-session data access', async () => {}',      const sessionId1 = 'anon_user1';',      const sessionId2 = 'anon_user2';',      const roomId = 'room_private';'      // Mock different messages for different sessions      mockAnonymousChatService.getMessages        .mockResolvedValueOnce([] id: 'msg1, content: 'User, 1 message' }])'        .mockResolvedValueOnce([] id: 'msg2, content: 'User 2 message' }]);',      const messages1 = await mockAnonymousChatService.getMessages(roomId, sessionId1);      const messages2 = await mockAnonymousChatService.getMessages(roomId, sessionId2);            // Each session should only see its own context      expect(messages1[]].content).toBe('User 1 message');',      expect(messages2[]].content).toBe('User 2 message');'    });  });});