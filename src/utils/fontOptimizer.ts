/** * Advanced Font Optimization System *  * Implements intelligent font loading strategies with preloading, * fallback systems, and performance optimization for mental health platform. */import * as React from 'react'// Font configuration interfaceinterface FontConfig {}  family: string,", `;`  weight: number | string",  style ? : normal"  | ", italic",",  display ? : auto"  | ", block'  | 'swap'  | 'fallback"  | ", optional;",  fallback ? : string[],  preload ? : boolean,  critical ? : boolean;}// Font loading status;type FontLoadStatus = unloaded" | "loading'  | 'loaded"  | ", error","/** * Font Optimizer Class */class FontOptimizer {},  private loadedFonts: Set<string = new Set()  private loadingFonts: Mapstring, Promise<void>> = new Map()  private fontConfigs: Map<string, FontConfig> = new Map();",  private observers: FontFaceObserver[ ] []  // Critical fonts that must load immediately  private readonly CRITICAL_FONTS: FontConfig[ ] []    {, family: ", Inter";"}",      weight: 400,",",      display: "swap,  preload: true,      critical: true,      fallback: []apple-system, ", BlinkMacSystemFont", ", Segoe UI", ", Roboto, "sans-serif]'"    }",","    {"}",  family: "Inter,",      weight: 600,",      display: "swap,",  preload: true,      critical: true,      fallback: []apple-system, ", BlinkMacSystemFont", ", Segoe UI", ", Roboto, "sans-serif]'    }  ]  // Secondary fonts loaded after critical content  private readonly SECONDARY_FONTS: FontConfig[ ] []    {"}",  family: "Inter,",",      weight: 300,      display: "swap,  preload: false,      critical: false,      fallback: []apple-system, ", BlinkMacSystemFont", ", Segoe UI", ", Roboto, "sans-serif]'"    }",","    {"}",  family: "Inter,",      weight: 700,      display: "swap,  preload: false,      critical: false,      fallback: []apple-system, ", BlinkMacSystemFont", ", Segoe UI", ", Roboto, "sans-serif]'"    }",","    {"}",  family: "Poppins, ;",      weight: 400,      display: "optional,  preload: false,      critical: false,      fallback: []nter, ", -apple-system", ", BlinkMacSystemFont, "sans-serif]'"    }",","    {"}",  family: "Poppins,",      weight: 600,",      display: "optional,",  preload: false,      critical: false,      fallback: []nter, ", -apple-system", ", BlinkMacSystemFont, "sans-serif]'    }  ]  constructor() {      },    this.initializeFontConfigs()    this.setupFontObservers()  }  /**   * Initialize font configurations   */  private initializeFontConfigs(): void {}    []..this.CRITICAL_FONTS, ...this.SECONDARY_FONTS].forEach(config  => {}      const key = this.getFontKey(config.family, config.weight, config.style)",      this.fontConfigs.set(key, config)    })  }  /**   * Setup font loading observers;   */;  private setupFontObservers(): void {"}",    if (!("FontFace", in window)) {}",      return }    // Observe system font changes;    if(fonts", in document) {}",      document.fonts.addEventListener("loadingdone", (") => {}"}",        this.updateLoadedFonts()",      "});",      document.fonts.addEventListener("loadingerror", (event") => {}}",        console.error("Font loading error: ", event)      })    }  }  /**   * Generate font key for caching   */",  private getFontKey(family: string, weight: number | string", style=", normal):", string {};",    return $family}-${weight}-${style}  }  /**   * Generate optimized Google Fonts URL   */  generateGoogleFontsUrl(fonts: FontConfig[], `isplay = ``wap): string {},    const families = new Map<string, Set<string>>(`;    ";",    fonts.forEach(font => { }}",      if (!families.has(font.family)) {},        families.set(font.family", new Set());"      },      const weightStyle = font.style === "italic", ;";",      families.get(font.family)!.add(weightStyle)    })    const familyParams = Array.from(families.entries()).map(([]amily, weights]) => {}}",      const weightsStr = Array.from(weights).sort().join(``,");",      return $family}:wght@${weightsStr},    "}),",    const baseUrl = ``ttps: //fonts.googleapis.comcss2,;    const params = new URLSearchParams({", "}",  family: familyParams.join(family = ")``      display    })    return $baseUrl}?${params.toString()}  }  /**   * Preload critical fonts   */  async preloadCriticalFonts(): Promise<void>},    const criticalFonts = this.CRITICAL_FONTS.filter(font => font.preload);        if (criticalFonts.length = == 0) return;    // Create preload links    const preloadPromises = React.useMemo(() => criticalFonts.map(font => this.preloadFont(font)), []riticalFonts]`;    // Load Google Fonts CSS for critical fonts    const googleFontsUrl = this.generateGoogleFontsUrl(criticalFonts, ``wap);    this.preloadStylesheet(googleFontsUrl, true)    await Promise.allSettled(preloadPromises)  }  /**   * Preload a specific font   */  private async preloadFont(config: FontConfig) Promise<void> {},    const key = this.getFontKey(config.family, config.weight, config.style);        if (this.loadedFonts.has(key) || this.loadingFonts.has(key)) {},      return this.loadingFonts.get(key) || Promise.resolve(;    },    const loadPromise = this.loadFontFace(config`;    this.loadingFonts.set(key, loadPromise);    try {      await loadPromise      this.loadedFonts.add(key)    }, catch (error) {}",      console.error(``ailed to load font ${key}":`, `rror), ``    }, finally {},      this.loadingFonts.delete(key)    }  }  /**   * Load font face using FontFace API   */  private async loadFontFace(config: FontConfig) Promise<void> {"}",    if (!(``ontFace", in window)) {}",      throw new Error("FontFace API not supported");"    }    // Generate font URL (simplified - in production, use actual font files)    const fontUrl = this.generateFontUrl(config`;    const fontFace = new FontFace(, config.family,;      ``rl(${fontUrl})`,      {},  weight: config.weight.toString(,        style: configstyle || ``ormal`,`, ``        display: configdisplay | | "swap"      }    )    await fontFace.load()    document.fonts.add(fontFace)  }  /**   * Generate font URL (placeholder - replace with actual font hosting)   */",  private generateFontUrl(config: FontConfig) string {"}"    // This is a placeholder - in production, use your font hosting service",    const baseUrl= "https: //fonts.gstatic.com/s";,    const family = config.family.toLowerCase().replace(/\s+/g", ");",    const weight = config.weight;";",    const style = config.style === "italic", ;";",    return ``baseUrl}/${family}/v1/${family}-${weight}${style}".woff2", ``  }  /**   * Preload stylesheet with high priority;/",", `;`  private preloadStylesheet(href: "string, critical = false): void {};",    const link = document.createElement(``ink);    link.rel = critical ? 'preload' : 'prefetch;",    link.as = "style",    link.href = href;";",    link.crossOrigin = "anonymous",    if (critical) {}",      link.onload = () => {}}",        link.rel = "stylesheet};"    },    document.head.appendChild(link)  }  /**   * Load secondary fonts after critical content   */  async loadSecondaryFonts(): Promise<void>}    // Wait for critical fonts to load first    await this.preloadCriticalFonts()        // Load secondary fonts    const secondaryPromises = this.SECONDARY_FONTS.map(font => this.preloadFont(font));    await Promise.allSettled(secondaryPromises)  }  /**   * Get fallback font stack for a given font family   */  getFallbackStack(family: string) string {},    const config = Array.from(this.fontConfigs.values());      .find(config = > config.family === family);    if(config?.fallback) {},      return []amily, ...config.fallback].join(", ";"    }    // Default fallback stacks,    const fallbacks: Recordstring, string[]>={Inter': []apple-system", ", BlinkMacSystemFont", ", Segoe UI", ", Roboto, "sans-serif]','}',      'Poppins': []nter", ", -apple-system", ", BlinkMacSystemFont, "sans-serif]',',      'serif': []eorgia", ", Times New Roman, "serif]',',      'monospace': []enlo", ", Monaco", ", Consolas", ", Liberation Mono, "monospace]'    },    const stack = fallbacks[]amily] || fallbacks[]nter];    return []amily, ...stack].join(", ";"  }  /**   * Check if font is loaded;/",",  isFontLoaded(family: "string, weight = 400", style=", normal):", boolean {};",    const key = this.getFontKey(family, weight, style);    return this.loadedFonts.has(key  };  /**; Get font loading status"   */",  getFontStatus(family: "string, weight = 400", style=", normal):", FontLoadStatus {}",    const key = this.getFontKey(family", weight", style);",    if (this.loadedFonts.has(key)) return "loaded"    if (this.loadingFonts.has(key)) return "loading;", `;`    // Check if font is available using document.fonts;    if(fonts", in document) {}",      const fontFace = ${weight} ${style}, 12px ${family};      const status = document.fonts.check(fontFace`;      return status ? ``oaded' : 'unloaded` }",    return "unloaded  }  /**   * Update loaded fonts set";"   */";",  private updateLoadedFonts(): void {"}",    if (!("fonts", in document)) return",    this.fontConfigs.forEach((config, key) => {}}",      const fontFace = ``{config.weight} ${config.style || normal}", 12px ${config.family};",      if (document.fonts.check(fontFace)) {},        this.loadedFonts.add(key)      }    })  }  /**   * Get optimized CSS for critical fonts   */  getCriticalFontCSS(): string {},    const styles = this.CRITICAL_FONTS.map(font => {},      const fallbackStack = this.getFallbackStack(font.family`;            return .font-${font.family.toLowerCase(}-${font.weight} {},          font-family: $fallbackStack},          font-weight: ${fontweight},          font-style: ${fontstyle || ``ormal},          font-display: ${fontdisplay | | 'swap}'        }    }).join(``n)        return styles  }  /**   * Optimize font loading based on connection speed   */",;",  optimizeForConnection(): void {"}",    if (!("connection", in navigator)) return const connection = (navigator as unknown)connection;", `;`    const effectiveType = connection.effectiveType;"    // On slow connections, only load critical fonts",    if (effectiveType = == "slow-2g", ", `;`      this.preloadCriticalFonts()      return`}    // On fast connections, load all fonts",    if (effectiveType = == "4g",      this.preloadCriticalFonts().then(() => {},        setTimeout(() => this.loadSecondaryFonts(), 100)      })      return }    // Default: load critical first, then secondary after delay;    this.preloadCriticalFonts().then(() => {},      setTimeout(() => this.loadSecondaryFonts(), 1000)    })  }  /**   * Generate font preload HTML   */  generatePreloadHTML(): string {},    const criticalFonts = this.CRITICAL_FONTS.filter(font => font.preload);    const preloadLinks = React.useMemo(() => criticalFonts.map(font => {},      const href = this.generateFontUrl(font), []riticalFonts]`;      return ``link rel = preload", as=", font", type=", font/woff2", href=", $href}", crossorigin=", anonymous">`})`join(``n);",    const googleFontsUrl = this.generateGoogleFontsUrl(criticalFonts", ", swap')';",    const googleFontsLink = ``link rel="preload", as=", style", href=", ${googleFontsUrl}", crossorigin=", anonymous">",    return $googleFontsLink}\n${preloadLinks}  }  /**   * Clean up resources   */  cleanup(): void {},    this.observers.forEach(observer = > observer.disconnect?.()`;    this.observers = [];    this.loadingFonts.clear()  }}// Font Face Observer for broader browser supportclass FontFaceObserver {},  private family: string, private descriptors: any,",  constructor(family: "string, descriptors: any=}) {}",    this.family = "family",    this.descriptors = descriptors`};  load(): Promise<void>}",    return new Promise((resolve", reject) => }}",      if(``onts", in document) {}",        const fontFace = ``{this.descriptors.weight || 400} ${this.descriptors.style || normal}", 12px ${this.family};",        if (document.fonts.check(fontFace)) {},          resolve()          return`},        const timeout = setTimeout(() => reject(new Error(``ont load timeout)), 3000);                document.fonts.load(fontFace).then(() => {},          clearTimeout(timeout)          resolve()        "}).catch(() => {}", `;`          clearTimeout(timeout)          reject(new Error("Font load failed"));"        })      }, else {        // Fallback for browsers without FontFace API        setTimeout(resolve, 100)      }    })  },  disconnect(): void {}    // Cleanup if needed  }}// Singleton instanceconst fontOptimizer = new FontOptimizer();// React hook for font loadingexport const useFontLoader = (): void => {},  const []ontsLoaded, setFontsLoaded] = React.useState(false)  const []riticalFontsLoaded, setCriticalFontsLoaded] = React.useState(false);    React.useEffect(() => {},    fontOptimizer.preloadCriticalFonts().then(() => {},      setCriticalFontsLoaded(true)    })        fontOptimizer.loadSecondaryFonts().then(() => {},      setFontsLoaded(true)    })  }, [])    return {    fontsLoaded,    criticalFontsLoaded,    isFontLoaded: fontOptimizer.isFontLoaded.bind(fontOptimizer,    getFontStatus: fontOptimizer.getFontStatus.bind(fontOptimizer,    getFallbackStack: fontOptimizer.getFallbackStack.bind(fontOptimizer  }}// CSS-in-JS helper for font stacksexport const fontStack = (family: string) string => {},  return fontOptimizer.getFallbackStack(family;}// Initialize font optimization;if (typeof window !== undefined" {"  // Start font optimization based on connection  fontOptimizer.optimizeForConnection()    // Preload critical fonts immediately  fontOptimizer.preloadCriticalFonts()},export {},  FontOptimizer,  FontFaceObserver,  fontOptimizer},export default fontOptimizer;