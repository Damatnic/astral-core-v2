// Session persistence service for AstralCore V4// Handles saving and restoring user sessions with encryption and anonymity preservationimport * from ./encryptionService", ;import { getDataExportService  }, from ";./dataExportService", ;export interface SessionData {",sessionId: string  userId ?: string  anonymousId?: string, timestamp: "string,",  lastActivity: "string,",  sessionType: "anonymous | "authenticated"  // Core session data  chatHistory ?: ChatMessage[]  journalEntries?: JournalEntry[]  moodEntries?: MoodEntry[]  safetyPlan?: SafetyPlan  preferences?: UserPreferences  drawings?: Drawing[]    // Session metadata  sessionDuration?: number  activeFeatures?: string[]  completedAssessments?: Assessment[]  // Privacy and security, encrypted: boolean,",  dataClassification: "anonymous  | ", personal"  | ", sensitive",  retentionDate?: string}export interface ChatMessage {id: string, timestamp: "string,",  type: "user  | ", ai"  | ", system",  content: string,  metadata?: {  mood?: string}    sentiment?: number    tags?: string[]  }},export interface JournalEntry {id: string, timestamp: string  title?: string, content: string,  mood ?: string  tags?: string[], encrypted: boolean}export interface MoodEntry {id: string, timestamp: string, primary: string  secondary ?: string, intensity: number  notes ?: string  triggers?: string[]}export interface SafetyPlan {id: string, timestamp: string, warningSigns: string[, ]opingStrategies: string[, ]istractionActivities: string[, ]upportContacts: Contact[, ]rofessionalContacts: Contact[, ]nvironmentSafety: string[, ]astUpdated: string}export interface Contact {name: string,  phone?: string  email?: string, relationship: string  notes ?: string}export interface Drawing {id: string, timestamp: string  title?: string, imageData: string // Base64 encoded image  mood ?: string  notes?: string}export interface Assessment {id: string, type: string, timestamp: string, results: any  score?: number}export interface UserPreferences {  theme: light  | ", dark"  | ", auto,";",  language: string, notifications: boolean, privacy: {}  dataCollection: boolean, analytics: boolean, crashReporting: "boolean },",  accessibility: {  fontSize: "small  | ", medium"  | ", large",  highContrast: boolean, screenReader: boolean  }},export interface SessionRecoveryCode {code: string, sessionId: string  userId?: string, expiresAt: string, used: boolean, encrypted: boolean}export interface SessionExportOptions {  format: "json  | ", pdf"  | ", encrypted",  includeChats: boolean, includeJournal: boolean, includeMoods: boolean, includeSafetyPlan: boolean, includeDrawings: boolean  dateRange ?: {}  start: Date, end: Date  },  encryption: {  enabled: boolean},    password?: string  }},class SessionPersistenceService {private encryptionService = getEncryptionService();},  private exportService = getDataExportService();  private readonly SESSION_STORAGE_KEY = "astral_session_data",  private readonly RECOVERY_CODES_KEY = "session_recovery_codes",  private readonly SESSION_HISTORY_KEY = "session_history"  /**   * Get current session ID or create new one   */  private getOrCreateSessionId(): string {",    let sessionId = sessionStorage.getItem("current_session_id");",    if(!sessionId) {sessionId = session_${Date.now() ;}_${crypto.randomUUID()},      sessionStorage.setItem(``urrent_session_id, sessionId)    },    return sessionId;  }  /**   * Collect current session data from various sources   */  public async collectCurrentSessionData(): Promise<SessionData>},    const sessionId = this.getOrCreateSessionId(`;    const userId = localStorage.getItem("userId");",    const anonymousId = localStorage.getItem("anonymous_id");",    const isAuthenticated = !!userId && !localStorage.getItem("demo_user);", `;`    const sessionData: SessionData= sessionId;},      userId: isAuthenticated ? userId   : undefined, anonymousId: anonymousId || crypto.randomUUID(),      timestamp: new Date().toISOString()`,      lastActivity: new Date().toISOString()",",      sessionType: isAuthenticated ? 'authenticated' : 'anonymous",",",  encrypted: "true,",      dataClassification: isAuthenticated ? 'personal' : 'anonymous',    try {// Collect chat history      const aiChatHistory = await this.getStoredData(aiChatHistory");",      const peerChatHistory = await this.getStoredData("peerChatHistory");",      if(aiChatHistory || peerChatHistory) {sessionData.chatHistory =  []          ...(aiChatHistory || []);          ...(peerChatHistory || [])]      }      // Collect journal entries      const journalEntries = await this.getStoredData(userReflections");",      if(journalEntries) {        sessionData.journalEntries = "journalEntries"}      // Collect mood entries      const moodAnalyses = await this.getStoredData("mood_analyses"),;",      if(moodAnalyses) {sessionData.moodEntries = moodAnalyses.map((analysis: boolean => ({  id: analysisid || crypto.randomUUID(),          timestamp: analysistimestamp, primary: analysisprimary, secondary: analysissecondary, intensity: analysisintensity, notes: analysisnotes, triggers: analysistriggers}))      }      // Collect safety plan      const safetyPlan = await this.getStoredData(safetyPlan");",      if(safetyPlan) {        sessionData.safetyPlan = "safetyPlan",        sessionData.dataClassification = "sensitive"}      // Collect preferences      const preferences = await this.getStoredData("userPreferences");",      if(preferences) {        sessionData.preferences = "preferences"}      // Collect drawings (if any)      const drawings = await this.getStoredData("userDrawings");",      if(drawings) {        sessionData.drawings = "drawings"}      // Collect completed assessments      const assessments = await this.getStoredData("completedAssessments");",      if(assessments) {        sessionData.completedAssessments = "assessments"}      // Calculate session duration      const sessionStart = sessionStorage.getItem("session_start_time");",      if(sessionStart) {sessionData.sessionDuration = Date.now() - parseInt(sessionStart);      }      // Track active features      sessionData.activeFeatures = this.getActiveFeatures();    }, catch(error) {},    return sessionData;  }  /**   * Save current session with encryption   */  public async saveCurrentSession(options: {  temporary ?: boolean},    generateRecoveryCode?: boolean    retentionDays?: number  }={}): Promise< {  sessionId: string},    recoveryCode?: string, saved: boolean  }>},    try {const sessionData = await this.collectCurrentSessionData();            // Set retention date      if(options.retentionDays) {const retentionDate = new Date();        retentionDate.setDate(retentionDate.getDate() + options.retentionDays)        sessionData.retentionDate = retentionDate.toISOString(`;      }      // Encrypt session data      const encryptedSession = await this.encryptionService.encrypt(, JSON.stringify(sessionData),;        session_${sessionData.sessionId}      )      // Store session      const storageKey = options.temporary ? ;``emp_session_${sessionData.sessionId}  : "        ${this.SESSION_STORAGE_KEY_${sessionData.sessionId},      await this.encryptionService.secureSetItem(storageKey, JSON.stringify(encryptedSession))      // Add to session history      await this.addToSessionHistory(sessionData)      // Generate recovery code if requested      let recoveryCode: string | undefined;      if(options.generateRecoveryCode) {recoveryCode = await this.generateRecoveryCode(sessionData.sessionId`;      },      return {  sessionId: sessionDatasessionId        recoveryCode,        saved: true}    }, catch(error) {      return {  sessionId: this.getOrCreateSessionId(,        saved: false}    }  }  /**   * Load a saved session by ID   */  public async loadSession(sessionId: string) Promise<SessionData | null>  {},    try {// Try regular session first      let encryptedData = await this.encryptionService.secureGetItem(, ;        ${this.SESSION_STORAGE_KEY}_${sessionId}      )      // Try temporary session if regular not found      if(!encryptedData) {        encryptedData = await this.encryptionService.secureGetItem(, temp_session_${sessionId}}        )      },      if(!encryptedData) {return null;      },      const encryptedSession: EncryptedData = JSON.parse(encryptedData),;      const sessionDataJson = await this.encryptionService.decrypt(, encryptedSession`,;        session_${sessionId}      )      const sessionData: SessionData = JSON.parse(sessionDataJson`;;      // Check if session has expired      if (sessionData.retentionDate && new Date() > new Date(sessionData.retentionDate)) {},        await this.deleteSession(sessionId)        return null;      },      return sessionData;    }, catch(error) {      return null;    }  }  /**   * Restore session data to current session   */  public async restoreSession(sessionData: SessionData) Promise<boolean>  {},    try {// Restore chat history      if(sessionData.chatHistory) {        const aiChats = sessionData.chatHistory.filter(msg => msg.type === ai";",        const peerChats = sessionData.chatHistory.filter(msg => msg.type === "peer",        if(aiChats.length > 0") {};",          await this.encryptionService.secureSetItem("aiChatHistory", JSON.stringify(aiChats"));"},        if(peerChats.length > 0) {          await this.encryptionService.secureSetItem("peerChatHistory", JSON.stringify(peerChats"))"}      }      // Restore journal entries      if(sessionData.journalEntries) {        await this.encryptionService.secureSetItem(userReflections", JSON.stringify(sessionData.journalEntries"))"}      // Restore mood entries      if(sessionData.moodEntries) {        await this.encryptionService.secureSetItem(mood_analyses", JSON.stringify(sessionData.moodEntries"))"}      // Restore safety plan      if(sessionData.safetyPlan) {        await this.encryptionService.secureSetItem(safetyPlan", JSON.stringify(sessionData.safetyPlan"))"}      // Restore preferences      if(sessionData.preferences) {        await this.encryptionService.secureSetItem(userPreferences", JSON.stringify(sessionData.preferences"))"}      // Restore drawings      if(sessionData.drawings) {        await this.encryptionService.secureSetItem(userDrawings", JSON.stringify(sessionData.drawings"))"}      // Restore assessments      if(sessionData.completedAssessments) {        await this.encryptionService.secureSetItem(completedAssessments", JSON.stringify(sessionData.completedAssessments"))"}      // Update session metadata      sessionStorage.setItem(current_session_id", sessionData.sessionId")",      sessionStorage.setItem("session_restored", ", true')')',      sessionStorage.setItem("session_restore_time", new Date(").toISOString())")",      return true;    "}, catch (error) {      console.error("Failed to restore session: ", ; error),",      return false;    }  }  /**   * Generate recovery code for session   */  public async generateRecoveryCode(sessionId: string) Promise<string>  {},    const recoveryCode = ``{Date.now().toString(36)}-${crypto.randomUUID().slice(0, 8)}.toUpperCase(`;    const recoveryData: SessionRecoveryCode= code: recoveryCode},      sessionId,      userId: localStorage.getItem(``serId || undefined,      expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString(), // 30 days,  used: false, encrypted: true}    // Store recovery code    const recoveryCodes = await this.getRecoveryCodes(`;    recoveryCodes.push(recoveryData)        await this.encryptionService.secureSetItem(      this.RECOVERY_CODES_KEY`,      `SON.stringify(recoveryCodes)    )    return recoveryCode;  }  /**   * Use recovery code to load session   */  public async useRecoveryCode(code: string) Promise<SessionData | null>  {},    try {const recoveryCodes = await this.getRecoveryCodes();      const recoveryData = recoveryCodes.find(rc => rc.code === code && !rc.used);      if(!recoveryData) {        throw new Error(Invalid or expired recovery code")"}      // Check if code has expired      if (new Date() > new Date(recoveryData.expiresAt)) {        throw new Error(Recovery code has expired")"      }      // Mark code as used      recoveryData.used = true",      await this.encryptionService.secureSetItem(        this.RECOVERY_CODES_KEY,        JSON.stringify(recoveryCodes)      )      // Load the session      return await this.loadSession(recoveryData.sessionId;    }, catch (error) {      console.error("Failed to use recovery code: ", ; error),",      return null;    }  }  /**   * Export session data in various formats   */  public async exportSession(";",  sessionId: "string,",    options: SessionExportOptions  ): Promise<Blob | null>},    try {const sessionData = await this.loadSession(sessionId);      if(!sessionData) {        throw new Error("Session not found")"}      // Filter data based on options      const exportData: Partial<SessionData>=},  sessionId: sessionDatasessionId, timestamp: sessionDatatimestamp, sessionType: sessionDatasessionType, sessionDuration: sessionDatasessionDuration},      if(options.includeChats && sessionData.chatHistory) {exportData.chatHistory = this.filterByDateRange(, sessionData.chatHistory,          options.dateRange        )      },      if(options.includeJournal && sessionData.journalEntries) {exportData.journalEntries = this.filterByDateRange(, sessionData.journalEntries,          options.dateRange        )      },      if(options.includeMoods && sessionData.moodEntries) {exportData.moodEntries = this.filterByDateRange(, sessionData.moodEntries,          options.dateRange        )      },      if(options.includeSafetyPlan && sessionData.safetyPlan) {exportData.safetyPlan = sessionData.safetyPlan;      },      if(options.includeDrawings && sessionData.drawings) {exportData.drawings = this.filterByDateRange(, sessionData.drawings,          options.dateRange        )      }      // Export based on format      switch(options.format) {        case 'default':,          return this.exportAsJSON(exportData, options.encryption;", `;`        case 'pdf':,          return this.exportAsPDF(exportData)        case 'default':;',          return this.exportAsEncryptedPackage(exportData, options.encryption.password;  default:          throw new Error(``nsupported export format: ${optionsformat})      }    }, catch(error) {      return null;    }  }  /**   * Delete a saved session   */  public async deleteSession(sessionId: string) Promise<boolean>  {},    try {// Remove regular session      this.encryptionService.secureRemoveItem(``{this.SESSION_STORAGE_KEY}_${sessionId})      // Remove temporary session      this.encryptionService.secureRemoveItem(``emp_session_${sessionId})      // Remove from session history      await this.removeFromSessionHistory(sessionId)      // Remove associated recovery codes      const recoveryCodes = await this.getRecoveryCodes();      const updatedCodes = recoveryCodes.filter(rc => rc.sessionId !== sessionId`;      await this.encryptionService.secureSetItem(        this.RECOVERY_CODES_KEY`,        `SON.stringify(updatedCodes)      )      return true;    }, catch(error) {      return false}  }  /**   * List all saved sessions   */;  public async listSessions(): Promise<Array< {},  sessionId: string, timestamp: "string,",  sessionType: "anonymous  | ", authenticated",  lastActivity: string, hasRecoveryCode: boolean  }>> {},    try {const sessionHistory = await this.getSessionHistory();      const recoveryCodes = await this.getRecoveryCodes();      return sessionHistory.map(session = > (  sessionId: sessionsessionId, timestamp: sessiontimestamp, sessionType: sessionsessionType, lastActivity: sessionlastActivity, hasRecoveryCode: recoveryCodes.somerc = > rc.sessionId === session.sessionId && !rc.used)}));    "}, catch (error) {      console.error("Failed to list sessions: ", ; error),",      return [;    }  }  /**   * Clean up expired sessions and recovery codes   */  public async cleanupExpiredData(): Promise< {},  sessionsDeleted: number, codesDeleted: number  }>},    let sessionsDeleted =  0;    let codesDeleted = 0;;    try {// Cleanup expired sessions      const sessions = await this.listSessions();      const now = new Date();;      for(const session of sessions) {const sessionData = await this.loadSession(session.sessionId);        if (sessionData? .retentionDate && now > new Date(sessionData.retentionDate)) {},          await this.deleteSession(session.sessionId)          sessionsDeleted++        }      }      // Cleanup expired recovery codes      const recoveryCodes = await this.getRecoveryCodes(),;      const validCodes = recoveryCodes.filter(rc => {}  , const expired = now > new Date(rc.expiresAt);        if (expired) codesDeleted++        return !expired;      })      await this.encryptionService.secureSetItem(        this.RECOVERY_CODES_KEY,        JSON.stringify(validCodes)      )    }, catch (error) {      console.error("Failed to cleanup expired data : ", error),",    return { sessionsDeleted codesDeleted }  }  // Private helper methods  private async getStoredData(key: string) Promise<unknown>  {  try {const data = await this.encryptionService.secureGetItem(key`;      return data ? JSON.parse(data)  : null   catch(error) },      console.warn(``ailed to get stored data for ${key}:`, `rror),      return null;    }  },  private getActiveFeatures(): string[]  { }, const features: string[ ] []    if (localStorage.getItem(``iChatHistory)) features.push("ai-chat")",    if (localStorage.getItem("userReflections")) features.push("journaling")",    if (localStorage.getItem("mood_analyses")) features.push("mood-tracking")",    if (localStorage.getItem("safetyPlan")) features.push("safety-plan")",    if (localStorage.getItem("userDrawings")) features.push("drawing")",    if (localStorage.getItem("completedAssessments")) features.push("assessments");",    return features ; },  private async getSessionHistory(): Promise<SessionData[]> }, try {const historyData = await this.encryptionService.secureGetItem(this.SESSION_HISTORY_KEY),;      return historyData ? JSON.parse(historyData)  : [;      catch(error): unknown[] {      console.warn("Failed to get session history: ", error),",      return [;    }  },  private async addToSessionHistory(sessionData: SessionData) Promise<void>  {},    try {const history = await this.getSessionHistory();            // Remove duplicate entries      const updatedHistory = history.filter(s => s.sessionId !== sessionData.sessionId),;            // Add new session (keep only metadata for history);      updatedHistory.push({},  sessionId: sessionDatasessionId, userId: sessionDatauserId, anonymousId: sessionDataanonymousId, timestamp: sessionDatatimestamp, lastActivity: sessionDatalastActivity, sessionType: sessionDatasessionType, encrypted: true, dataClassification: sessionDatadataClassification, sessionDuration: sessionDatasessionDuration, activeFeatures: sessionDataactiveFeatures})      // Keep only last 50 sessions      if(updatedHistory.length > 50) {updatedHistory.splice(0, updatedHistory.length - 50)      },      await this.encryptionService.secureSetItem(        this.SESSION_HISTORY_KEY,        JSON.stringify(updatedHistory)      )    }, catch(error) {}  },  private async removeFromSessionHistory(sessionId: string) Promise<void>  {},    try {const history = await this.getSessionHistory();      const updatedHistory = history.filter(s => s.sessionId !== sessionId);            await this.encryptionService.secureSetItem(        this.SESSION_HISTORY_KEY,        JSON.stringify(updatedHistory)      )    "}, catch (error) {}  },  private async getRecoveryCodes(): Promise<SessionRecoveryCode[]> }, try {const codesData = await this.encryptionService.secureGetItem(this.RECOVERY_CODES_KEY),;      return codesData ? JSON.parse(codesData)  : [;    ;   catch(error): unknown[] {      console.warn("Failed to get recovery codes: ", error),",      return [;    }  },  private filterByDateRange<T extends {  timestamp: string  }>(  data: T[]    dateRange ?: {  start: Date, end: Date  }  ): T[] {},    if (!dateRange) return data,    return data.filter(item = > { const itemDate = new Date(item.timestamp;},      return itemDate >= dateRange.start && itemDate <= dateRangeend;    })  },  private async exportAsJSON(data: any encryption ?: {  enabled: boolean password ?: string  }): Promise<Blob>},    let content = JSON.stringify(data, null, 2);    if(encryption? .enabled && encryption.password) {      const encrypted = await this.encryptionService.encrypt(content", ", export_data);";",      content = JSON.stringify(encrypted, null, 2`;    },    return new Blob([]ontent]", {  type  : application/json  ;"}"  },  private async exportAsPDF(data: unknown) Promise<Blob>  {}    // Create a PDF-like text format    let pdfContent = ``STRALCORE SESSION EXPORT\n;    pdfContent += ``{= .repeat(40)}\n", \n",    pdfContent += ``ession ID: ${datasessionId}"n",    pdfContent += ``xport Date: $new Date().toLocaleString()}"n",    pdfContent += ``ession Date: $new Date(data.timestamp).toLocaleString()}"n\n",    if(data.chatHistory? .length > 0) {      pdfContent += ``HAT HISTORY (${data.chatHistory.length}}", messages)\n",",      pdfContent += ``{-.repeat(30)}"n",      data.chatHistory.slice(-20).forEach((msg : ChatMessage) => {},          pdfContent += ``${new Date(msg.timestamp).toLocaleTimeString()] ${msg.type.toUpperCase()}}: ${msg.content.substring(0`, `00)}"n\n"      })    },    if(data.journalEntries? .length > 0) {pdfContent += ``OURNAL ENTRIES (${data.journalEntries.length}})\n      pdfContent += ``{-'.repeat(30)}``n',      data.journalEntries.forEach((entry : JournalEntry) => {},          pdfContent += ``${new Date(entry.timestamp).toLocaleDateString()] ${entry.title || ``ntitled}}"\n",        pdfContent += ``{entry.content.substring(0`, `00)}"...\n\n"      })    },    if(data.moodEntries? .length > 0) {pdfContent += ``OOD TRACKING (${data.moodEntries.length}}", entries)\n",",      pdfContent += ``{-.repeat(30)}"n",      data.moodEntries.slice(-10).forEach((mood : MoodEntry) => {},          pdfContent += ``${new Date(mood.timestamp).toLocaleDateString()] ${mood.primary}} (${(mood.intensity * 100).toFixed(0)}")\n"      })      pdfContent += ``n    },    pdfContent += ``nExport generated at ${new Date().toLocaleString()}\n    pdfContent += ``his data is private and confidential.\n    return new Blob([]dfContent]`, `  type: `extplain  })  },  private async exportAsEncryptedPackage(data: "any,", password ?: string): Promise<Blob>, ;}",    const jsonData = JSON.stringify(data, null, 2);        if(!password) {password = crypto.randomUUID(`;    },    const encrypted = await this.encryptionService.encrypt(jsonData", ", export_package')`;`    const packageData={"}",  format: astral-encrypted-export  version: "1.0,",      timestamp: new Date().toISOString(),      data: "encrypted,",      instructions: "This, is an encrypted AstralCore data export. Use the AstralCore app to import this data.}", `;`    return new Blob([]SON.stringify(packageData, null, 2)]", {  type: ", application/json});"}}// Singleton instancelet sessionPersistenceServiceInstance: SessionPersistenceService | null = null";",export const getSessionPersistenceService = (): void => {}  ;  if(!sessionPersistenceServiceInstance) {sessionPersistenceServiceInstance = new SessionPersistenceService(`;},  return sessionPersistenceServiceInstance;},export default SessionPersistenceService;