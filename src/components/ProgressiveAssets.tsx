// Progressive Asset Loading System
// Optimizes images, videos, and other media for better performance

import React from 'react';

// Image optimization configuration
export const imageOptimizationConfig = {
  // Supported image formats in order of preference
  preferredFormats: ['webp', 'avif', 'png', 'jpg', 'jpeg'],
  
  // Size breakpoints for responsive images
  breakpoints: [480, 768, 1024, 1200, 1920],
  
  // Quality settings for different use cases
  quality: {
    thumbnail: 60,
    standard: 80,
    high: 90,
    lossless: 100
  },
  
  // Lazy loading thresholds
  lazyLoadThreshold: '50px',
  
  // Intersection observer options
  observerOptions: {
    rootMargin: '50px 0px',
    threshold: 0.1
  }
};

// Video optimization configuration
export const videoOptimizationConfig = {
  // Preferred video formats
  formats: ['webm', 'mp4'],
  
  // Quality settings
  quality: {
    low: '480p',
    medium: '720p',
    high: '1080p'
  },
  
  // Lazy loading settings
  preload: 'metadata' as const,
  
  // Video chunking for large files
  chunkSize: 1024 * 1024 * 2, // 2MB chunks
};

// Progressive Image Component
interface ProgressiveImageProps {
  src: string;
  alt: string;
  className?: string;
  sizes?: string;
  priority?: boolean;
}

export const ProgressiveImage: React.FC<ProgressiveImageProps> = ({
  src,
  alt,
  className = '',
  sizes = '100vw',
  priority = false
}) => {
  const [isLoading, setIsLoading] = React.useState(true);
  const [error, setError] = React.useState(false);
  const [currentSrc, setCurrentSrc] = React.useState('');
  const imgRef = React.useRef<HTMLImageElement>(null);

  // Generate responsive image sources
  const generateSrcSet = (baseSrc: string) => {
    return imageOptimizationConfig.breakpoints
      .map(width => {
        // In a real implementation, these would be generated by a build process
        // For now, we'll use the original image
        return `${baseSrc} ${width}w`;
      })
      .join(', ');
  };

  // Lazy loading with Intersection Observer
  React.useEffect(() => {
    const img = imgRef.current;
    if (!img || priority) {
      setCurrentSrc(src);
      return;
    }

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setCurrentSrc(src);
            observer.unobserve(img);
          }
        });
      },
      imageOptimizationConfig.observerOptions
    );

    observer.observe(img);
    return () => observer.disconnect();
  }, [src, priority]);

  const handleLoad = () => {
    setIsLoading(false);
  };

  const handleError = () => {
    setError(true);
    setIsLoading(false);
  };

  if (error) {
    return (
      <div className={`image-error ${className}`}>
        <span>Image failed to load</span>
      </div>
    );
  }

  return (
    <div className={`progressive-image-container ${className}`}>
      {isLoading && (
        <div className="image-placeholder">
          <div className="loading-shimmer"></div>
        </div>
      )}
      
      <picture>
        {/* WebP source for modern browsers */}
        <source
          srcSet={currentSrc ? generateSrcSet(currentSrc.replace(/\.(png|jpg|jpeg)$/i, '.webp')) : ''}
          type="image/webp"
          sizes={sizes}
        />
        
        {/* Fallback to original format */}
        <img
          ref={imgRef}
          src={currentSrc}
          alt={alt}
          srcSet={currentSrc ? generateSrcSet(currentSrc) : ''}
          sizes={sizes}
          onLoad={handleLoad}
          onError={handleError}
          style={{
            opacity: isLoading ? 0 : 1,
            transition: 'opacity 0.3s ease'
          }}
          loading={priority ? 'eager' : 'lazy'}
        />
      </picture>
    </div>
  );
};

// Progressive Video Component
interface ProgressiveVideoProps {
  src: string;
  poster?: string;
  className?: string;
  autoplay?: boolean;
  muted?: boolean;
  loop?: boolean;
  controls?: boolean;
}

export const ProgressiveVideo: React.FC<ProgressiveVideoProps> = ({
  src,
  poster,
  className = '',
  autoplay = false,
  muted = true,
  loop = false,
  controls = true
}) => {
  const [isLoading, setIsLoading] = React.useState(true);
  const [error, setError] = React.useState(false);
  const [shouldLoad, setShouldLoad] = React.useState(false);
  const videoRef = React.useRef<HTMLVideoElement>(null);

  // Lazy loading for videos
  React.useEffect(() => {
    const video = videoRef.current;
    if (!video) return;

    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            setShouldLoad(true);
            observer.unobserve(video);
          }
        });
      },
      { rootMargin: '100px 0px' }
    );

    observer.observe(video);
    return () => observer.disconnect();
  }, []);

  const handleLoadStart = () => {
    setIsLoading(true);
  };

  const handleCanPlay = () => {
    setIsLoading(false);
  };

  const handleError = () => {
    setError(true);
    setIsLoading(false);
  };

  // Generate video sources for different formats
  const generateVideoSources = (baseSrc: string) => {
    const baseName = baseSrc.replace(/\.[^/.]+$/, '');
    
    return videoOptimizationConfig.formats.map(format => ({
      src: `${baseName}.${format}`,
      type: `video/${format}`
    }));
  };

  if (error) {
    return (
      <div className={`video-error ${className}`}>
        <span>Video failed to load</span>
      </div>
    );
  }

  return (
    <div className={`progressive-video-container ${className}`}>
      {isLoading && shouldLoad && (
        <div className="video-loading">
          <div className="loading-spinner"></div>
          <span>Loading video...</span>
        </div>
      )}
      
      <video
        ref={videoRef}
        className="progressive-video"
        poster={poster}
        autoPlay={autoplay}
        muted={muted}
        loop={loop}
        controls={controls}
        preload={videoOptimizationConfig.preload}
        onLoadStart={handleLoadStart}
        onCanPlay={handleCanPlay}
        onError={handleError}
        style={{
          opacity: isLoading ? 0.5 : 1,
          transition: 'opacity 0.5s ease'
        }}
      >
        {shouldLoad && generateVideoSources(src).map((source) => (
          <source
            key={`${source.type}-${source.src}`}
            src={source.src}
            type={source.type}
          />
        ))}
        
        {/* Accessibility: Add captions track */}
        <track kind="captions" src="" srcLang="en" label="English" default />
        
        Your browser does not support the video tag.
      </video>
    </div>
  );
};

// Asset Preloader Service
export class AssetPreloader {
  private preloadedImages = new Set<string>();
  private preloadedVideos = new Set<string>();
  private preloadQueue: Array<{ type: 'image' | 'video'; src: string; priority: number }> = [];

  // Preload critical images
  preloadImage(src: string, _priority = 1): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.preloadedImages.has(src)) {
        resolve();
        return;
      }

      const img = new Image();
      img.onload = () => {
        this.preloadedImages.add(src);
        resolve();
      };
      img.onerror = reject;
      img.src = src;
    });
  }

  // Preload video metadata
  preloadVideo(src: string, _priority = 1): Promise<void> {
    return new Promise((resolve, reject) => {
      if (this.preloadedVideos.has(src)) {
        resolve();
        return;
      }

      const video = document.createElement('video');
      video.preload = 'metadata';
      video.onloadedmetadata = () => {
        this.preloadedVideos.add(src);
        resolve();
      };
      video.onerror = reject;
      video.src = src;
    });
  }

  // Queue assets for preloading
  queueAsset(type: 'image' | 'video', src: string, priority = 1) {
    this.preloadQueue.push({ type, src, priority });
    this.preloadQueue.sort((a, b) => b.priority - a.priority);
  }

  // Process preload queue during idle time
  processQueue() {
    if ('requestIdleCallback' in window) {
      requestIdleCallback(() => {
        this.processQueueItems();
      });
    } else {
      setTimeout(() => this.processQueueItems(), 100);
    }
  }

  private async processQueueItems() {
    const batchSize = 3; // Process 3 items at a time
    const batch = this.preloadQueue.splice(0, batchSize);

    const promises = batch.map(item => {
      if (item.type === 'image') {
        return this.preloadImage(item.src).catch(() => {
          // Silently handle preload failures
        });
      } else {
        return this.preloadVideo(item.src).catch(() => {
          // Silently handle preload failures
        });
      }
    });

    await Promise.allSettled(promises);

    // Continue processing if there are more items
    if (this.preloadQueue.length > 0) {
      setTimeout(() => this.processQueueItems(), 1000);
    }
  }

  // Get preload statistics
  getStats() {
    return {
      preloadedImages: this.preloadedImages.size,
      preloadedVideos: this.preloadedVideos.size,
      queueLength: this.preloadQueue.length
    };
  }
}

// Critical asset preloading
export const criticalAssetPreloader = new AssetPreloader();

// Preload critical assets
export const preloadCriticalAssets = () => {
  // Preload crisis-related images first
  criticalAssetPreloader.queueAsset('image', '/icon-192.png', 10);
  criticalAssetPreloader.queueAsset('image', '/icon-512.png', 9);
  
  // Queue mental health support videos with lower priority
  criticalAssetPreloader.queueAsset('video', '/Videos/Be Yourself  Ted Lasso.mp4', 5);
  criticalAssetPreloader.queueAsset('video', '/Videos/The Best Quote Ever.mp4', 4);
  
  criticalAssetPreloader.processQueue();
};

// Asset optimization utilities
export const assetUtils = {
  // Check if browser supports modern image formats
  supportsWebP: () => {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas.toDataURL('image/webp').indexOf('webp') !== -1;
  },

  supportsAVIF: () => {
    const canvas = document.createElement('canvas');
    canvas.width = 1;
    canvas.height = 1;
    return canvas.toDataURL('image/avif').indexOf('avif') !== -1;
  },

  // Get optimal image format for browser
  getOptimalImageFormat: () => {
    if (assetUtils.supportsAVIF()) return 'avif';
    if (assetUtils.supportsWebP()) return 'webp';
    return 'png';
  },

  // Calculate image dimensions for responsive loading
  calculateImageDimensions: (originalWidth: number, originalHeight: number, maxWidth: number) => {
    const aspectRatio = originalHeight / originalWidth;
    const width = Math.min(originalWidth, maxWidth);
    const height = width * aspectRatio;
    
    return { width: Math.round(width), height: Math.round(height) };
  }
};

// Initialize asset preloading
if (typeof window !== 'undefined') {
  preloadCriticalAssets();
}

export default {
  ProgressiveImage,
  ProgressiveVideo,
  AssetPreloader,
  criticalAssetPreloader,
  preloadCriticalAssets,
  assetUtils,
  imageOptimizationConfig,
  videoOptimizationConfig
};
