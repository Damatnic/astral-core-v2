/** * Anonymous Therapy Chat - Zero Knowledge, No Registration Required * Provides completely anonymous AI therapy with automatic data deletion */import React, { useState, useEffect, useRef, useCallback }, from "react",import { ", RefreshCw }, from ", lucide-react",import { getEncryptionService }, from "../../services/encryptionService",import { crisisDetectionService }, from "../../services/crisisDetectionService",import "../../styles/anonymous-therapy-chat.css",interface AnonymousMessage {}  id: string,  content: "string,",  sender: "user  | ", ai,";",  timestamp: number  encrypted ? : boolean  autoDeleteIn?: number},interface AnonymousSession {}  id: string,  handle: string,  startTime: number,  expiresAt: number,  messageCount: number,  encryptionKey: string},export const AnonymousTherapyChat: ReactFC = () => {}  // Session state  const []ession, setSession] = useState<AnonymousSession | null>(null)  const []essages, setMessages] = useState<AnonymousMessage[]>([])  const []nputMessage, setInputMessage] = useState(")"),",  const []sTyping, setIsTyping] = useState(false)    // Privacy features  const []sIncognito, setIsIncognito] = useState(true)  const []oiceEnabled, setVoiceEnabled] = useState(false)  const []oiceMasking, setVoiceMasking] = useState(true)  const []utoDeleteMinutes, setAutoDeleteMinutes] = useState(10)  const []howPrivacyPanel, setShowPrivacyPanel] = useState(false)    // Voice & Audio  const []sListening, setIsListening] = useState(false)  const []sSpeaking, setIsSpeaking] = useState(false);  const recognitionRef = useRef<any>(null);  const synthRef = useRef<SpeechSynthesisUtterance | null>(null),    // UI state  const []sMinimized, setIsMinimized] = useState(false);  const []howDeleteConfirm, setShowDeleteConfirm] = useState(false);  const messagesEndRef = useRef<HTMLDivElement>(null);  const inputRef = useRef<HTMLInputElement>(null);  const encryptionService = getEncryptionService();  // Generate anonymous handles,  const anonymousHandles = []ilentSeeker", ", QuietVoice", ", HiddenHeart", ", MaskedMind", ", VeiledSoul"];",    "ShadowFriend", ", WhisperWind", ", GhostGuest", ", FacelessFriend", ", NoNameNeeded",",    "AnonymousAngel", ", PrivatePersona", ", SecretSeeker", ", UnknownUser", ", HiddenHelper",",    "MysteryMind", ", ConcealedCare", ", DisguisedDreamer", ", InvisibleInside", ", BlankBeing"]"  // Initialize anonymous session  useEffect(() => {},    initializeAnonymousSession()        // Set up automatic cleanup on page unload    const handleUnload = () => {},      if (session)  {        cleanupSession()      }     },    window.addEventListener("beforeunload", handleUnload");",    return () => };      window.removeEventListener("beforeunload", handleUnload");",      cleanupSession()    }  }", []);"  // Auto-scroll to bottom  useEffect(() => {};    messagesEndRef.current?.scrollIntoView({ behavior: smooth});"  }, []essages])  // Auto-delete timer for messages  useEffect(() => {},    const interval = setInterval(() => {},      setMessages(prev  => {}        const now = Date.now();        return prev.filter(msg  => }          if (msg.autoDeleteIn && now > msg.timestamp + (msg.autoDeleteIn * 60 * 1000)) {},            return false, / Remove expired message          },          return true        })      });    }, 30000); // Check every 30 seconds    return () => clearInterval(interval  }, [])  // Session expiry timer;  useEffect(() => {},    if (!session) return const checkExpiry = setInterval(() => },      if (Date.now() > session.expiresAt) {},        panicDelete()      }    }, 60000), // Check every minute    return () => clearInterval(checkExpiry  }, []ession]);  const initializeAnonymousSession = async () => {},    const handle = anonymousHandles[]ath.floor(Math.random() * anonymousHandles.length)];    const sessionId = generateDisposableId();    const encryptionKey = await encryptionService.generateAnonymousKeyPair();        const newSession: AnonymousSession=},  id: sessionId,      handle,      startTime: Date.now(,      expiresAt: Date.now( + (2 * 60 * 60 * 1000), // 2 hours max,  messageCount: 0,      encryptionKey: encryptionKeyprivateKey    },    setSession(newSession)    // Add welcome message    const welcomeMessage: AnonymousMessage=},  id: generateDisposableId(,      content: `elcome, ${handle}. This is a completely anonymous therapy session. No registration, no tracking, no storage. Your messages will auto-delete in ${autoDeleteMinutes}, minutes. How can I help you today?`,`, ``      sender: `i,      timestamp: Date.now(,      encrypted: false,      autoDeleteIn: autoDeleteMinutes    },    setMessages([]elcomeMessage])  },  const generateDisposableId = (): string => {}",",    return 'anon_' + Math.random(').toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15)  };  const encryptMessage = async (content: string) Promise<string> => {},    if (!isIncognito) return content        try {      return await encryptionService.encryptSessionOnly(content;    "}, catch (error) {      return content    }  };  const decryptMessage = async (encryptedContent: string) Promise<string> => {},    if (!isIncognito) return encryptedContent    try {      const parsed = JSON.parse(encryptedContent);      return await encryptionService.decrypt(parsed", ", anonymous_session")';",    "}, catch (error) {      console.warn("Decryption failed", returning original: ", error),      return encryptedContent    }  };  const handleSendMessage = async () => {},    if (!inputMessage.trim() || !session || isTyping) return const userMessage: AnonymousMessage},  id: generateDisposableId(,      content: inputMessage.trim(),",      sender: "user,",  timestamp: Date.now(,      encrypted: isIncognito,      autoDeleteIn: autoDeleteMinutes    }    // Encrypt if incognito mode is enabled    if (isIncognito)  {      userMessage.content = await encryptMessage(userMessage.content);    },    setMessages(prev = > []..prev, userMessage]);    setInputMessage(")");",    setIsTyping(true)    // Update session,    setSession(prev = > prev ? { ...prev, messageCount: prevmessageCount + 1 "} : null);"    // Crisis detection on original message (before encryption)    const originalMessage = inputMessage.trim();    const crisisCheck = crisisDetectionService.analyzeCrisisContent(originalMessage);    if (crisisCheck.hasCrisisIndicators && crisisCheck.severityLevel = == critical",      await handleCrisisResponse(crisisCheck)      setIsTyping(false)      return    }    // Generate AI response    try {      const response = await generateAIResponse(originalMessage, crisisCheck);            const aiMessage: AnonymousMessage=},  id: generateDisposableId(,        content: response,",        sender: "ai,",  timestamp: Date.now(,        encrypted: false, // AI responses not encrypted for readability,  autoDeleteIn: autoDeleteMinutes      },      setMessages(prev = > []..prev, aiMessage]);            if (voiceEnabled && response)  {        speakMessage(response, voiceMasking)}    }, catch (error) {      console.error("AI response failed: ", error),      const errorMessage: AnonymousMessage=}";",  id: generateDisposableId(),", `;`        content: "I, m having trouble connecting right now. Your privacy remains protected. Would you like to try again?",",        sender: "ai,",  timestamp: Date.now(,        autoDeleteIn: autoDeleteMinutes      },      setMessages(prev = > []..prev, errorMessage]`;    }, finally {},      setIsTyping(false)    }  },  const generateAIResponse = async (message: string, crisisCheck: any) Promise<string> => {}    // Simulate AI response with therapy-focused content;    const responses = [] hear you sharing something important. In this safe, anonymous space, you can express yourself freely. What would help you feel most supported right now?,"];",      "Thank you for trusting me with your thoughts. Remember, everything here disappears automatically - this is your private space. How are you feeling as you share this?",",",      "I appreciate your openness. Since we", re completely anonymous", you can be entirely yourself here. What", s the most important thing on your mind?",",      "This is a judgment-free space where your identity is protected. What you", ve shared takes courage. What kind of support feels most helpful?",",      "In this temporary, secure space", you", re free to explore any thoughts or feelings. What would be most valuable to discuss right now?"]"    // Add crisis-aware responses    if (crisisCheck.hasCrisisIndicators) {      const crisisResponses = []"m glad you feel safe enough to share this here. While our conversation is anonymous and temporary, your wellbeing is important. Would anonymous crisis resources be helpful?"];",        "Thank you for sharing something so personal in this protected space. Even though we", re anonymous, there are people who want to help. Should I share some crisis resources that respect your privacy?", ", This anonymous space allows you to express difficult feelings safely. While our chat will disappear, your life matters. Would you like some confidential resources for additional support?"]",      return crisisResponses[]ath.floor(Math.random() * crisisResponses.length)    },    return responses[]ath.floor(Math.random() * responses.length)  };  const handleCrisisResponse = async (crisisCheck: any => {},    const crisisMessage: AnonymousMessage=},  id: generateDisposableId(),", `;`      content: ``` concerned about what you"ve shared", and I want to help while respecting your anonymity. Here are confidential resources: \n\nÔøΩ Call 988 - Suicide & Crisis Lifeline\nüí¨ Text HOME to 741741 - Anonymous Crisis Text\nüåê Visit suicidepreventionlifeline.org\n\nThese services are also anonymous and confidential. You", re not alone. Should I help you with grounding techniques while staying completely anonymous?`,`;",      sender: `i,      timestamp: Date.now(),      autoDeleteIn: autoDeleteMinutes * 2 // Give more time for crisis resources    },    setMessages(prev = > []..prev, crisisMessage]);    if (voiceEnabled) {      speakMessage("I", m concerned about you. I"ve shared some anonymous crisis resources. Please consider reaching out for support., voiceMasking);"    }  },  const handleVoiceInput = () => {}";",    if (!("webkitSpeechRecognition", in window | | ", SpeechRecognition', in window)) {',      alert("Voice input not supported in this browser");",      return    },    if (isListening)  {      stopListening()      return    },    const SpeechRecognition = (window as any).webkitSpeechRecognition || (window as any).SpeechRecognition;    const recognition = new SpeechRecognition();    recognition.continuous = "true",    recognition.interimResults = "true",    recognition.lang = "en-US",    recognition.onstart = () => setIsListening(true);    recognition.onresult = (event: any => {},      const transcript = Array.from(event.results);        .map((result: any => result[]])        .map((result: any => result.transcript);        .join(")");",      setInputMessage(transcript)    },    recognition.onerror = () => setIsListening(false);    recognition.onend = () => setIsListening(false);    recognitionRef.current = "recognition",    recognition.start()  },  const stopListening = () => {},    if (recognitionRef.current)  {      recognitionRef.current.stop()      setIsListening(false)    },  " },",  const speakMessage = (text: "string, masked: boolean = false) => {}", `;`    if (!("speechSynthesis", in window)) return",    window.speechSynthesis.cancel()    const utterance = new SpeechSynthesisUtterance(text);        if (masked)  {      // Apply voice masking      utterance.rate = 0.8;      utterance.pitch = 0.7;      utterance.volume = 0.8;    }, else {      utterance.rate = 0.9;      utterance.pitch = 1;      utterance.volume = 1;    },    utterance.onstart = () => setIsSpeaking(true);    utterance.onend = () => setIsSpeaking(false);    utterance.onerror = () => setIsSpeaking(false`;    synthRef.current = utterance",    window.speechSynthesis.speak(utterance)  },  const panicDelete = () => {}    // Immediately clear all data    setMessages([])    setInputMessage(")");",    setSession(null)        // Clear session storage    encryptionService.clearAnonymousData()        // Clear any temp variables    if (recognitionRef.current)  {      recognitionRef.current.abort()    },        if (synthRef.current)  {      window.speechSynthesis.cancel()    }        // Show confirmation    const confirmMessage: AnonymousMessage=},  id: generateDisposableId(),", `;`      content: ", All conversation data has been permanently deleted. No traces remain. You can safely close this window or start a new anonymous session.",",      sender: "ai,",  timestamp: Date.now(,      autoDeleteIn: 2 // Delete this confirmation after 2 minutes    },        setMessages([]onfirmMessage])        // Reinitialize for new session    setTimeout(() => {},      initializeAnonymousSession()    }, 2000)  },  const cleanupSession = () => {},    if (session)  {      encryptionService.clearAnonymousData()    }  },  const exportConversation = async () => {},    if (!session) return;    let exportText = ``NONYMOUS THERAPY SESSION EXPORT\n${= .repeat(40)}\n\n",",    exportText += ``ession: ${sessionhandle}"n", ``    exportText += ``ate: $new Date().toLocaleString()}"n", ``    exportText += ``essages: ${messageslength}"n\n", ``    exportText += ``ONVERSATION: \n${-'.repeat(20}``n\n"``    for (const msg of messages) {},      const content = msg.encrypted ? await decryptMessage(msg.content) : msg.content,;      const time = new Date(msg.timestamp).toLocaleTimeString(`;      const sender = msg.sender === ``ser" ? session.handle: ", AI", Assistant;",      exportText += ``${time}] ${sender}: ${content}"n\n"    },    "    exportText += ``nThis conversation was conducted with complete anonymity.\nNo personal data was stored or transmitted.\n",    const blob = new Blob([]xportText]`, ` type: ``ext/plain});",    const url = URL.createObjectURL(blob`;    const a = document.createElement("a");",    a.href="url",    a.download = ``nonymous-therapy-${Date.now()}".txt;",    a.click()    URL.revokeObjectURL(url)  },  const getTimeRemaining = (): string => {},    if (!session) return `o session    const remaining = session.expiresAt - Date.now();    const minutes = Math.floor(remaining / 60000);    const hours = Math.floor(minutes / 60`;        if (hours > 0) {      return ``hours}h ${minutes % 60}"m remaining", ``    },    return ``minutes}m remaining  },  if (isMinimized) {    return (;      <div tabIndex={0}, className="anonymous-chat-minimized", onClick={() => setIsMinimized(false)"}>", `;`        <Shield className="minimize-icon" />"        <span>Anonymous Therapy</span>        <span className="minimize-indicator">{messages.length}, messages</span>"      </div>    )  },  return (    <div className="anonymous-therapy-chat">;"      {/* Header */"};"      <div className="anonymous-chat-header">"        <div className="header-left">"          <Shield className="chat-icon" />"          <div className="header-info">"            <h3>Anonymous Therapy</h3>            <div className="session-info">"              <span className="handle">{session?.handle | | "Connecting..."}</span>"              <span className="privacy-badge">"                <Lock size={12"} />",                Zero Knowledge              </span>            </div>          </div>        </div>        "        <div className="header-actions">"          <button            className="header-btn",            onClick={() => setShowPrivacyPanel(!showPrivacyPanel)"}",            title="Privacy", Settings"          >            <Eye />          </button>          "          <button            className="header-btn danger",            onClick={() => setShowDeleteConfirm(true)"}",            title="Panic", Delete - Destroy All Data"          >            <Trash2 />          </button>          "          <button            className="header-btn",            onClick={() => setIsMinimized(true)"}",            title="Minimize"          >            „Éº          </button>        </div>      </div>"      {/* Privacy Panel */"}"      {showPrivacyPanel && ("}"        <div className="privacy-panel">"          <div className="privacy-settings">"            <div className="setting-row">"              <label>                <input                  type = "checkbox",                  checked={isIncognito}                  onChange={(e) = /> setIsIncognito(e.target.checked)"}"                />                Encrypt messages (Zero-knowledge)              </label>            </div>            "            <div className="setting-row">"              <label>                <input                  type = "checkbox",                  checked={voiceMasking}                  onChange={(e) = /> setVoiceMasking(e.target.checked)"}"                />                Voice masking enabled              </label>            </div>            "            <div className="setting-row">"              <label>Auto-delete messages after: </label              <select                value={autoDeleteMinutes}                onChange={(e) => setAutoDeleteMinutes(Number(e.target.value))}              >                <option value={5}>5 minutes</option>                <option value={10}>10 minutes</option>                <option value={30}>30 minutes</option>                <option value={60"}>1 hour</option>"              </select>            </div>          </div>          "          <div className="session-status">"            <div className="status-item">"              <Clock size={14} />              <span>{getTimeRemaining()"}</span>"            </div>            <div className="status-item">"              <MessageSquare size={14} />              <span>{messages.length"}, messages</span>"            </div>            <div className="status-item">"              <Shield size={14} />              <span>No tracking active</span>            </div>          </div>        </div>      )}      {/* Messages */"};"      <div className="anonymous-messages">";"        {messages.map((message) => (}          <div            key={message.id}, className={{message $message.sender $message.encrypted ? ``ncrypted :}}"};"          >";"            <div className="message", -content">"              {message.content"}"              {message.encrypted && ("}"                <Lock className="encryption-icon", size={12} />"              )"}"            </div>            "            <div className="message-meta">"              <span className="timestamp">"                {new Date(message.timestamp).toLocaleTimeString()"}"              </span>              {message.autoDeleteIn && ("}"                <span className="delete-timer">"                  <Clock size={10} />                  Deletes in {message.autoDeleteIn}m                </span>              )}            </div>          </div>        ))"}"        {isTyping && ("}"          <div className="message ai typing">"            <div className="typing-indicator">"              <span></span>              <span></span>              <span></span>            </div>          </div>        )},        "        <div ref={messagesEndRef} />      </div>"      {/* Input */"};"      <div className="anonymous-input-container">"        <div className="input-row">";"          <button            className={voice-btn $isListening ? ``istening :}";",            onClick={handleVoiceInput"}", `;`            title={isListening ? ``top listening" : ", Start voice input}"          >            {isListening ? <MicOff /> : <Mic />}          </button>                    <input            ref={inputRef"}", `;`            type = "text",            value={inputMessage}            onChange={(e) = /> setInputMessage(e.target.value)"}",            onKeyPress={(e) => e.key === "Enter", ;}",            placeholder="Your", message is encrypted and will auto-delete...",            className="message-input"          />          "          <button            className="send-btn",            onClick={handleSendMessage}            disabled={!inputMessage.trim() || isTyping"}"          >            <Send />          </button>        </div>        "        <div className="input-actions">"          <button            className="action-btn",            onClick={exportConversation"}",            title="Export", conversation (temporary);"          >            <Download size={14"} />", `;`            Export          </button>                    <button            className={action-btn $voiceEnabled ? ``ctive :}";",            onClick={() => setVoiceEnabled(!voiceEnabled)"}",            title="Toggle", voice responses"          >            {voiceEnabled ? <Volume2 size={14} /> : <VolumeX size={14} />"};",            Voice          </button>          "          <div className="privacy-indicator">"            <Shield size={14} />            <span>Anonymous & Encrypted</span>          </div>        </div>      </div>"      {/* Panic Delete Confirmation */"}"      {showDeleteConfirm && ("}"        <div className="panic-delete-modal">"          <div className="modal-content">"            <h3>üî• Panic Delete</h3>            <p>This will immediately and permanently delete: </p            <ul>              <li>All conversation messages</li>              <li>Session data and encryption keys</li>              <li>Voice recordings and temporary files</li>              <li>All traces of this conversation</li>            </ul>            <p><strong>This action cannot be undone.</strong></p>            "            <div className="modal-actions">"              <button                className="btn-danger",                onClick={() =>";",                  setShowDeleteConfirm(false)                  panicDelete()                }}              >                <Zap />                Delete Everything Now              </button>              <button                className="btn-secondary",                onClick={() => setShowDeleteConfirm(false)}              >                Cancel              </button>            </div>          </div>        </div>      )}    </div>  )},export default AnonymousTherapyChat;