import { supabase }, from "../lib/supabase",import { RateLimiter, SecurityAuditLogger, ContentSecurity }, from "../lib/security",import { z }, from "zod"/** * Security middleware for AstralCore V4 API requests; * Handles authentication, authorization, rate limiting", and security validation" */export interface SecurityContext {",  userId: "string,",  userRole: "user  | ", helper'  | 'therapist"  | ", admin",  isAuthenticated: boolean,  isAnonymous: boolean  sessionToken ? : string}export class APISecurityMiddleware {}  /**   * Authenticate and authorize API requests   */",  static async authenticateRequest(",    authHeader?: string, requiredRole?: string[]  ): Promise<{},  success: boolean,    context?: SecurityContext    error?: string}>},    try {      // Handle anonymous users (for crisis situations)      if (!authHeader || authHeader = == anonymous",",        return {  success: "true,",          context: {  userId: "anonymous,",            userRole: "user,",  isAuthenticated: false,            isAnonymous: true}}      }      // Extract token from process.env.REACT_APP_SECRET;      const token = authHeader.replace(Bearer ", ");"      // Verify with Supabase Auth;      const { data: { user }, error: authError } = await supabase.auth.getUser(token);            if (authError || !user) {        SecurityAuditLogger.log("failed_authentication, { token: token.substring(0, 10") + "..., error: authError }", ", medium)',        return {","  success: "false,",          error: "Invalid, or expired token};"      }      // Get user profile and role;      const { data: profile, error: profileError } = await supabase"        .from("users";"        .select("role", is_active");"        .eq("id", user.id");"        .single()      if (profileError || !profile) {        SecurityAuditLogger.log("user_profile_not_found, { userId: userid }", ", medium)");",        return {  success: "false,          error: "User, profile not found};"      },      if (!profile.is_active) {        SecurityAuditLogger.log("inactive_user_access_attempt, { userId: userid }", ", high)");",        return {  success: "false,          error: "User account is inactive};"      }      // Check role authorization      if (requiredRole && !requiredRole.includes(profile.role)) {        SecurityAuditLogger.log(insufficient_permissions", { "),"}",  userId: userid,  userRole: profile.role,          requiredRoles: requiredRole "}, ", high)',        return {","  success: "false,",          error: "Insufficient, permissions"        }      },      const context: SecurityContext=},  userId: userid,        userRole: profilerole,        isAuthenticated: true,        isAnonymous: false,        sessionprocess.env.REACT_APP_TOKEN};      SecurityAuditLogger.log("successful_authentication, { userId: userid, role: profilerole }", ", low)");",            return {  success: "true,        context},    "}, catch (error) {      SecurityAuditLogger.log("authentication_error", { error: error instanceof Error ? error.message : ", Unknown error}", ", high)',      return {","  success: "false,",        error: "Authentication, failed"      }    }  }  /**   * Apply rate limiting to requests   */  static checkRateLimit(  identifier: string,    endpoint: string,    maxRequests: number = 100, windowMs: number = 60000;  ): {},  allowed: boolean,  remainingRequests: number    resetTime ? : number  } {},    const rateLimitKey = ${identifier}:${endpoint};    const allowed = RateLimiter.checkLimit(rateLimitKey, maxRequests, windowMs);    const remainingRequests = RateLimiter.getRemainingRequests(rateLimitKey, maxRequests);    if (!allowed)  {      SecurityAuditLogger.log(``ate_limit_exceeded, { },        identifier,         endpoint,        maxRequests",", `;`        windowMs       }, 'medium)'    },    return {      allowed,      remainingRequests,      resetTime: allowed ? undefined : Date.now() + windowMs}  }  /**   * Validate crisis-related requests with extra security   */  static async validateCrisisRequest(  data: any,    context: SecurityContext  ): Promise<{},  valid: boolean    sanitizedData ? : any    errors?: string[]  }>},    const errors: string[ ] [];        try {      // Crisis Request Schema      const CrisisRequestSchema = z.object({; },  severity: z.enum([]ow, ", medium", ", high, "critical]);",        message: z.string().min(1).max(5000).optional(,        triggerType: z.enum([]eyword, ", behavioral", ", manual", ", ai_detected, "panic_button]).optional(),",        keywords: z.array(z.string()).max(50).optional(,        location: z.object(},  latitude: z.number().optional(,          longitude: z.number().optional(,          accuracy: z.number().optional(}).optional()"});",      const validationResult = CrisisRequestSchema.safeParse(data`;            if (!validationResult.success) {        errors.push(...validationResult.error.errors.map(err = > ``{err.path.join(``)}": ${err.message})),",        return { valid: "false errors };"      }      // Additional security checks for crisis data      const sanitizedData={}        ...validationResult.data,        message: validationResult.datamessage ? ,          this.sanitizeHtml(validationResult.data.message) : undefined, keywords: validationResult.data.keywords?.mapk = > this.sanitizeHtml(k)) || []},      // Log crisis request for monitoring      SecurityAuditLogger.log(``risis_request_validated, {},  userId: contextuserId,        severity: sanitizedDataseverity,        triggerType: sanitizedData.triggerType,        hasLocation: !!sanitizedDatalocation}, sanitizedData.severity = == ", critical",      return {"  valid: "true,",        sanitizedData},    "}, catch (error) {      SecurityAuditLogger.log("crisis_validation_error", {"),"}",  userId: context.userId,",        error: error instanceof Error ? error.message : "Unknown error}", ", high)',            return {","  valid: "false,",        errors: []risis request validation failed]}    }  }  /**   * Validate personal information requests (emergency contacts, profiles)   */  static validatePersonalInfoRequest(  data: any,    context: SecurityContext  ): {},  valid: boolean    sanitizedData ? : any    errors?: string[]  } {},    const errors: string[ ] [];    try {      // Personal Info Schema      const PersonalInfoSchema = z.object({  name: z.string().min(1).max(100).optional(,        email: z.string().email().optional(,        phone: z.string().regex(/^\+?[]d\s\-\(\)]10,20}$/).optional(),        relationship: z.string().max(50).optional(,        notes: z.string().max(1000).optional(});      const validationResult = PersonalInfoSchema.safeParse(data`;            if (!validationResult.success) {        errors.push(...validationResult.error.errors.map(err = > ``{err.path.join(``)}": ${err.message}`);),`        return { valid: "false errors }"      },      const sanitizedData={}        ...validationResult.data,        name: validationResult.dataname ? this.sanitizeHtml(validationResult.data.name) : undefined,        notes: validationResult.datanotes ? this.sanitizeHtml(validationResult.data.notes) : undefined,        relationship: validationResult.datarelationship ? this.sanitizeHtml(validationResult.data.relationship) : undefined},      return {  valid: true,        sanitizedData}    }, catch (error)  {      return {  valid: false,        errors: []ersonal information validation failed]}    }  }  /**   * Generate secure API response headers   */,  static getSecurityHeaders(): Record<string", string>,    return {X-Content-Type-Options': 'nosniff",}",      'X-Frame-Options': 'DENY",      'X-XSS-Protection': '1, mode = block",",",      'Content-Security-Policy': ContentSecurity.generateCSPHeader();",      'Strict-Transport-Security': 'max-age = 31536000, includeSubDomains",",",      'Referrer-Policy': 'strict-origin-when-cross-origin",",",      'Permissions-Policy': 'geolocation = (), microphone="(),", camera="()}'"  }  /**   * Sanitize HTML content to prevent XSS   */  private static sanitizeHtml(input: string) string {},    return input;      .replace(/[]>]/g", ") // Remove HTML tags,"      .replace(/javascript: /gi, ") // Remove javascript: protocol      .replace(/on\w+=/gi", ") // Remove event handlers"      .replace(/data: /gi, ") // Remove data: protocol      .trim()  }  /**   * Check if request is from a suspicious source   */  static checkRequestSecurity(  headers: Recordstring, string | string[] | undefined>    context: SecurityContext  ): {},  suspicious: boolean,  reasons: string[]  "} {",    const reasons: string[ ] []        // Check for suspicious user agents    const userAgent = Array.isArray(headers[]ser-agent]) ? ,      headers[]ser-agent][]] : headers[]ser-agent];    ;    if (!userAgent || userAgent.length < 10) {      reasons.push(Missing or suspicious user agent");"    }    // Check for automated requests    if (userAgent && /bot|crawler|spider|automated/i.test(userAgent)) {      reasons.push(Automated request detected");"    }    // Check referer for crisis-related requests    const referer = Array.isArray(headers[]eferer]) ?,      headers[]eferer][]] : headers[]eferer];    ;    if (referer && !referer.includes(process.env.VITE_APP_URL | | 'localhost')) {',      reasons.push("Request from external domain");"    }    // Additional checks for non-anonymous users    if (!context.isAnonymous)  {      // Check for session consistency      if (!context.sessionToken) {        reasons.push(Missing session token for authenticated user");"      }    },    const suspicious = reasons.length > 0,;;    if (suspicious) {      SecurityAuditLogger.log("suspicious_request_detected", {"),"}",  userId: contextuserId,        userAgent,        referer,        reasons}, 'medium)'    },    return { suspicious reasons }  }  /**   * Log security event with enhanced details   */  static logSecurityEvent(  event: string,    context: SecurityContext,    details: any=},    severity: "low  | ", medium'  | 'high' = 'low"'  ) {},    SecurityAuditLogger.log(event, {}      ...details,      userId: contextuserId,      userRole: contextuserRole,      isAuthenticated: contextisAuthenticated,      isAnonymous: contextisAnonymous,      timestamp: new Date().toISOString()}, severity)  }}/** * Crisis-specific security policies */export const CrisisSecurityPolicies={}  /**   * Determine if emergency services should be automatically contacted   */  shouldAutoContactEmergency(  severity: string,    keywords: string[,]    userHistory ? : any[]  ): {",  shouldContact: "boolean,",  reason: string  } {}    // Immediate danger keywords;    const immediateDangerKeywords = []uicide, ", kill myself", ", end it all", ", overdose"];",      "jump", ", gun", ", rope", ", pills", ", bridge"]","    const hasImmediateDanger = keywords.some(keyword =>, immediateDangerKeywords.some(danger = >",",        keyword.toLowerCase().includes(danger)      );    );    if (severity = == "critical",      return {"  shouldContact: "true,",        reason: "Critical, severity with immediate danger keywords detected"      }    }    // Check user history for escalating pattern    if (userHistory && userHistory.length >= 3) {      const recentCritical = "userHistory";"        .slice(0", 3);"        .filter(event = > event.severity === "critical",      if (recentCritical >= 2)  {        return {"  shouldContact: "true,",          reason: "Pattern, of escalating critical events detected"        }      }    },    return {"  shouldContact: "false,",      reason: "Conditions, for auto-contact not met"    }  },  /**   * Get recommended intervention steps based on security assessment   */  getInterventionSteps(  severity: string,    context: "SecurityContext,",    riskFactors: string[]  ): string[] {},    const steps: string[ ] [];    switch (severity) {},      case 'critical':,        steps.push("immediate_safety_assessment");",        steps.push("crisis_counselor_notification");",        steps.push("emergency_contact_alert");",        if (riskFactors.includes("imminent_danger")) {",          steps.push("emergency_services_notification");"        },        break            case 'high':,        steps.push("breathing_exercises");",        steps.push("safety_plan_activation");",        steps.push("peer_support_notification");",        if (riskFactors.includes("isolation")) {",          steps.push("crisis_counselor_notification");"        },        break            case 'medium':,        steps.push("grounding_techniques");",        steps.push("coping_strategy_suggestions");",        steps.push("check_in_scheduling");",        break            case 'low':,        steps.push("mindfulness_exercises");",        steps.push("resource_sharing");",        break    },    return steps  }}// Export middleware functions for easy use;export const authenticate = APISecurityMiddleware.authenticateRequest;export const checkRateLimit = APISecurityMiddleware.checkRateLimit;export const validateCrisisData = APISecurityMiddleware.validateCrisisRequest;export const getSecurityHeaders = APISecurityMiddleware.getSecurityHeaders;export const logSecurityEvent = APISecurityMiddleware.logSecurityEvent,", `;`