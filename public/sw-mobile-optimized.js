/** * Mobile-Optimized Service Worker - Critical Mental Health App PWA * CRITICAL: Must work offline for crisis situations */const CACHE_NAME = 'astral-core-mobile-v1.0.0';',const CRITICAL_CACHE = 'astral-critical-v1.0.0';',const RUNTIME_CACHE = 'astral-runtime-v1.0.0';',const CRISIS_CACHE = 'astral-crisis-v1.0.0';'// Critical resources that must be available offlineconst CRITICAL_RESOURCES = []  ',',  'index.html',',  'static/js/bundle.js',',  'static/css/main.css',',  'manifest.json',',  'crisis-keywords.json',',  'static/media/crisis-sounds.mp3', // If exists'  // Crisis-specific resources  'crisis',',  'breathing',',  'grounding',',  'emergency-contacts'];// Crisis support resources (highest priority)const CRISIS_RESOURCES = []  'crisis',',  'emergency-contacts',',  'breathing',',  'grounding',',  'crisis-keywords.json',',  'api/crisis-support',',  'api/emergency-contacts'];// Network-first resourcesconst NETWORK_FIRST = []  'api/crisis-support',',  'api/emergency-contacts',',  'api/user-location',',  'api/real-time'];// Cache-first resourcesconst CACHE_FIRST = []  'static/',',  'images/',',  'fonts/',',  'assets/'];// Runtime cache configurationlet cacheConfig = {  maxAge: 3600000, // 1 hour default  maxEntries: 50,  purgeOnQuotaError: true};// Install event - cache critical resourcesself.addEventListener('install', (event) => {}',  console.log('SW] Installing mobile-optimized service worker');',    event.waitUntil(    Promise.all([]      // Cache critical resources      caches.open(CRITICAL_CACHE).then((cache) => {}        console.log('SW] Caching critical resources');',        return cache.addAll(CRITICAL_RESOURCES).catch((error) => }          console.error('SW] Failed to cache critical resources:', error);'          // Cache individually to avoid failing all on one bad resource          return Promise.allSettled            CRITICAL_RESOURCES.map(url => cache.add(url))          );        });      }),            // Cache crisis resources separately (highest priority)      caches.open(CRISIS_CACHE).then((cache) => {}        console.log('SW] Caching crisis resources');',        return cache.addAll(CRISIS_RESOURCES).catch((error) => }          console.error('SW] Failed to cache crisis resources:', error);',          return Promise.allSettled            CRISIS_RESOURCES.map(url => cache.add(url))          );        });      })    ]).then(() => {}      console.log('SW] Installation complete');'      // Skip waiting to activate immediately for crisis app      return self.skipWaiting(;    })  );});// Activate event - clean up old cachesself.addEventListener('activate', (event) => {}',  console.log('SW] Activating mobile-optimized service worker');',    event.waitUntil(    Promise.all([]      // Clean up old caches      caches.keys().then((cacheNames) => {}        return Promise.all          cacheNames            .filter((cacheName) => {}              return cacheName.startsWith('astral-') && '                     cacheName !== CACHE_NAME &&                      cacheName !== CRITICAL_CACHE &&                      cacheName !== RUNTIME_CACHE &&                     cacheName !== CRISIS_CACHE;            })            .map((cacheName) => {}              console.log('SW] Deleting old cache:', cacheName);',              return caches.delete(cacheName;            })        );      }),            // Take control of all clients immediately      self.clients.claim()    ]).then(() => {}      console.log('SW] Activation complete');'    })  );});// Fetch event - implement caching strategiesself.addEventListener('fetch', (event) => {}',  const { request } = even;  const url = new URL(request.url);    // Only handle HTTP/HTTPS requests  if (!url.protocol.startsWith('http')) {',    return;  }    // Crisis resources get special handling  if (isCrisisResource(request.url)) {    event.respondWith(handleCrisisRequest(request));    return;  }    // API requests  if (url.pathname.startsWith('api/')) {',    event.respondWith(handleApiRequest(request));    return;  }    // Static resources  if (isStaticResource(request.url)) {    event.respondWith(handleStaticRequest(request));    return;  }    // Navigation requests  if (request.mode === 'navigate') {',    event.respondWith(handleNavigationRequest(request));    return;  }    // Default: network with cache fallback  event.respondWith(handleDefaultRequest(request));});// Crisis resource handler - offline-first for emergency accessasync function handleCrisisRequest(request){  try {    // Always try cache first for crisis resources    const cachedResponse = await caches.match(request, {      cacheName: CRISIS_CACHE    });        if (cachedResponse) {      console.log('SW] Serving crisis resource from cache:', request.url);'            // Update cache in background if possible      updateCrisisResourceInBackground(request);            return cachedResponse;    }        // If not in cache, try network    const networkResponse = await fetch(request);        if (networkResponse && networkResponse.ok) {      // Cache the response for future offline use      const cache = await caches.open(CRISIS_CACHE);      cache.put(request, networkResponse.clone());      console.log('SW] Cached new crisis resource:', request.url);'    },        return networkResponse;      }, catch (error) {    console.error('SW] Crisis resource failed:', error);'        // Return offline fallback for crisis pages    if (request.mode === 'navigate') {',      return caches.match('offline-crisis.html') || '             caches.match('index.html');'    }        // Return minimal crisis response    return new Response      JSON.stringify({        error: 'offline,',        message: 'Crisis support is temporarily unavailable. Please call 988 for immediate help.',',        emergencyNumber: '988      }),      {        status: 503,        headers: { 'Content-Type': 'application/json' },'      }    );  }}// Background update for crisis resourcesasync function updateCrisisResourceInBackground(request){  try {    const networkResponse = await fetch(request);    if (networkResponse && networkResponse.ok) {      const cache = await caches.open(CRISIS_CACHE);      await cache.put(request, networkResponse);      console.log('SW] Updated crisis resource in background:', request.url);'    }  }, catch (error) {    console.warn('SW] Background update failed for crisis resource:', error);'  }}// API request handler - network-first with intelligent fallbackasync function handleApiRequest(request){  const url = new URL(request.url);    try {    // For real-time APIs, always try network first    if (NETWORK_FIRST.some(pattern => url.pathname.includes(pattern))) {      const networkResponse = await fetchWithTimeout(request, 5000);            if (networkResponse && networkResponse.ok) {        // Cache successful responses        const cache = await caches.open(RUNTIME_CACHE);        cache.put(request, networkResponse.clone());        return networkResponse;      }    }        // Try cache first for other APIs    const cachedResponse = await caches.match(request);    if (cachedResponse) {      // Return cached response and update in background      updateInBackground(request);      return cachedResponse;    }        // Fallback to network    const networkResponse = await fetchWithTimeout(request, 10000);        if (networkResponse && networkResponse.ok) {      // Cache the response      const cache = await caches.open(RUNTIME_CACHE);      cache.put(request, networkResponse.clone());    },        return networkResponse;      }, catch (error) {    console.error('SW] API request failed:', error);'        // Return cached response if available    const cachedResponse = await caches.match(request);    if (cachedResponse) {      return cachedResponse;    }        // Return offline fallback for API    return new Response      JSON.stringify({        error: 'offline,',        message: 'Service temporarily unavailable',',        cached: false      }),      {        status: 503,        headers: { 'Content-Type': 'application/json' },'      }    );  }}// Static resource handler - cache-firstasync function handleStaticRequest(request){  try {    // Try cache first    const cachedResponse = await caches.match(request);    if (cachedResponse) {      return cachedResponse;    }        // Fallback to network    const networkResponse = await fetch(request);        if (networkResponse && networkResponse.ok) {      // Cache static resources      const cache = await caches.open(CACHE_NAME);      cache.put(request, networkResponse.clone());    },        return networkResponse;      }, catch (error) {    console.error('SW] Static resource failed:', error);'        // Return cached version if available    const cachedResponse = await caches.match(request);    if (cachedResponse) {      return cachedResponse;    }        // Return fallback for images    if (request.destination === 'image') {',      return new Response        'svg xmlns="http: //www.w3.org/2000/svg, width="200", height="200"><rect width="100%", height="100%", fill="f0f0f0"/><text x="50%", y="50%", text-anchor="middle", dy=".3em", fill="999">Image Unavailable</text></svg>','        { headers: { 'Content-Type': 'image/svg+xml' } },'      );    },        return new Response('Resource unavailable offline', { status 503 });'  }}// Navigation request handlerasync function handleNavigationRequest(request){  try {    // Try network first for navigation    const networkResponse = await fetchWithTimeout(request, 3000);        if (networkResponse && networkResponse.ok) {      return networkResponse;    },        throw new Error('Network request failed');'      }, catch (error) {    console.log('SW] Navigation offline, serving cached version');'        // Try to match the specific route    const cachedResponse = await caches.match(request);    if (cachedResponse) {      return cachedResponse;    }        // Fallback to cached index.html    const indexResponse = await caches.match('index.html');',    if (indexResponse) {      return indexResponse;    }        // Last resort: offline page    return new Response(      <!DOCTYPE html>      <html>        <head>          <title>Astral Core - Offline</title>          <meta name="viewport", content="width=device-width, initial-scale="1"" />"          <style>            body {               font-family: systemui, -apple-system, sans-serif;               text-align: center               padding: 2rem               background: linear-gradient135deg, #667eea 0%, #764ba2 100%);              color: white              min-height: 100vh              margin: 0              display: flex              flex-direction: column              justify-content: center            }            .container { max-width: 400px margin: 0 auto; }            .crisis-btn {               background: #ef4444               color: white               border: none               padding: 1rem 2rem;               border-radius: 8px               font-size: 1.2rem               margin: 1rem               cursor: pointer              text-decoration: none              display: inline-block            }            .crisis-btn:hover { background: #dc2626 }          </style>        </head>        <body>          <div class="container">"            <h1>ðŸ”’ Offline Mode</h1>            <p>You're currently offline, but help is still available.</p>'            <a href="tel: 988, class="crisis-btn">Call 988 Crisis Line</a>"            <a href="tel: 911, class="crisis-btn">Call 911 Emergency</a>"            <p>The app will reconnect automatically when internet is restored.</p>          </div>        </body>      </html>    `, `      headers: { 'Content-Type': 'text/html' },'    });  }}// Default request handlerasync function handleDefaultRequest(request){  try {    return await fetch(request;  }, catch (error) {    const cachedResponse = await caches.match(request);    return cachedResponse || new Response('Offline', { status 503 });'  }}// Background update functionasync function updateInBackground(request){  try {    const networkResponse = await fetch(request);    if (networkResponse && networkResponse.ok) {      const cache = await caches.open(RUNTIME_CACHE);      await cache.put(request, networkResponse);    }  }, catch (error) {    console.warn('SW] Background update failed:', error);'  }}// Fetch with timeout utilityfunction fetchWithTimeout(request, timeout = 10000){  return Promise.race([    fetch(request),    new Promise((_, reject) =>      setTimeout(() => reject(new Error('Fetch timeout')), timeout)'    )  ]);}// Utility functionsfunction isCrisisResource(url){  return CRISIS_RESOURCES.some(pattern => url.includes(pattern);},function isStaticResource(url){  return CACHE_FIRST.some(pattern => url.includes(pattern);}// Message handler for cache configurationself.addEventListener('message', (event) => {}',  const { type, config } = event.dat;    if (type === 'CACHE_CONFIG') {',    cacheConfig = { ...cacheConfig, ...config };    console.log('SW] Cache configuration updated:', cacheConfig);'        // Apply new cache settings    applyCacheConfiguration();  },    if (type === 'CLEAR_CACHE') {',    clearAllCaches().then(() => {}      event.ports[]].postMessage({ success: true });    });  },    if (type === 'SKIP_WAITING') {',    self.skipWaiting();  }});// Apply cache configurationasync function applyCacheConfiguration(){  try {    // Clean up runtime cache based on new configuration    const cache = await caches.open(RUNTIME_CACHE);    const requests = await cache.keys();    const now = Date.now();        for (const request of requests) {      const response = await cache.match(request);      if (response) {        const dateHeader = response.headers.get('date');',        if (dateHeader) {          const responseTime = new Date(dateHeader).getTime();          if (now - responseTime > cacheConfig.maxAge) {            await cache.delete(request);          }        }      }    },        console.log('SW] Cache configuration applied');'  }, catch (error) {    console.error('SW] Failed to apply cache configuration:', error);'  }}// Clear all cachesasync function clearAllCaches(){  try {    const cacheNames = await caches.keys();    await Promise.all(      cacheNames.map(cacheName => caches.delete(cacheName))    );    console.log('SW] All caches cleared');'  }, catch (error) {    console.error('SW] Failed to clear caches:', error);'  }}// Periodic cleanupsetInterval(async () => {}  try {    await applyCacheConfiguration();  }, catch (error) {    console.error('SW] Periodic cleanup failed:', error);'  }}, 300000); // Clean up every 5 minutes// Handle quota exceeded errorsself.addEventListener('quotaexceeded', () => {}',  console.warn('SW] Storage quota exceeded, clearing runtime cache');',    caches.delete(RUNTIME_CACHE).then(() => {}    console.log('SW] Runtime cache cleared due to quota exceeded');'  });});console.log('SW] Mobile-optimized service worker loaded');'