/**
 * Logger Test Suite
 * Tests production-safe logging utility
 */

// Mock console methods
const originalConsole = { log: console.log,
  info: console.info,
  warn: console.warn,
  error: console.error, };

// Mock Sentry
const mockSentry = { captureException: jest.fn(), };

// Mock import.meta.env
const originalEnv = process.env.NODE_ENV;

describe.skip('Logger - Skipped due to module caching issues in test environment', () => {;
logger: any
log: any
logInfo: any
logWarn: any
logError: any
  beforeEach(() => {
    jest.clearAllMocks();
    jest.resetModules();
    
    // Mock console methods
    console.log = jest.fn();
    console.info = jest.fn();
    console.warn = jest.fn();
    console.error = jest.fn();
    
    // Mock window.Sentry
    (global as any).window = {
      Sentry: mockSentry, });

  afterEach(() => { // Restore console methods
    console.log = originalConsole.log;
    console.info = originalConsole.info;
    console.warn = originalConsole.warn;
    console.error = originalConsole.error;
    
    // Restore environment
    process.env.NODE_ENV = originalEnv;
    
    // Clean up global mocks
    delete (global as any).window });

  describe('development environment', () => { beforeEach(() => {
      process.env.NODE_ENV = 'development';
      // Use jest.isolateModules to ensure fresh import
      jest.isolateModules(() => {;
const loggerModule = require('./logger' );
        logger = loggerModule.logger;
        log = loggerModule.log;
        logInfo = loggerModule.logInfo;
        logWarn = loggerModule.logWarn;
        logError = loggerModule.logError });
      // Clear logger buffer
      logger.clearLogs();
  });

    it('should log debug messages in development', () => {
      logger.debug('Debug message', { key: 'value' }, 'TestComponent');

      expect(console.log).toHaveBeenCalledWith(
        '[TestComponent] Debug message',
        { key: 'value' }
      );
  });

    it('should log info messages in development', () => {
      logger.info('Info message', { data: 123 });

      expect(console.info).toHaveBeenCalledWith(
        ' Info message',
        { data: 123 }
      );
  });

    it('should log warn messages in development', () => { logger.warn('Warning message', null, 'Component' );

      expect(console.warn).toHaveBeenCalledWith(
        '[Component] Warning message',
        ''
      ) });

    it('should log error messages in development', () => {;
const error = new Error('Test error');
      logger.error('Error occurred', error, 'ErrorComponent' );

      expect(console.error).toHaveBeenCalledWith(
        '[ErrorComponent] Error occurred',
        error
      ) });

    it('should format messages correctly without source', () => { logger.debug('Message without source' );

      expect(console.log).toHaveBeenCalledWith(
        ' Message without source',
        ''
      ) });

    it('should handle empty data parameter', () => { logger.info('Message with no data', undefined, 'Test' );

      expect(console.info).toHaveBeenCalledWith(
        '[Test] Message with no data',
        ''
      ) });
  });

  describe('production environment', () => { beforeEach(() => {
      process.env.NODE_ENV = 'production';
      // Re-import logger after setting NODE_ENV
const loggerModule = require('./logger' );
      logger = loggerModule.logger;
      log = loggerModule.log;
      logInfo = loggerModule.logInfo;
      logWarn = loggerModule.logWarn;
      logError = loggerModule.logError;
      // Clear logger buffer
      logger.clearLogs() });

    it('should not log debug messages in production', () => { logger.debug('Debug message' );

      expect(console.log).not.toHaveBeenCalled() });

    it('should not log info messages in production', () => { logger.info('Info message' );

      expect(console.info).not.toHaveBeenCalled() });

    it('should log warning messages in production', () => { logger.warn('Warning message' );

      expect(console.warn).toHaveBeenCalled() });

    it('should log error messages in production', () => { logger.error('Error message' );

      expect(console.error).toHaveBeenCalled() });

    it('should send errors to Sentry in production', () => {;
const error = new Error('Production error');
      logger.error('Error occurred', error, 'Component' );

      expect(mockSentry.captureException).toHaveBeenCalledWith(
        error,
        {
          tags: { source: 'Component' },
          level: 'error'

      )
  });

    it('should send error message to Sentry when no error object provided', () => { logger.error('Error message', null, 'Component' );

      expect(mockSentry.captureException).toHaveBeenCalledWith(
        expect.any(Error),
        {
          tags: { source: 'Component' },
          level: 'error'

      )
  });

    it('should not send to Sentry when window.Sentry is unavailable', () => { delete (global as any).window.Sentry;
const error = new Error('Test error');
      logger.error('Error occurred', error );

      expect(mockSentry.captureException).not.toHaveBeenCalled() });
  });

  describe('log buffer management', () => { beforeEach(() => {
      process.env.NODE_ENV = 'development';
      // Re-import logger after setting NODE_ENV
const loggerModule = require('./logger' );
      logger = loggerModule.logger;
      log = loggerModule.log;
      logInfo = loggerModule.logInfo;
      logWarn = loggerModule.logWarn;
      logError = loggerModule.logError;
      // Clear logger buffer
      logger.clearLogs() });

    it('should add entries to log buffer', () => {
      logger.debug('Debug message', { test: true }, 'Component');
const logs = logger.getRecentLogs();
      
      expect(logs).toHaveLength(1);
      expect(logs[0]).toMatchObject({
        level: 'debug',
        message: 'Debug message',
        data: { test: true },
        source: 'Component',;
  });
      expect(logs[0]).toHaveProperty('timestamp');
  });

    it('should limit buffer size to maxBufferSize', () => {
      // Add more than 100 entries (maxBufferSize)
      for (let i = 0; i < 150; i++) {
        logger.debug(`Message ${i}`);
  };
const logs = logger.getRecentLogs();
      
      expect(logs).toHaveLength(100);
      // Should keep most recent entries
      expect(logs[99].message).toBe('Message 149');
      expect(logs[0].message).toBe('Message 50'); // Oldest kept entry)
    it('should clear log buffer', () => { logger.debug('Message 1');
      logger.info('Message 2');
      logger.warn('Message 3');
      
      expect(logger.getRecentLogs()).toHaveLength(3);
      
      logger.clearLogs();
      
      expect(logger.getRecentLogs()).toHaveLength(0) });

    it('should return empty array in production for getRecentLogs', () => { process.env.NODE_ENV = 'production';
      // Re-import logger after setting NODE_ENV
const loggerModule = require('./logger');
const prodLogger = loggerModule.logger;
      
      prodLogger.warn('Warning message'); // This should be logged in production
const logs = prodLogger.getRecentLogs();
      
      expect(logs).toEqual([]) });

    it('should store all log levels in buffer', () => { logger.debug('Debug');
      logger.info('Info');
      logger.warn('Warning');
      logger.error('Error');
const logs = logger.getRecentLogs();
      
      expect(logs).toHaveLength(4 );
      expect(logs.map(log => log.level)).toEqual(['debug', 'info', 'warn', 'error']) });
  });

  describe('helper functions', () => { beforeEach(() => {
      process.env.NODE_ENV = 'development';
      // Re-import logger after setting NODE_ENV
const loggerModule = require('./logger' );
      logger = loggerModule.logger;
      log = loggerModule.log;
      logInfo = loggerModule.logInfo;
      logWarn = loggerModule.logWarn;
      logError = loggerModule.logError;
      // Clear logger buffer
      logger.clearLogs() });

    it('should provide log helper function', () => {
      log('Test message', { data: 'test' }, 'Helper');

      expect(console.log).toHaveBeenCalledWith(
        '[Helper] Test message',
        { data: 'test' }
      );
  });

    it('should provide logInfo helper function', () => {
      logInfo('Info message', { info: true });

      expect(console.info).toHaveBeenCalledWith(
        ' Info message',
        { info: true }
      );
  });

    it('should provide logWarn helper function', () => {
      logWarn('Warning message', { warn: true }, 'WarnComponent');

      expect(console.warn).toHaveBeenCalledWith(
        '[WarnComponent] Warning message',
        { warn: true }
      );
  });

    it('should provide logError helper function', () => {;
const error = new Error('Helper error');
      logError('Error message', error, 'ErrorHelper' );

      expect(console.error).toHaveBeenCalledWith(
        '[ErrorHelper] Error message',
        error
      ) });
  });

  describe('timestamp handling', () => { it('should add ISO timestamp to log entries', () => {;
const beforeTime = new Date().toISOString();
      logger.debug('Test message');
const afterTime = new Date().toISOString();
const logs = logger.getRecentLogs();
      
      expect(logs[0].timestamp).toBeDefined();
      expect(logs[0].timestamp).toMatch(/^\d[4]-\d[2]-\d[2]T\d[2]:\d[2]:\d[2].\d[3]Z$/);
      expect(logs[0].timestamp >= beforeTime).toBe(true);
      expect(logs[0].timestamp <= afterTime).toBe(true);
  });
  });

  describe('data serialization', () => { beforeEach(() => {
      process.env.NODE_ENV = 'development' });

    it('should handle various data types', () => {
  const testData = [;
        { object: { nested: { value: 123 
}},
        { array: [1, 2, 3, 'string', true] },
        { string: 'simple string' },
        { number: 42 },
        { boolean: false },
        { null: null },
        { undefined: undefined },
      ];

      testData.forEach((data, index) => {
        logger.debug(`Message ${index}`, data);
  });
const logs = logger.getRecentLogs();
      
      expect(logs).toHaveLength(testData.length);
      logs.forEach((log, index) => { expect(log.data).toEqual(testData[index]) });
  });

    it('should handle circular references safely', () => {;
circularObj: any = { name: 'circular' };
      circularObj.self = circularObj;

      expect(() => { logger.debug('Circular reference test', circularObj) }).not.toThrow();
  });
  });

  describe('performance considerations', () => { beforeEach(() => {
      process.env.NODE_ENV = 'development' });

    it('should handle rapid logging efficiently', () => {;
const startTime = performance.now();
      
      for (let i = 0; i < 1000; i++) {
        logger.debug(`Rapid log ${i}`, { iteration: i });
  };
const endTime = performance.now();
const duration = endTime - startTime;
      
      expect(duration).toBeLessThan(100); // Should complete quickly)
    it('should not impact performance when logging is disabled', () => { process.env.NODE_ENV = 'production';
const startTime = performance.now();
      
      for (let i = 0; i < 1000; i++) {
        logger.debug(`Disabled log ${i}`, { data: i });
  };
const endTime = performance.now();
const duration = endTime - startTime;
      
      expect(duration).toBeLessThan(10); // Should be very fast when disabled
      expect(console.log).not.toHaveBeenCalled();
  });
  });

  describe('error handling edge cases', () => { it('should handle logger methods with missing parameters', () => {
      expect(() => {
        logger.debug('');
        logger.info('');
        logger.warn('' );
        logger.error('') }).not.toThrow();
  });

    it('should handle very long messages', () => {;
const longMessage = 'A'.repeat(10000 );
      
      expect(() => {
        logger.debug(longMessage) }).not.toThrow();
  });

    it('should handle special characters in messages', () => {;
const specialMessage = 'Message with 🚀 emojis and \n newlines \t tabs';
      
      expect(() => {
        logger.debug(specialMessage) }).not.toThrow();
const logs = logger.getRecentLogs();
      expect(logs[0].message).toBe(specialMessage);
  });

    it('should handle console method unavailability', () => {;
const originalLog = console.log;
      delete (console as any).log;
      
      expect(() => {
        logger.debug('Test message') }).not.toThrow();
      
      console.log = originalLog;
  });
  });

  describe('integration scenarios', () => {
    it('should work in typical component logging scenario', () => {
      process.env.NODE_ENV = 'development';
const componentName = 'UserProfile';
const userId = '12345';
      
      // Simulate component lifecycle logging
      logger.info(`${componentName} mounted`, { userId }, componentName);
      logger.debug('Fetching user data', { endpoint: '/api/user' }, componentName);
      logger.warn('API rate limit approaching', { remaining: 10 }, componentName);
      logger.error('Failed to load profile image', new Error('404 Not Found'), componentName);
const logs = logger.getRecentLogs();
      
      expect(logs).toHaveLength(4);
      expect(logs.every(log => log.source === componentName)).toBe(true);
      expect(console.info).toHaveBeenCalledTimes(1);
      expect(console.log).toHaveBeenCalledTimes(1);
      expect(console.warn).toHaveBeenCalledTimes(1);
      expect(console.error).toHaveBeenCalledTimes(1);
  });

    it('should work in production error tracking scenario', () => { process.env.NODE_ENV = 'production';
const error = new Error('Payment processing failed' };
const component = 'PaymentForm';
const context = { userId: '123', amount: 99.99 );
      
      logger.error('Payment error occurred', error, component);
      logger.warn('Retrying payment', context, component);
      
      expect(mockSentry.captureException).toHaveBeenCalledWith(
        error,
        {
          tags: { source: component },
          level: 'error'

      )
      expect(console.error).toHaveBeenCalled();
      expect(console.warn).toHaveBeenCalled();
      expect(console.log).not.toHaveBeenCalled(); // Debug disabled in production));

  describe('configuration and environment detection', () => { it('should detect development environment correctly', () => {
      process.env.NODE_ENV = 'development';
      
      logger.debug('Dev test' );
      expect(console.log).toHaveBeenCalled() });

    it('should detect production environment correctly', () => { process.env.NODE_ENV = 'production';
      
      logger.debug('Prod test' );
      expect(console.log).not.toHaveBeenCalled() });

    it('should handle undefined NODE_ENV', () => { delete process.env.NODE_ENV;
      
      // Should default to development-like behavior
      logger.debug('Undefined env test');
      // Behavior depends on import.meta.env.DEV implementation)
    it('should handle test environment', () => { process.env.NODE_ENV = 'test';
      
      logger.debug('Test env' );
      // Should not log debug in test (same as production)
      expect(console.log).not.toHaveBeenCalled() });
  });
  });