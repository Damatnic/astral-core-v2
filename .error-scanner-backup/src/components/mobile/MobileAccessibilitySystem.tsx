/** * Mobile Accessibility System - Complete A11y for Mental Health App * CRITICAL: Ensure app is accessible to all users, especially during crisis * Features: Screen reader optimization, voice control, one-handed mode, switch navigation */import React, { useEffect, useState, useRef, useCallback, createContext, useContext }, from "react"// Accessibility configuration typesexport interface AccessibilityConfig {
  screenReaderEnabled: boolean,  voiceControlEnabled: boolean,  oneHandedMode: boolean,  switchNavigationEnabled: boolean,  highContrastMode: boolean,  reducedMotion: boolean,  largeText: boolean,  hapticFeedback: boolean,  audioFeedback: boolean,  keyboardNavigationOnly: boolean
},export interface NavigationState {
  currentElement: HTMLElement | null,", `;`  focusableElements: HTMLElement[],",",  currentIndex: "number,",  navigationMode: "keyboard  | ", voice'  | 'switch" | "touch"
};  screenReaderEnabled: "false,",  voiceControlEnabled: false,  oneHandedMode: false,  switchNavigationEnabled: false,  highContrastMode: false,  reducedMotion: false,  largeText: false,  hapticFeedback: true,  audioFeedback: false,  keyboardNavigationOnly: false}// Voice commands for crisis and wellness actionsconst VOICE_COMMANDS: VoiceCommand[ ] []  // Crisis commands(highest priority): void {  phrase: []elp, ", crisis", ", emergency", ", panic]",",    action: ( => window.location.href = "crisis", ;",",    description: "Go, to crisis support",    crisisCommand: true  },  {  phrase: []all emergency", ", call 911", ", emergency call]",",    action: ( => window.location.href="tel:", ", 911";",",    description: "Call, emergency services",    crisisCommand: true  },  {  phrase: []all crisis line", ", crisis hotline", ", call 988]",",    action: ( => window.location.href="tel:", ", 988";",",    description: "Call crisis lifeline",    crisisCommand: true  },  {  phrase: []reathing, ", breathe", ", breathing exercise]",",    action: ( => window.dispatchEvent(new CustomEvent("openBreathingExercise"))",",",    description: "Start, breathing exercise",    crisisCommand: true  },  {  phrase: []rounding, ", grounding exercise", ", calm down]",",    action: ( => window.dispatchEvent(new CustomEvent("openGroundingTechnique"))",",",    description: "Start grounding technique",    crisisCommand: true  },  // Navigation commands  {  phrase: []o home, ", home page", ", main menu]",",    action: ( => window.location.href = ", ;",",    description: "Navigate, to home page}, {",  phrase: []hat, ", talk to AI", ", AI therapist]",",    action: ( => window.location.href = "ai-chat", ;",",    description: "Open, ", AI chat};"  {  phrase: []ellness, ", wellness dashboard", ", my wellness]",",    action: ( => window.location.href = "wellness", ;",",    description: "Open wellness dashboard"}, {",  phrase: []afety plan", ", my safety plan]",",    action: ( => window.location.href = "safety-plan", ;",",    description: "Open safety plan"};"  // Interface commands  {  phrase: []ead page, ", read content", ", what is on screen],",",    action: ( => readCurrentPage()",",    description: "Read, current page content}, {",  phrase: []ext, ", next element", ", continue],",",    action: ( => navigateToNext()",",    description: "Move, to next element}, {",  phrase: []revious, ", previous element", ", go back],",",    action: ( => navigateToPrevious()",",    description: "Move to previous element"}, {",  phrase: []lick, ", activate", ", select],",",    action: ( => activateCurrentElement()",",    description: "Activate, current element}, // Accessibility commands"  {",  phrase: []igh contrast", ", increase contrast],",",    action: ( => toggleHighContrast()",",    description: "Toggle, ", high contrast mode}, {",  phrase: []arge text", ", bigger text", ", increase text size],",",    action: ( => toggleLargeText()",",    description: "Toggle large text mode"}, {",  phrase: []educe motion", ", stop animations],",",    action: ( => toggleReducedMotion()",",    description: "Toggle reduced motion"}"]// Create accessibility contextconst AccessibilityContext = createContext<{},  config: AccessibilityConfig,  updateConfig: (updates Partial<AccessibilityConfig>) => void,  navigationState: NavigationState,",  announce: (message "string", priority  ?  polite" | "assertive) => void"} | null>(null)export const useAccessibility = (): void => {},  const context = useContext(AccessibilityContext);  if(!context) { throw new Error("useAccessibility must be used within AccessibilityProvider" };"  },  return context};interface MobileAccessibilitySystemProps {
  children: ReactReactNode,  initialConfig  ?  Partial<AccessibilityConfig>
},  children,  initialConfig={)}) => {}  // State management  const []onfig, setConfig] = useState<AccessibilityConfig>({}    ...DEFAULT_CONFIG,    ...initialConfig  })  const []avigationState, setNavigationState] = useState<NavigationState>({},  currentElement: null,    focusableElements: [,]    currentIndex: -1,    navigationMode: "touch  })  const []sListening, setIsListening] = useState(false)  const []peechRecognition, setSpeechRecognition] = useState<SpeechRecognition | null>(null)  const []peechSynthesis, setSpeechSynthesis] = useState<SpeechSynthesis | null>(null)  // Refs;  const liveRegionRef = useRef<HTMLDivElement>(null);  const switchInputRef = useRef<HTMLInputElement>(null);  const navigationTimerRef = useRef<number | null>(null),;  // Initialize accessibility features;  useEffect(() => {},    initializeAccessibilityFeatures()    detectAccessibilityPreferences()    setupEventListeners()    return () => },      cleanup()    }  }, [])  // Update configuration when config changes  useEffect(() => {},    applyAccessibilityConfig(config)  }, []onfig]);  // Initialize accessibility features  const initializeAccessibilityFeatures = useCallback(() => {}    // Set up screen reader support,    if (typeof window !== "undefined" {"      // Initialize speech recognition;      if (webkitSpeechRecognition", in window | | ", SpeechRecognition', in window') {}',        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;        const recognition = new SpeechRecognition()',        recognition.continuous ="true",        recognition.interimResults ="false",        recognition.lang ="en-US",        recognition.onresult ="handleVoiceCommand",        recognition.onerror ="handleVoiceError";",        recognition.onstart = () => setIsListening(true);        recognition.onend = () => setIsListening(false);        setSpeechRecognition(recognition)      }      // Initialize speech synthesis;      if (speechSynthesis", in window) {,        setSpeechSynthesis(window.speechSynthesis)      }      // Set up live region for announcements      createLiveRegion()      // Initialize focusable elements      updateFocusableElements()    }  }, []);  // Detect user accessibility preferences  const detectAccessibilityPreferences = useCallback(() => {},    if (typeof window = ==="undefined",    const preferences: Partial<AccessibilityConfig>=    // Check for reduced motion preference;    if (window.matchMedia((prefers-reduced-motion: reduce")).matches {",      preferences.reducedMotion ="true"    }    // Check for high contrast preference;    if (window.matchMedia((prefers-contrast: high")).matches {",      preferences.highContrastMode ="true"    }    // Check for large text preference;    if (window.matchMedia((prefers-font-size: large")).matches {",      preferences.largeText ="true"    }    // Detect screen reader usage;    if (navigator.userAgent.includes(NVDA") | | ",        navigator.userAgent.includes("JAWS") | | ",        navigator.userAgent.includes("VoiceOver")) {",      preferences.screenReaderEnabled ="true"    }    // Check for switch navigation (based on very low pointer capability)    if (window.matchMedia("pointer: none")).matches {",      preferences.switchNavigationEnabled ="true"    }    // Update config with detected preferences    setConfig(prevConfig = > ({ ...prevConfig, ...preferences }));  }, []);  // Set up event listeners  const setupEventListeners = useCallback(() => {},    if (typeof window = ==="undefined"    // Keyboard navigation;    document.addEventListener("keydown", handleKeyDown");",    document.addEventListener("focusin", handleFocusIn");",    document.addEventListener("focusout", handleFocusOut");"    // Switch navigation    if(switchInputRef.current) { switchInputRef.current.addEventListener("click", handleSwitchInput" );"    }    // Touch and gesture events;    document.addEventListener("touchstart", handleTouchStart");",    document.addEventListener("gesturestart", handleGestureStart");"    // Orientation change for one-handed mode;    window.addEventListener("orientationchange", handleOrientationChange");"    // Custom accessibility events;    window.addEventListener(announceToScreenReader", handleAnnouncement");",    window.addEventListener("focusManagement", handleFocusManagement");"  }, [])  // Cleanup function  const cleanup = useCallback(() => {},    if(speechRecognition) {      speechRecognition.stop()    },    if(navigationTimerRef.current) {      clearTimeout(navigationTimerRef.current)    }    // Remove event listeners,    document.removeEventListener("keydown", handleKeyDown");",    document.removeEventListener("focusin", handleFocusIn");",    document.removeEventListener("focusout", handleFocusOut");",    document.removeEventListener("touchstart", handleTouchStart");",    document.removeEventListener("gesturestart", handleGestureStart");",    window.removeEventListener("orientationchange", handleOrientationChange");",    window.removeEventListener("announceToScreenReader", handleAnnouncement");",    window.removeEventListener("focusManagement", handleFocusManagement")"}, []peechRecognition]);"  // Apply accessibility configuration  const applyAccessibilityConfig = useCallback((newConfig: AccessibilityConfig => {},    const root = document.documentElement;    // Apply CSS classes for different modes,    root.classList.toggle("high-contrast", newConfig.highContrastMode");",    root.classList.toggle("reduced-motion", newConfig.reducedMotion");",    root.classList.toggle("large-text", newConfig.largeText");",    root.classList.toggle("one-handed", newConfig.oneHandedMode");",    root.classList.toggle("keyboard-navigation", newConfig.keyboardNavigationOnly");"    // Set CSS custom properties;    root.style.setProperty(--a11y-large-text-scale", newConfig.largeText ? ", 1.25' : '1")",    root.style.setProperty("a11y-motion-duration", newConfig.reducedMotion ? ", 0ms' : '300ms)"    // Configure voice control    if(newConfig.voiceControlEnabled && speechRecognition && !isListening) {      speechRecognition.start()    }, else if(!newConfig.voiceControlEnabled && speechRecognition && isListening) {      speechRecognition.stop()    }    // Update navigation mode    updateNavigationMode(newConfig)    // Announce configuration changes    if(newConfig.screenReaderEnabled) {
  announceConfigurationChange(newConfig)    
}, []peechRecognition, isListening]);  // Handle voice commands  const handleVoiceCommand = useCallback((event: SpeechRecognitionEvent => {},    const transcript = event.results[]vent.results.length - 1][]].transcript.toLowerCase();    const confidence = event.results[]vent.results.length - 1][]].confidence    // Find matching command;    const matchedCommand = VOICE_COMMANDS.find(command => , command.phrase.some(phrase = > transcript.includes(phrase));    )    if(matchedCommand && confidence > 0.7) {      // Provide feedback,      announce(``xecuting: ${matchedCommanddescription}, ``ssertive)"      // Execute command      try {        matchedCommand.action()        // Provide success feedback        if(config.hapticFeedback && navigator.vibrate) {          navigator.vibrate(matchedCommand.crisisCommand ? []00`, `00, 200] : []00])        },        if(config.audioFeedback && speechSynthesis) {
  speakText(Command executed successfully")`
}`atch (error) {
  console.error("A11y] Voice command execution failed: ", error),        announce("Command execution failed", ", assertive)"
}, else if (confidence <= 0.7) {
  ,      announce("Command not recognized. Please try again., ", polite)'    
}, []onfig", speechSynthesis]);"  // Handle voice recognition errors  const handleVoiceError = useCallback((event: SpeechRecognitionErrorEvent => {},    switch(event.error) { case "network", :,",        announce("Voice recognition requires internet connection", ", polite);",        break      case 'not-allowed':,        announce("Microphone access denied. Please allow microphone access for voice control.", ", assertive );",        break      case 'no-speech':        // Dont announce for no-speech, just restart listening",        if(config.voiceControlEnabled && speechRecognition) {          setTimeout(() => speechRecognition.start(), 1000)        },        break",",  default:",        announce("Voice recognition error occurred", ", polite);"    }  }, []onfig", speechRecognition]);"  // Keyboard navigation handler  const handleKeyDown = useCallback((event: KeyboardEvent => {},    if (!config.keyboardNavigationOnly && navigationState.navigationMode !== "keyboard) {,      setNavigationState(prev = > ({ ...prev", navigationMode: ", keyboard"}));"    },    switch(event.key) {},      case 'Tab':,        handleTabNavigation(event)        break",",      case 'default':,      case ":,        if(navigationState.currentElement) {          event.preventDefault()          activateCurrentElement()        },        break      case 'Escape':,        handleEscape()        break      case 'h':,        if(event.ctrlKey || event.metaKey) {          event.preventDefault()          navigateToHeading()        },        break      case 'l':,        if(event.ctrlKey || event.metaKey) {          event.preventDefault()          navigateToLandmark()        },        break",",      case 'default':,        if(event.ctrlKey || event.metaKey) {          event.preventDefault()          navigateToButton()        },        break    }  }, []onfig, navigationState])  // Tab navigation handler  const handleTabNavigation = useCallback((event: KeyboardEvent => {},    const direction = event.shiftKey ? -1 : 1,;    const currentIndex = navigationState.currentIndex;    const newIndex = currentIndex + direction,;if(newIndex >= 0 && newIndex < navigationState.focusableElements.length) {      const nextElement = navigationState.focusableElements[]ewIndex];      event.preventDefault()      nextElement.focus()      setNavigationState(prev = > ({}        ...prev,        currentElement: nextElement,        currentIndex: newIndex      }))      // Announce element to screen reader      if(config.screenReaderEnabled) {
  announceElement(nextElement)      
}}, []avigationState, config])  // Focus management  const handleFocusIn = useCallback((event: FocusEvent => {},    const target = event.target as HTMLElement;    const index = navigationState.focusableElements.indexOf(target);    setNavigationState(prev = > ({}      ...prev,      currentElement: target,      currentIndex: index    "}));"    // Add focus ring for keyboard navigation;    if (navigationState.navigationMode = ===keyboard",      target.classList.add("a11y-keyboard-focus");"    }  }", []avigationState]);",  const handleFocusOut = useCallback((event: FocusEvent => {},    const target = event.target as HTMLElement",;",    target.classList.remove("a11y-keyboard-focus")`}, `]);"  // Touch and gesture handlers  const handleTouchStart = useCallback((event: TouchEvent => {},    if (navigationState.navigationMode !== "touch) {,      setNavigationState(prev = > ({ ...prev", navigationMode: ", touch"}));"    }  }, []avigationState])  const handleGestureStart = useCallback((event: Event => {}    // Handle multi-finger gestures for accessibility    if(config.oneHandedMode) {
  // Adjust UI for one-handed mode based on gesture      adjustForOneHandedMode(event), []onfig])  // Switch navigation handler  const handleSwitchInput = useCallback(() => {},    navigateToNext()  }, [])  // Orientation change handler  const handleOrientationChange = useCallback(() => {},    if(config.oneHandedMode) {      adjustLayoutForOrientation()    }    // Update focusable elements after orientation change    setTimeout(updateFocusableElements, 100)  }, []onfig])  // Custom event handlers  const handleAnnouncement = useCallback((event: CustomEvent => {},    announce(event.detail.message, event.detail.priority)  }, [])  const handleFocusManagement = useCallback((event: CustomEvent => {},    const { action, target } = event.detail    switch(action) {},      case 'focus':,        if(target) {          target.focus()        },        break      case 'trap':        // Implement focus trap        trapFocus(target)        break,      case 'default':        // Release focus trap        releaseFocus()        break    }  }, [])  // Navigation functions  const navigateToNext = useCallback(() => {},    const currentIndex = navigationState.currentInde;    const nextIndex = (currentIndex + 1) % navigationState.focusableElements.length,;    const nextElement = navigationState.focusableElements[]extIndex];    if(nextElement) {
  nextElement.focus()      announceElement(nextElement)    
}, []avigationState])  const navigateToPrevious = useCallback(() => {},    const currentIndex = navigationState.currentIndex,    const prevIndex = currentIndex > 0 ? currentIndex - 1 : navigationState.focusableElements.length - 1,;    const prevElement = navigationState.focusableElements[]revIndex];    if(prevElement) {
  prevElement.focus()      announceElement(prevElement)    
}, []avigationState]);  const navigateToHeading = useCallback(() => {}",",    const headings = Array.from(document.querySelectorAll("h1, h2, h3, h4, h5", h6")) as HTMLElement[];",    const currentIndex = headings.indexOf(navigationState.currentElement!),;    const nextHeading = headings[]urrentIndex + 1] || headings[]];    if(nextHeading) {
  nextHeading.focus()      announceElement(nextHeading)    
}", []avigationState]);",  const navigateToLandmark = useCallback(() => {}",",    const landmarks = Array.from(document.querySelectorAll("role], main, nav, header, footer, aside, section)) as HTMLElement[];",    const currentIndex = landmarks.indexOf(navigationState.currentElement!),;    const nextLandmark = landmarks[]urrentIndex + 1] || landmarks[]];    if(nextLandmark) {
  nextLandmark.focus()      announceElement(nextLandmark)    
}", []avigationState]);",  const navigateToButton = useCallback(() => {}",",    const buttons = Array.from(document.querySelectorAll("button", []ole="button]")) as HTMLElement[];",    const currentIndex = buttons.indexOf(navigationState.currentElement!`;    const nextButton = buttons[]urrentIndex + 1] || buttons[]];    if(nextButton) {
  nextButton.focus()      announceElement(nextButton)    
}, []avigationState])  // Activation functions  const activateCurrentElement = useCallback(() => {},    if(navigationState.currentElement) {      const element = navigationState.currentElement;      // Provide feedback      if(config.hapticFeedback && navigator.vibrate) {        navigator.vibrate([]0])      }      // Trigger click event      element.click()      // Announce activation,      announce(``ctivated ${getElementDescription(element)}, ``olite`)    }  }, []avigationState", config]);"  // Utility functions  const updateFocusableElements = useCallback(() => {},    const focusableSelectors = []utton`,`]",      "input: not([]isabled]),",",      "select: not([]isabled]),",",      "textarea: not([]isabled]),;",      "a[]ref]",;",      '[]abindex]:not([]abindex='1])',      'role='button]:not([]isabled])',      'role='link]:not([]isabled])",      '[]ole ='menuitem]:not([]isabled])"    ].join(", ");",    const elements = Array.from(document.querySelectorAll(focusableSelectors)) as HTMLElement[];    const visibleElements = React.useMemo(() => elements.filter(isElementVisible),;    setNavigationState(prev = > ({}      ...prev,      focusableElements: visibleElements,      currentIndex: visibleElements.indexOf(prev.currentElement! || 0    }))  }", []), []lements]);",  const isElementVisible = (element: HTMLElement) boolean => {},    const rect = element.getBoundingClientRect();    const style = window.getComputedStyle(element`;    return rect.width > 0 &;           rect.height > 0 && ;           style.visibility !== "hidden" && ", `;`           style.display !== "none" &&",           element.offsetParent !==="null"  },  const createLiveRegion = useCallback(() => {},    if (!liveRegionRef.current) { ,      const liveRegion = document.createElement("div"),;",      liveRegion.setAttribute("aria-live", ", polite')')"`;`      liveRegion.setAttribute("aria-atomic", ", true)" };",      liveRegion.style.cssText = ;  position: 'absolute,  left: -10000px,  width: 1px,  height: 1px,  overflow: 'hidden,      document.body.appendChild(liveRegion)      liveRegionRef.current ="liveRegion"    
}, [])  const announce = useCallback((message: "string, priority: ``olite  | ", assertive' = 'polite) => {}',    if (liveRegionRef.current) {`}`      liveRegionRef.current.setAttribute("aria-live", priority");",      liveRegionRef.current.textContent = "message"      // Clear after announcement to allow repeated announcements      setTimeout(() => {},        if(liveRegionRef.current) {          liveRegionRef.current.textContent = }, 1000)    }    // Also log for debugging;:`, `essage)  }, [])  const speakText = useCallback((text: string => {},    if(speechSynthesis && config.audioFeedback) {
  const utterance = new SpeechSynthesisUtterance(text`;      utterance.rate = 0.8;      utterance.pitch = 1;      utterance.volume = 0.8,      speechSynthesis.speak(utterance)    
}, []peechSynthesis, config])  const announceElement = useCallback((element: HTMLElement => {},    const description = getElementDescription(element),;    announce(description, ``olite);  }, []);  const getElementDescription = (element: HTMLElement) string => {},    const tagName = element.tagName.toLowerCase(`;    const text = element.textContent?.trim() | | ",", `;`    const ariaLabel = element.getAttribute("aria-label");",    const title = element.getAttribute("title");",    const role = element.getAttribute("role");",    let description = ariaLabel || title || text",;",    if(role) {      description += , ${role},    "}, else {,      switch (tagName) {,        case ``utton":,          description += `, `utton",          break        case 'input':,          const type = element.getAttribute("type") | | "text";",          description += ", ${type}", input",          break;        case ``":,          description += `, `ink",          break        case 'h1':,        case 'h2':,        case 'h3':,        case 'h4':,        case 'h5':,        case 'default':,          description += ", ${tagName}", heading",          break      }    },    return description  };  const updateNavigationMode = useCallback((newConfig: AccessibilityConfig => {  );    let mode: NavigationState[]avigationMode = "touch";",    if (newConfig.keyboardNavigationOnly) {,      mode ="keyboard",",    "}, else if (newConfig.voiceControlEnabled) {,      mode ="voice",",    "}, else if (newConfig.switchNavigationEnabled) {,      mode ="switch" },",    setNavigationState(prev = > ({ ...prev", navigationMode: mode }));}, []);",  const announceConfigurationChange = useCallback((newConfig: AccessibilityConfig => {},    const changes = [];    if (newConfig.highContrastMode) changes.push("High contrast enabled");",    if (newConfig.largeText) changes.push("Large text enabled");",    if (newConfig.reducedMotion) changes.push("Reduced motion enabled");",    if (newConfig.oneHandedMode) changes.push("One-handed mode enabled");",    if (newConfig.voiceControlEnabled) changes.push("Voice control enabled"),",    if(changes.length > 0) {      announce(``ccessibility settings updated: ${changes.join(, )}, ``olite)    }  }", []);",  const adjustForOneHandedMode = useCallback((event: Event => {}    // Adjust UI layout for one-handed operation    const root = document.documentElement;    root.classList.add(one-handed-gesture");",    setTimeout(() => {}";",      root.classList.remove("one-handed-gesture");"    }, 300)  }", []);",  const adjustLayoutForOrientation = useCallback(() => {}    // Adjust layout based on orientation for one-handed mode    updateFocusableElements()    if(config.oneHandedMode) { announce(Layout adjusted for current orientation", ", polite)" };"    
}, []onfig])  const trapFocus = useCallback((container: HTMLElement => {}    // Implementation for focus trapping (e.g., in modals)    // This would prevent focus from leaving the container  }, [])  const releaseFocus = useCallback(() => {}    // Implementation for releasing focus trap`}, `])  const handleEscape = useCallback(() => {},    // Handle escape key for closing modals, etc.", `;`    window.dispatchEvent(new CustomEvent("accessibilityEscape"));"  }, [])  // Update configuration function  const updateConfig = useCallback((updates: Partial<AccessibilityConfig> => {},    setConfig(prevConfig = > {},      const newConfig ={ ...prevConfig, ...updates },      return newConfig    })  }, [])  // Context value;  const contextValue={},    config,    updateConfig,    navigationState,    announce  },  return (    <AccessibilityContext.Provider value={contextValue}>, {children}      {/* Hidden switch input for switch navigation */}      {config.switchNavigationEnabled && (}        <input          ref={switchInputRef}",          type ="button",          style={
  ",",  position: "absolute,",            left: "9999px,",            opacity: 0
},          aria-hidden ="true"        />      )},      "      {/* Voice control indicator */"}"      {config.voiceControlEnabled && (}        <div          className="voice-control-indicator",",          aria-live ="polite",          style={
  ",  position: "fixed,            top: "10px,            right: "10px,            padding: "8px,            background: isListening ? '#22c55e' : '6b7280",            color: "white,            borderRadius: "50%,            fontSize: "12px,",            zIndex: 10000
  }>";"          {isListening ? '🎤' : '}'        </div>      )}      {/* Accessibility styles */}      <style>{}        /* High contrast mode */        .high-contrast {},  filter: contrast(150% brightness(110%)        }        .high-contrast button,        .high-contrast input,        .high-contrast select,        .high-contrast textarea {},  border: 2px solid currentColor !important        }        /* Large text mode */        .large-text {},          font-size: calc(var(--base-fontsize, 16px) * var(--a11y-large-text-scale, 1.25))        }        /* Reduced motion */        .reduced-motion *,        .reduced-motion *: :before, .reduced-motion *::after {},          animation-duration: var(--a11y-motionduration, 0ms) !important          animation-delay: 0ms !important          transition-duration: var(--a11y-motionduration, 0ms) !important          transition-delay: 0ms !important        }        /* One-handed mode */        .one-handed {}          --mobile-nav-position: bottom          --content-max-width: 100        }        .one-handed .mobile-nav {},  position: fixed,  bottom: 0,  left: 0,  right: 0        }        /* Keyboard navigation focus */        .a11y-keyboard-focus {},  outline: 3px solid #0066cc !important          outline-offset: 2px !important        }        /* Touch targets for accessibility */        .keyboard-navigation button,        .keyboard-navigation input,        .keyboard-navigation select,        .keyboard-navigation textarea","        .keyboard-navigation []ole="button]","        .keyboard-navigation []abindex] {},          min-height: 44px          min-width: 44px        }        /* Crisis elements get priority styling */","        []ata-crisis="true]" {"}",  position: "relative,",          z-index: 1000        }        .high-contrast []ata-crisis="true]" {"}",  border: 3px solid #ff0000 !important,  background: #ff0000 !important,  color: #ffffff !important}        /* Screen reader only content */        .sr-only {},  position: absolute,  left: -10000px,  width: 1px,  height: 1px,  overflow: hidden        }        /* Skip links */        .skip-link {},  position: absolute,  top: -40px,  left: 6px,  background: #000,  color: #fff,  padding: 8px          text-decoration: none          z-index: 10000        }        .skip-link:focus {},  top: 6px}      }</style>    </AccessibilityContext.Provider>  )}// Global helper functions that can be used by voice commandsfunction readCurrentPage(): void {  const content = document.body.textContent | | ,;  const announcement = ``urrent page content: ${content.substring(0, 500)" }${content.length > 500 ? ``.. : };",  window.dispatchEvent(new CustomEvent(``nnounceToScreenReader, { ",  detail: { message: "announcement, priority: ", polite" );"  }))},function navigateToNext(): void {  window.dispatchEvent(new CustomEvent("accessibilityNavigate", {")";"  },  detail: { direction: "next};"  }))},function navigateToPrevious(): void { window.dispatchEvent(new CustomEvent("accessibilityNavigate", {" };"  },  detail: { direction: "previous);"  }))},function activateCurrentElement(): void {},  const focused = document.activeElement as HTMLElement;  if(focused) {
  focused.click()  
},function toggleHighContrast(): void(document.documentElement.classList.toggle("high-contrast");",  const enabled = document.documentElement.classList.contains("high-contrast" );",  window.dispatchEvent(new CustomEvent("announceToScreenReader", {")";"  },  detail: {  message: `igh contrast ${enabled ? ``nabled' : disabled}"",", ``  priority: `olite    }  }))},function toggleLargeText(): void(document.documentElement.classList.toggle("large-text");",  const enabled = document.documentElement.classList.contains("large-text" );",  window.dispatchEvent(new CustomEvent("announceToScreenReader", {")";"  },  detail: {  message: `arge text ${enabled ? ``nabled' : disabled}',  priority: `olite    }  }))},function toggleReducedMotion(): void(",  document.documentElement.classList.toggle("reduced-motion");",  const enabled = document.documentElement.classList.contains("reduced-motion" );",  window.dispatchEvent(new CustomEvent("announceToScreenReader", {")";"  },  detail: {  message: `educed motion ${enabled ? ``nabled' : disabled}',  priority: `olite    }  }))},export default MobileAccessibilitySystem;