/** * Comprehensive Wellness Tracking Service * Tracks mood, sleep, medications, habits with analytics and celebrations */interface MoodEntry {id: string, userId: string, timestamp: Date, mood: 1 | 2 | 3 | 4 | 5; // 1 = very bad, 5= excellent",  emotions: string[]  triggers ?: string[]  activities?: string[]  notes?: string  weather?: string  location?: string}interface SleepEntry {id: string, userId: string, date: Date, bedTime: Date, wakeTime: Date, quality: 1 | 2 | 3 | 4 | 5, hoursSlept: number, interruptions: number  dreams?: boolean  notes?: string}interface MedicationEntry {id: string, userId: string, name: string, dosage: string, frequency: string, startDate: Date  endDate?: Date, takenToday: boolean, reminders: {}  time: string, enabled: boolean  }[]  sideEffects ?: string[]  effectiveness?: 1 | 2 | 3 | 4 | 5},interface HabitEntry {id: string, userId: string, name: string, category: "health  | ", mindfulness'  | 'social'  | 'productivity"  | ", self-care",",  targetFrequency: "daily  | ", weekly"  | ", monthly",  currentStreak: number, longestStreak: number, completedToday: boolean  lastCompleted?: Date  reminderTime?: string}interface WellnessInsight {  type: "pattern  | ", correlation'  | 'achievement"  | ", suggestion",  title: string, description: string  data?: any,  actionable ?: string[]}interface ProgressMetrics {  moodTrend: "improving  | ", stable"  | ", declining,",",  averageMood: number, sleepConsistency: number, medicationAdherence: number, habitCompletion: number, streakDays: number, totalEntries: number}class WellnessTrackingService {private moodEntries: Map<string MoodEntry[]> = new Map()  private sleepEntries: Mapstring, SleepEntry[]> = new Map()  private medications: Mapstring, MedicationEntry[]> = new Map()  private habits: Mapstring, HabitEntry[]> = new Map()  private reminders: Mapstring, any[]> = new Map()  /**   * Track mood entry   */  public trackMood(  userId: string, data: Omit<MoodEntry, ", id'  | 'userId'  | 'timestamp'>  ): MoodEntryconst entry: MoodEntry={ },",  id: this.generateId("mood",",      userId,      timestamp: new Date(),      ...data    },    const userMoods = this.moodEntries.get(userId) || [];    userMoods.push(entry)    this.moodEntries.set(userId, userMoods)    // Check for celebrations    this.checkMoodMilestones(userId, userMoods)    // Generate insights    this.generateMoodInsights(userId, userMoods)    return entry;  }  /**   * Track sleep entry   */  public trackSleep(  userId: string, data: OmitSleepEntry, ", id'  | 'userId'  | 'hoursSlept'>'  ): SleepEntry,",    const hoursSlept = this.calculateHoursSlept(data.bedTime", data.wakeTime);",    const entry: SleepEntry={ , id: this.generateId(, sleep"),"}",      userId,      hoursSlept,      ...data    },    const userSleep = this.sleepEntries.get(userId) || [];    userSleep.push(entry)    this.sleepEntries.set(userId, userSleep)    // Check sleep patterns    this.analyzeSleepPatterns(userId, userSleep)    return entry;  }  /**   * Add or update medication   */  public manageMedication(  userId: string, medication: OmitMedicationEntry, ", id'  | 'userId'>'  ): MedicationEntryconst entry: MedicationEntry={}",  id: this.generateId("med",",      userId,      ...medication    },    const userMeds = this.medications.get(userId) || [];        // Check if updating existing medication    const existingIndex = userMeds.findIndex(m => m.name === medication.name),;    if(existingIndex >= 0) {      userMeds[]xistingIndex] = entry"}, else {userMeds.push(entry)    },        this.medications.set(userId, userMeds)    // Set up reminders    this.setupMedicationReminders(userId, entry)    return entry;  }  /**   * Track habit   */  public trackHabit(  userId: string, habitId: string, completed: boolean = true", "  ): HabitEntry | null  {},    const userHabits = this.habits.get(userId) || [];    const habit = userHabits.find(h => h.id === habitId);        if (!habit) return null;    if(completed) { habit.completedToday = "true",      habit.lastCompleted = new Date();            // Update streak      const lastDate = habit.lastCompleted;      const today = new Date();      const daysSince = lastDate"        ? Math.floor((today.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24))         : 999;            if(daysSince <= 1) {habit.currentStreak++        if(habit.currentStreak > habit.longestStreak) {habit.longestStreak = habit.currentStreak,          this.celebrateStreak(userId, habit), else { habit.currentStreak =  1 }, else { habit.completedToday = "false",      habit.currentStreak =  0 },    return habit;  }  /**   * Create new habit   */  public createHabit(  userId: string, habitData: Omit<HabitEntry, ", id'  | 'userId'  | 'currentStreak'  | 'longestStreak'  | 'completedToday'>  ): HabitEntryconst habit: HabitEntry={}",  id: this.generateId("habit",",      userId,      currentStreak:  0, longestStreak:  0, completedToday: false      ...habitData    },    const userHabits = this.habits.get(userId) || [];    userHabits.push(habit)    this.habits.set(userId, userHabits)    return habit;  }  /**   * Get mood chart data   */  public getMoodChartData(",",  userId: "string,",    period: "week  | ", month'  | 'year' = 'week'  ):   {},  labels: string[]ata: number[]motions: Recordstring, number>  triggers: Recordstring, number>  } {},    const moods = this.moodEntries.get(userId) || [];    const cutoffDate = this.getCutoffDate(period);        const filteredMoods = moods.filter(m => m.timestamp >= cutoffDate);        // Group by day    const groupedData: Recordstring, number[]>={},    const emotionCounts: Recordstring, number>={},    const triggerCounts: Recordstring, number>={},        filteredMoods.forEach(mood = > { const dateKey = mood.timestamp.toLocaleDateString() },            if(!groupedData[]ateKey]) {groupedData[]ateKey] = []      },      groupedData[]ateKey].push(mood.mood)            // Count emotions      mood.emotions.forEach(emotion = > {'
  emotionCounts[]motion] = (emotionCounts[]motion] || 0) + 1
})            // Count triggers      mood.triggers?.forEach(trigger  => {}        triggerCounts[]rigger] = (triggerCounts[]rigger] || 0) + 1      })    })        // Calculate averages    const labels = Object.keys(groupedData).sort(),;    const data = labels.map(label => {}  , const dayMoods = groupedData[]abel];      return dayMoods.reduce((sum, mood) => sum + mood, 0) / dayMoodslength;    })        return {      labels,      data,,      emotions : "emotionCounts",",      triggers: triggerCounts      }  /**   * Get sleep patterns   */  public getSleepPatterns(",  userId: "string,",    period: "week  | ", month' = 'week'  ):   {},  averageHours: number, averageQuality: number, consistency: number, bestNight: SleepEntry | null,",",  worstNight: SleepEntry | null",",  recommendations: string[]  "} { ",    const sleepData = this.sleepEntries.get(userId) || [];    const cutoffDate = this.getCutoffDate(period);    const filtered = sleepData.filter(s => s.date >= cutoffDate  );    if(filtered.length === 0) {},",",      return {}",  averageHours: "0,",        averageQuality:  0, consistency:  0, bestNight: null, worstNight: null, recommendations: []tart tracking your sleep to get insights]      }    },        const totalHours = filtered.reduce((sum, s) => sum + s.hoursSlept, 0),;    const totalQuality = filtered.reduce((sum, s) => sum + s.quality, 0);        const averageHours = totalHours / filtered.length;    const averageQuality = totalQuality / filtered.length;        // Calculate consistency (standard deviation of bedtimes)    const bedtimes = filtered.map(s => s.bedTime.getHours() * 60 + s.bedTime.getMinutes());    const avgBedtime = bedtimes.reduce((a, b) => a + b, 0) / bedtimes.length;    const variance = bedtimes.reduce((sum, time) => sum + Math.pow(time - avgBedtime, 2), 0) / bedtimes.length;    const stdDev = Math.sqrt(variance);    const consistency = Math.max(0, 100 - (stdDev * 2)); // Convert to percentage        const bestNight = filtered.reduce((best, current) => ;      current.quality > (best?.quality || 0) ? current  : best    , filtered[]])        const worstNight = filtered.reduce((worst, current) => ,      current.quality < (worst?.quality || 5) ? current  : worst    , filtered[]])        const recommendations = this.generateSleepRecommendations(averageHours, averageQuality, consistency),;    ;    return { averageHours,      averageQuality,      consistency,      bestNight,      worstNight,      recommendations     }/**   * Get medication adherence   */  public getMedicationAdherence(userId: string)   {},  overall: number, byMedication: Recordstring, number>  missed: MedicationEntry[]pcoming: Array<  medication: MedicationEntry, time: string  }>  } {},    const userMeds = this.medications.get(userId) || [];    const activeMeds = userMeds.filter(m => !m.endDate || m.endDate > new Date());        if(activeMeds.length === 0) {},      return { overall: 100, byMedication: { };        missed: []pcoming: []      }    },        const takenCount = activeMeds.filter(m => m.takenToday).length;    const overall = (takenCount / activeMeds.length) * 100,;    ;    const byMedication: Recordstring, number>={},    activeMeds.forEach(med = > { byMedication[]ed.name] = med.takenToday ? 100  : 0  ) },        const missed = activeMeds.filter(m => !m.takenToday);        // Get upcoming reminders    const now = new Date();    const upcoming = activeMeds",;"      .flatMap(med = > , med.reminders;          .filter(r = > r.enabled);          .map(r = > ({ medication: med, time: rtime });      )      .filter(r = > {", "}",        const []ours", minutes] = r.time.split(', : ')map(Number),",        const reminderTime = new Date(),;        reminderTime.setHours(hours, minutes, 0, 0);        return reminderTime  now;      })      .sort((a, b) => a.time.localeCompare(b.time))        return { overall,      byMedication,      missed,      upcoming     }/**   * Get progress metrics   */  public getProgressMetrics(userId: string) ProgressMetrics(const moods = this.moodEntries.get(userId) || [];    const sleep = this.sleepEntries.get(userId) || [];    const meds = this.medications.get(userId) || [];    const userHabits = this.habits.get(userId) || [];        // Mood trend    const recentMoods = moods.slice(-7),;    const olderMoods = moods.slice(-14, -7 );",    let moodTrend: ProgressMetrics[]oodTrend = "stable;",    if(recentMoods.length >= 3 && olderMoods.length >= 3) {",      const recentAvg = recentMoods.reduce((sum, m) => sum + m.mood, 0) / recentMoods.length",;",      const olderAvg = olderMoods.reduce((sum", m) => sum + m.mood", 0) / olderMoods.length;",      if (recentAvg > olderAvg + 0.5) moodTrend = "improving",      else if (recentAvg < olderAvg - 0.5) moodTrend = "declining"}        // Average mood    const averageMood = moods.length > 0;      ? moods.reduce((sum, m) => sum + m.mood, 0) / moods.length       : 3    // Sleep consistency    const sleepPatterns = this.getSleepPatterns(userId, 'week)';',    const sleepConsistency = sleepPatterns.consistency;        // Medication adherence    const medAdherence = this.getMedicationAdherence(userId);    const medicationAdherence = medAdherence.overall;        // Habit completion    const completedHabits = userHabits.filter(h => h.completedToday).length;    const habitCompletion = userHabits.length > 0;      ? (completedHabits / userHabits.length) * 100       : 0    // Longest streak    const streakDays = Math.max(0, ...userHabits.map(h => h.currentStreak));        // Total entries    const totalEntries = moods.length + sleep.length;        return { moodTrend,      averageMood,      sleepConsistency,      medicationAdherence,      habitCompletion,',      streakDays      totalEntries     }/**   * Generate wellness insights   */  public generateInsights(userId: string) WellnessInsight[]  {},    const insights: WellnessInsight[ ] [];    const metrics = this.getProgressMetrics(userId),;    const moods = this.moodEntries.get(userId) || [];    const sleep = this.sleepEntries.get(userId) || [];    // Mood insights    if (metrics.moodTrend === improving",",      insights.push({  type: "pattern,",        title: "Your, mood is improving! 🌟",",        description: "Your, ", mood has been trending upward over the past week. Keep up the great work!,",",        actionable: []ontinue with current coping strategies, 'Share what\'s working in the community]      })',    "}, else if (metrics.moodTrend === ", declining",",      insights.push({  type: "pattern,",        title: "Let\, s address the mood dip",",        description: "Your mood has been lower recently. This is a good time to reach out for support.",",        actionable: []chedule a check-in with your therapist", ", Try a new coping technique, "Reach out to a friend]      }"    }        // Sleep-mood correlation    if(moods.length >= 7 && sleep.length >= 7) {const correlation = this.calculateSleepMoodCorrelation(userId),,      if (Math.abs(correlation) > 0.5) {},        insights.push({  type: correlation,",          title: correlation > 0 ? 'Better sleep = Better mood'  : 'Sleep affecting mood",", ",          description: `e found a ${  correlation > 0 ? ``ositive' : negative '}`` ", correlation between your sleep and mood.,", `;`          data: { correlation }, actionable: []rioritize sleep hygiene", ", Set a consistent bedtime, "Try a bedtime routine]        });"      }    }        // Streak achievements    if(metrics.streakDays >= 7) {"
  insights.push({  type: achievement,",  title: ``{metricsstreakDays"
}", day streak! 🔥`,`        description: ``ou`e maintained your habits for ${metrics.streakDays}", days straight!;",        actionable: []elebrate this achievement", ", Set a new streak goal"]      });"    }        // Medication reminders    const medAdherence = this.getMedicationAdherence(userId),;    if(medAdherence.overall < 80) {insights.push({  type: suggestion,",        title: "Medication, reminder",",        description: "Your medication adherence is below 80%. Consider setting up reminders.", actionable: []et up medication alarms", Use a pill organizer, ", Link medication to daily routine];"      })    },        return insights;  }  /**   * Private helper methods   */  private generateId(prefix: string) string {return $prefix}_${Date.now()}_${ Math.random().toString(36).substr(2`, `) },  private calculateHoursSlept(bedTime: Date, wakeTime: Date) number { const diff = wakeTime.getTime() - bedTime.getTime(`,    return Math.round((diff / (1000 * 60 * 60)) * 10)  10 },  private getCutoffDate(period: ``eek  | ", month'  | 'year'): Date  const now = new Date();'}',    switch(period) { case 'week': return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)","      case 'month':,        return new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000)      case 'default':,        return new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000   };  private checkMoodMilestones(userId: "string, moods: MoodEntry[]) void  { "}"    // Check for milestone entries    if(moods.length === 7) {},      // Trigger celebration notification    },        if(moods.length === 30) {},      // Trigger celebration notification    }        // Check for improvement streaks    const recent = moods.slice(-7`;    if(recent.length === 7) {},      const improving = recent.every((m, i) => ;        i === 0 || m.mood >= recent[] - 1].mood,      )            if(improving) {console.log(``Wellness] User ${userId}", has 7-day mood improvement streak!`)`        // Trigger celebration      },  private generateMoodInsights(userId: string, moods: MoodEntry[]) void {// Analyze patterns and generate insights    const recent = moods.slice(-30),        if (recent.length < 7) return;        // Find most common emotions,    const emotionCounts: Recordstring, number>={},    recent.forEach(m  => {}      m.emotions.forEach(e = > {"
  emotionCounts[]] = (emotionCounts[]] || 0) + 1
})    })        // Find most common triggers    const triggerCounts: Recordstring, number>={},    recent.forEach(m  => {}      m.triggers?.forEach(t = > {
  triggerCounts[]] = (triggerCounts[]] || 0) + 1
})    })    console.log(``Wellness] Mood insights for ${userId} : `, `  topEmotions: Object.entries(emotionCounts)sort(a, b) => b[]] - a[]]).slice(0, 3);},      topTriggers: Object.entries(triggerCounts).sort(a, b) => b[]] - a[]]).slice(0, 3)    )  },  private analyzeSleepPatterns(userId: string, sleepData: SleepEntry[]) void(if (sleepData.length < 7) return const recent = sleepData.slice(-7 );    const avgHours = recent.reduce((sum, s) => sum + s.hoursSlept, 0) / recent.length;    if(avgHours < 6) {}, else if(avgHours > 9) {}  },  private setupMedicationReminders(userId: string, medication: MedicationEntry) void {
  medication.reminders.forEach(reminder = > { if(reminder.enabled) {        // Would integrate with notification service)  },  private celebrateStreak(userId: string, habit: HabitEntry) void {console.log(``Wellness] User ${userId}, achieved new streak record for ${habit.name}: ${habit.longestStreak}, days!`)    // Trigger celebration notification`},  private generateSleepRecommendations(  avgHours: number, avgQuality: number, consistency: number  ): string[]  {  const recommendations: string[ ] []},    if(avgHours < 7) {recommendations.push(``im for 7-9 hours of sleep per night)  },        if(avgQuality < 3) {      recommendations.push(Consider sleep hygiene improvements")",      recommendations.push("Limit screen time before bed")"},        if(consistency < 70) { recommendations.push("Try to maintain consistent sleep/wake times")",      recommendations.push("Create a bedtime routine  );"},        return recommendations;  },  private calculateSleepMoodCorrelation(userId: string) number  { const moods = this.moodEntries.get(userId) || [] },    const sleep = this.sleepEntries.get(userId) || [];        // Simple correlation calculation    const paired: Array<{sleep number, mood: number  }> = []        moods.forEach(mood  => {}      const sleepEntry = sleep.find(s => ,        s.date.toDateString() === mood.timestamp.toDateString())      if(sleepEntry) {paired.push({},  sleep: sleepEntryhoursSlept, mood: moodmood        })      }    })        if (paired.length < 5) return 0        // Calculate Pearson correlation    const n = paired.length;    const sumX = paired.reduce((sum, p) => sum + p.sleep, 0);    const sumY = paired.reduce((sum, p) => sum + p.mood, 0);    const sumXY = paired.reduce((sum, p) => sum + p.sleep * p.mood, 0);    const sumX2 = paired.reduce((sum, p) => sum + p.sleep * p.sleep, 0);    const sumY2 = paired.reduce((sum, p) => sum + p.mood * p.mood, 0);        const correlation = (n * sumXY - sumX * sumY) / ;      Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY))        return isNaN(correlation) ? 0    correlation;  }// Export singleton instanceexport const wellnessTrackingService = new WellnessTrackingService(`;export default wellnessTrackingServiceexport type { },  MoodEntry,   SleepEntry,   MedicationEntry,   HabitEntry,  WellnessInsight`,  ProgressMetrics }`"