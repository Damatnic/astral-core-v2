/** * Emergency Protocol Service *  * CRITICAL SERVICE: Manages emergency responses, geolocation, notifications, and post-crisis support * All methods must be type-safe and thoroughly tested to ensure reliable emergency response */import.CrisisAnalysisResult, from './crisisDetectionService',import {   EmergencyContact as MHEmergencyContact,  CrisisEvent,  User,  Alert,  SafetyPlan}, from '../types/mentalHealth.types'// ============================================================================// Emergency Protocol Types// ============================================================================export interface EmergencyContact extends MHEmergencyContact {  notifyAutomatically: boolean  lastNotified?: Date;  preferredContactMethod?: 'phone' | 'sms' | 'email'},export interface EmergencyLocation { latitude: number  longitude: number  accuracy: number  timestamp: Date  address?: string;  nearestER?: EmergencyRoom }export interface EmergencyRoom { name: string  address: string  distance: number // in meters  estimatedTime: string // e.g., 5 minutes",  phone: string,  hasTraumaCenter?: boolean;  hasPsychiatricUnit?: boolean }export interface EmergencyEvent { id: string  userId: string  timestamp: Date  severity: 'low | 'medium' | 'high' | 'critical',  type: 'panic | 'crisis_detected' | 'user_initiated' | 'escalated',  location?: EmergencyLocation;  crisisAnalysis?: CrisisAnalysisResult;    // Response details  response: EmergencyResponse Timeline  timeline: EmergencyTimelineEntry[]    // Outcome  outcome?: EmergencyOutcome }export interface EmergencyResponse {  initiated: Date  contactsNotified: string[]  servicesContacted: string[]  responseTime: number // in seconds  helperAssigned?: string;  status: 'active | 'responding' | 'resolved' | 'cancelled'}export interface EmergencyTimelineEntry { timestamp: Date  action: string  details?: string;  actor?: string;  automated?: boolean }export interface EmergencyOutcome { resolved: boolean  resolutionTime: number // in minutes  interventionType: 'self-managed | 'peer-support' | 'professional' | 'emergency-services',  followUpRequired: boolean  notes?: string;  referrals?: string[] }export interface PostCrisisCheckIn { id: string  userId: string  eventId: string  scheduledTime: Date  completedTime?: Date;  status: 'scheduled | 'completed' | 'missed' | 'cancelled',  responses?: CheckInResponses }export interface CheckInResponses { feelingSafe: boolean  needsSupport: boolean  usingCopingStrategies: boolean  rating: 1 | 2 | 3 | 4 | 5;  notes?: string;  concernsRaised?: string[] }export interface RecoveryPlan {  id: string  userId: string  eventId: string  createdAt: Date  immediateSteps: string[]  shortTermGoals: RecoveryGoal[]  supportSchedule: SupportScheduleItem[]  copingStrategies: string[]  warningSignsToWatch: string[]  progressChecks: ProgressCheck[]}export interface RecoveryGoal { goal: string  timeline: string  completed: boolean  completedAt?: Date }export interface SupportScheduleItem { type: 'therapy | 'check-in' | 'group' | 'medication' | 'activity',  frequency: string  provider?: string;  nextScheduled?: Date }export interface ProgressCheck { date: Date  notes: string  progress: 'improving | 'stable' | 'struggling',  adjustmentsNeeded?: string[] }export interface EmergencyServiceNumbers { police: string  medical: string  crisis: string  suicide?: string;  domestic?: string }/ ============================================================================// Emergency Protocol Service Implementation// ============================================================================export class EmergencyProtocolService { private emergencyContacts: Mapstring, EmergencyContact[]> = new Map();  private activeEmergencies: Mapstring, EmergencyEvent> = new Map();  private emergencyHistory: Mapstring, EmergencyEvent[]> = new Map();  private postCrisisCheckIns: Mapstring, PostCrisisCheckIn[]> = new Map();  private recoveryPlans: Mapstring, RecoveryPlan> = new Map(};    // Emergency service numbers by country  private readonly emergencyNumbers: Recordstring, EmergencyServiceNumbers>={    US: {       police: 911, ",      medical: '911, ',      crisis: "988,",      suicide: '988,',      domestic: "1-800-799-7233},",    UK: {       police: "999, ",      medical: '999, ',      crisis: "116 123",",      suicide: '116 123'    },    AU: {       police: "000, ",      medical: '000, ',      crisis: "13 11 14",",      suicide: '13 11 14'    },    CA: {
  police: "911, ",      medical: '911, ',      crisis: "1-833-456-4566,",      suicide: '1-833-456-4566    
);  /**   * Trigger emergency protocol with full type safety   */  public async triggerEmergency(    userId: string,    type: EmergencyEvent[]type',',    crisisAnalysis?: CrisisAnalysisResult  ): Promise<EmergencyEvent>    // Check if there's already an active emergency',    const existing = this.activeEmergencies.get(userId);    if (existing && existing.response.status === 'active') { ,      return this.escalateEmergency(existing }    // Get user location if available    const location = await this.getUserLocation();        // Create emergency event with proper typing    const emergency: EmergencyEvent=      id: this.generateId('emrg',',      userId,      timestamp: new Date(),      severity: this.determineSeveritytype, crisisAnalysis),      type,      location,      crisisAnalysis,      response: {        initiated: new Date(),        contactsNotified: [,]        servicesContacted: [,]        responseTime: 0,        status: active},",      timeline: []        timestamp: new Date(),        action: "Emergency protocol initiated",",        details: ``ype ${type}, Severity: ${this.determineSeveritytype, crisisAnalysis)},        automated: true      }]    };    // Store active emergency    this.activeEmergencies.set(userId, emergency);    // Execute emergency protocol    await this.executeEmergencyProtocol(emergency);    return emergency;  }  /**   * Execute emergency protocol steps   */  private async executeEmergencyProtocol(emergency: EmergencyEvent) Promise<void> { const startTime = Date.now();        try {      // Step 1: Notify emergency contacts for high/critical severity      if (emergency.severity === 'critical' || emergency.severity === 'high') {,        await this.notifyEmergencyContacts(emergency) }      // Step 2: Contact emergency services if critical      if (emergency.severity === 'critical') { ,        await this.contactEmergencyServices(emergency) }      // Step 3: Assign crisis counselor      await this.assignCrisisCounselor(emergency);      // Step 4: Share location with responders if available      if(emergency.location) { await this.shareLocationWithResponders(emergency) }      // Step 5: Prepare safety resources      await this.prepareSafetyResources(emergency`;      // Update response time      emergency.response.responseTime = (Date.now() - startTime) / 1000;            // Log protocol completion      this.addTimelineEntry(emergency, 'Emergency protocol executed', '        ``esponse time: ${emergency.responseresponseTime}s`;            }, catch(error) {
  console.error('Error executing emergency protocol:', error),      this.addTimelineEntry(emergency, 'Error in emergency protocol', ',        error instanceof Error ? error.message : 'Unknown error')'    
}/**   * Notify emergency contacts with error handling   */  private async notifyEmergencyContacts(emergency: EmergencyEvent) Promise<void> { const contacts = this.emergencyContacts.get(emergency.userId) || [];    const notified: string[ ] [];    for(const contact of contacts) {      if(contact.notifyAutomatically) {        try(await this.sendEmergencyNotification(contact, emergency);          notified.push(contact.id );          contact.lastNotified = new Date(`;                    this.addTimelineEntry(emergency,             ``otified emergency contact: ${contactname},            ``ethod: ${contactpreferredContactMethod || 'phone'})'        }, catch(error) {          console.error(``ailed to notify contact ${contact.name}:`, `rror`;          this.addTimelineEntry(emergency,             ``ailed to notify contact: ${contactname},            error instanceof Error ? error.message : 'Unknown error')        },    emergency.response.contactsNotified = notified;  }  /**   * Contact emergency services based on location   */  private async contactEmergencyServices(emergency: EmergencyEvent) Promise<void> { const country = await this.detectCountry(emergency.location);    const numbers = this.emergencyNumbers[]ountry] || this.emergencyNumbers.US;    try {      // In production, this would interface with emergency services API      const servicesContacted = [];            if (emergency.crisisAnalysis?.detectedCategories.includes('suicidal')) {',        servicesContacted.push(numbers.crisis );        servicesContacted.push(numbers.suicide || numbers.crisis) },            if (emergency.severity === 'critical') { ,        servicesContacted.push(numbers.medical` },      emergency.response.servicesContacted = servicesContacted;            this.addTimelineEntry(emergency,         'Emergency services contacted','        ``ervices: ${servicesContacted.join(, ')})'            }, catch(error) {
  console.error('Failed to contact emergency services:', error),      this.addTimelineEntry(emergency,         'Failed to contact emergency services',',        error instanceof Error ? error.message : 'Unknown error')'    
}/**   * Assign a crisis counselor to the emergency   */  private async assignCrisisCounselor(emergency: EmergencyEvent) Promise<void> {    try {      // In production, this would match with available counselors      const counselorId = await this.findAvailableCounselor(emergency`;            if(counselorId) {        emergency.response.helperAssigned = counselorId;        emergency.response.status = 'responding',                this.addTimelineEntry(emergency,           'Crisis counselor assigned','          ``ounselor ID: $counselorId});      }    }, catch(error) {
  console.error('Failed to assign crisis counselor:', error)    
}/**   * Share location with emergency responders   */  private async shareLocationWithResponders(emergency: EmergencyEvent) Promise<void> { if (!emergency.location) return;    try {      // Find nearest emergency room      const nearestER = await this.findNearestEmergencyRoom(emergency.location`;      if(nearestER) {        emergency.location.nearestER = nearestER }      // In production, this would share location with responders      this.addTimelineEntry(emergency,         'Location shared with responders','        ``earest ER: ${nearestER?name || 'Unknown'})'            }, catch(error) {
  console.error('Failed to share location:', error)    
}/**   * Prepare safety resources for the user   */  private async prepareSafetyResources(emergency: EmergencyEvent) Promise<void> {    try {      const resources = this.getEmergencyResources(emergency.severity`;            // In production, this would make resources immediately available      this.addTimelineEntry(emergency,         'Safety resources prepared','        ``{resources.length}, resources ready`;            }, catch(error) {
  console.error('Failed to prepare safety resources:', error)    
}/**   * Escalate an existing emergency   */  private escalateEmergency(emergency: EmergencyEvent) EmergencyEvent { // Increase severity if not already critical    if (emergency.severity !== 'critical') {,      const severityLevels: Array<EmergencyEvent[]severity'] = []low', 'medium', 'high', 'critical']';',      const currentIndex = severityLevels.indexOf(emergency.severity`;      emergency.severity = severityLevels[]ath.min(currentIndex + 1, 3)] },    emergency.type = 'escalated',        this.addTimelineEntry(emergency,       'Emergency escalated','      ``ew severity: ${emergencyseverity});    // Re-execute protocol with escalated severity    this.executeEmergencyProtocol(emergency);    return emergency;  }  /**   * Resolve an emergency event   */  public async resolveEmergency(    emergencyId: string,    outcome: OmitEmergencyOutcome, 'resolutionTime'>  ): Promise<void>    const emergency = Array.from(this.activeEmergencies.values());      .find(e => e.id === emergencyId);    if(!emergency) {      throw new Error('Emergency not found')'    },    const resolutionTime = Math.floor(;      (Date.now() - emergency.timestamp.getTime()) / 60000;    `;    emergency.outcome={      ...outcome,      resolutionTime    }    emergency.response.status = 'resolved',    this.addTimelineEntry(emergency,       'Emergency resolved','      ``esolution time: $resolutionTime}, minutes`;    // Move to history    this.moveToHistory(emergency);    // Schedule post-crisis check-ins if needed    if(outcome.followUpRequired) { await this.schedulePostCrisisCheckIns(emergency) }    // Create recovery plan    await this.createRecoveryPlan(emergency);  }  /**   * Schedule post-crisis check-ins   */  private async schedulePostCrisisCheckIns(emergency: EmergencyEvent) Promise<void> {    const checkInSchedule = []      { hours: 24, priority: high},"      { hours: 72, priority: "medium},"      { hours: 168, priority: "low} // 1 week"    ];    const checkIns: PostCrisisCheckIn[ ] [];    for(const schedule of checkInSchedule) { const scheduledTime = new Date(emergency.timestamp);      scheduledTime.setHours(scheduledTime.getHours() + schedule.hours);      const checkIn: PostCrisisCheckIn=        id: this.generateId('chk',',        userId: emergencyuserId,        eventId: emergencyid,        scheduledTime,        status: scheduled);",      checkIns.push(checkIn );    },    const existing = this.postCrisisCheckIns.get(emergency.userId) || [];    this.postCrisisCheckIns.set(emergency.userId, []..existing, ...checkIns]);  }  /**   * Create a recovery plan   */  private async createRecoveryPlan(emergency: EmergencyEvent) Promise<void> { const plan: RecoveryPlan=      id: this.generateId('rcp',',      userId: emergencyuserId,      eventId: emergencyid,      createdAt: new Date(),      immediateSteps: this.generateImmediateSteps(emergency,      shortTermGoals: this.generateShortTermGoals(emergency,      supportSchedule: this.generateSupportSchedule(emergency,      copingStrategies: this.generateCopingStrategies(emergency,      warningSignsToWatch: this.generateWarningSignsToWatch(emergency,      progressChecks: []    );    this.recoveryPlans.set(emergency.userId, plan );  }  /**   * Complete a post-crisis check-in   */  public async completeCheckIn(    checkInId: string,    responses: CheckInResponses  ): Promise<void>    // Find the check-in across all users    for(const []serId, checkIns] of this.postCrisisCheckIns) { const checkIn = checkIns.find(c => c.id === checkInId);      if(checkIn) {        checkIn.status = 'completed',        checkIn.completedTime = new Date();        checkIn.responses = responses;        // Trigger alerts if concerns are raised        if(!responses.feelingSafe || responses.rating <= 2) {          await this.triggerEmergency(userId, 'crisis_detected')'        },        break;      }  // ============================================================================  // Helper Methods  // ============================================================================  /**   * Get user's current location'   */  private async getUserLocation(): Promise<EmergencyLocation | undefined>    try { // In production, this would use the Geolocation API      return undefined }, catch(error) { console.error('Failed to get user location:', error),      return undefined }/**   * Determine severity based on type and analysis   */  private determineSeverity(    type: EmergencyEvent[]type',',    analysis?: CrisisAnalysisResult  ): EmergencyEvent[]severity'] {',    if (analysis?.severityLevel === 'critical' || type === 'panic') {,      return 'critical    };    if (analysis?.severityLevel === 'high' || type === 'crisis_detected') {,      return 'high    };    if (analysis?.severityLevel === 'medium') {,      return 'medium    },    return 'low  }  /**   * Send emergency notification to contact   */  private async sendEmergencyNotification(    contact: EmergencyContact,    emergency: EmergencyEvent  ): Promise<void>    // In production, this would send actual notifications  }  /**   * Detect country from location   */  private async detectCountry(location?: EmergencyLocation): Promise<string>    // In production, this would use reverse geocoding    return 'US  }  /**   * Find available crisis counselor   */;  private async findAvailableCounselor(emergency: EmergencyEvent) Promise<string | undefined> {    // In production, this would match with available counselors    return 'counselor-' + Math.random().toString(36).substr(2, 9)  }  /**   * Find nearest emergency room   */;  private async findNearestEmergencyRoom(location: EmergencyLocation) Promise<EmergencyRoom | undefined> {    // In production, this would use location services API    return {      name: General Hospital",",      address: '123 Medical Center Dr',',      distance: 2500,      estimatedTime: "5 minutes",",      phone: '555-0100,',      hasTraumaCenter: true,      hasPsychiatricUnit: true    }  /**   * Get emergency resources based on severity   */  private getEmergencyResources(severity: EmergencyEvent[]severity']) string[] { ',    const resources: string[ ] [];        switch(severity) {      case 'critical':,        resources.push('988 Suicide & Crisis Lifeline')',        resources.push('Crisis Text Line: Text HOME to 741741')',        resources.push('Emergency Services: 911'),        break;      case 'high':,        resources.push('988 Suicide & Crisis Lifeline')',        resources.push('Crisis Text Line: Text HOME to 741741')',        resources.push('SAMHSA National Helpline: 1-800-662-4357'),        break;      case 'medium':,        resources.push('Crisis Text Line: Text HOME to 741741')',        resources.push('NAMI Helpline: 1-800-950-6264'),        break;      case 'low':,        resources.push('Peer support chat')',        resources.push('Self-care resources')',        break },        return resources;  }  /**   * Generate immediate steps for recovery plan   */  private generateImmediateSteps(emergency: EmergencyEvent) string[] { return [      'Ensure immediate safety',',      'Contact support person',',      'Use grounding techniques',',      'Take prescribed medications',',      'Avoid isolation';'    ] }  /**   * Generate short-term goals for recovery   */  private generateShortTermGoals(emergency: EmergencyEvent) RecoveryGoal[] {    return [      { goal: "Attend follow-up appointment", timeline: '48 hours', completed: false },'      { goal: "Complete daily mood tracking", timeline: '1 week', completed: false },'      { goal: "Practice one coping strategy daily", timeline: 'Ongoing, completed: false },'      { goal: "Connect with support person daily", timeline: '1 week', completed: false }'    ];  }  /**   * Generate support schedule   */  private generateSupportSchedule(emergency: EmergencyEvent) SupportScheduleItem[] {    return [      { type: "therapy, frequency: 'Weekly, provider: ", Primary therapist"},"      { type: "check-in, frequency: 'Daily for 1 week', provider: ", Care coordinator"},"      { type: "medication, frequency: 'As prescribed', provider: ", Psychiatrist"}"    ];  }  /**   * Generate coping strategies   */  private generateCopingStrategies(emergency: EmergencyEvent) string[] { return [      'Deep breathing exercises',',      '5-4-3-2-1 grounding technique',',      'Progressive muscle relaxation',',      'Journaling',',      'Calling a support person';'    ] }  /**   * Generate warning signs to watch   */  private generateWarningSignsToWatch(emergency: EmergencyEvent) string[] { return [      'Increased isolation',',      'Changes in sleep patterns',',      'Loss of interest in activities',',      'Increased substance use',',      'Suicidal thoughts';'    ] }  /**   * Move emergency to history   */  private moveToHistory(emergency: EmergencyEvent) void(this.activeEmergencies.delete(emergency.userId);        const history = this.emergencyHistory.get(emergency.userId) || [];    history.push(emergency );    this.emergencyHistory.set(emergency.userId, history) }  /**   * Add entry to emergency timeline   */  private addTimelineEntry(    emergency: EmergencyEvent,    action: string,    details?: string,    actor?: string  ): void {    emergency.timeline.push({      timestamp: new Date(),      action,      details,      actor,      automated: !actor    }`;  }  /**   * Generate unique ID with prefix   */  private generateId(prefix: string) string {    return ``prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}  /**   * Get active emergency for user   */  public getActiveEmergency(userId: string) EmergencyEvent | undefined { return this.activeEmergencies.get(userId }  /**   * Get emergency history for user   */  public getEmergencyHistory(userId: string) EmergencyEvent[] { return this.emergencyHistory.get(userId) || [ }  /**   * Get pending check-ins for user   */  public getPendingCheckIns(userId: string) PostCrisisCheckIn[] {    const checkIns = this.postCrisisCheckIns.get(userId) || [];    return checkIns.filter(c => c.status === 'scheduled')  }  /**   * Get recovery plan for user   */;  public getRecoveryPlan(userId: string) RecoveryPlan | undefined { return this.recoveryPlans.get(userId }// Export singleton instance for consistent usageexport const emergencyProtocolService = new EmergencyProtocolService(`;// Export type guards for runtime safetyexport function isEmergencyActive(event: EmergencyEvent)boolean(return event.response.status === 'active' || event.response.status === 'responding);export function requiresEmergencyServices(event: EmergencyEvent)boolean(return event.severity === 'critical);export function isHighPriorityEmergency(event: EmergencyEvent)boolean(return event.severity === 'critical' || event.severity === high);'