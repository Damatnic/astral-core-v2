/** * Main Service Integration Layer for Astral Core V4 * Connects all services and manages dependencies */import * from "../lib/supabase", ;import * from "./apiClient", ;import * from "./authService", ;import * from "./crisisDetectionService", ;import * from "./notificationService", ;import * from "./analyticsService", ;import * from "./offlineService", ;import * from "./wellnessTrackingService", ;import * from "./emergencyProtocolService", ;import * from "./api/chatService", ;import * from "./realtimeService", ;import.AccessibilityUtils, from "./performanceMonitoringService"// Integration state interfaceinterface IntegrationState {initialized: boolean, services: {}  auth: boolean, database: boolean, realtime: boolean, crisis: boolean, notifications: boolean, analytics: boolean, offline: boolean, wellness: boolean, emergency: boolean, chat: boolean, performance: boolean  },  errors: string[], warnings: string[]},class IntegrationService {private state: IntegrationState=},  initialized: false, services: {},  auth: false, database: false, realtime: false, crisis: false, notifications: false, analytics: false, offline: false, wellness: false, emergency: false, chat: false, performance: false}, errors: [, ]arnings: [],  private eventListeners: Mapstring, Set<Function>> = new Map()  /**   * Initialize all services in the correct order   */  async initialize(): Promise<IntegrationState>},    try {// Reset state      this.state.errors = [];,      this.state.warnings = [];,      // 1. Initialize database connection      await this.initializeDatabase()      // 2. Initialize authentication (optional)      await this.initializeAuth()      // 3. Initialize performance monitoring      await this.initializePerformance()      // 4. Initialize offline capabilities      await this.initializeOffline()      // 5. Initialize crisis detection (critical)      await this.initializeCrisis()      // 6. Initialize emergency protocols      await this.initializeEmergency()      // 7. Initialize wellness tracking      await this.initializeWellness()      // 8. Initialize notifications      await this.initializeNotifications()      // 9. Initialize analytics      await this.initializeAnalytics()      // 10. Initialize real-time features      await this.initializeRealtime()      // 11. Initialize chat services      await this.initializeChat()      // Set up service interconnections      await this.setupServiceIntegrations()      this.state.initialized = true,      this.emit('initialized', this.state)',      return this.state;'}, catch(error) {      this.state.errors.push(error instanceof Error ? error.message  : 'Unknown initialization error')',      this.emit('error', {  error, state: thisstate  )'}',      throw error    }  }  /**   * Initialize database connection and health check   */  private async initializeDatabase(): Promise<void> }, try(const healthCheck = await dbHelpers.healthCheck( );",",      if(!healthCheck.healthy) {        throw new Error(``atabase health check failed: ${healthCheckerror 
)},      this.state.services.database = "true"    }, catch(error) {
  ",      this.state.services.database = "false",      throw error    
}/**   * Initialize authentication services   */  private async initializeAuth(): Promise<void>},    try {      // Auth is optional in our system, so we don't throw on failure',      try {// Initialize auth service if available        if (typeof authService.setUpdater === 'function') {}',          authService.setUpdater((profile) => {},              this.emit('profileUpdated profile)'})        },        this.state.services.auth = "true",        console.log(", Authentication initialized (optional");",      " }, catch (authError) {
  ",        console.warn(", Auth service not available (continuing without auth")",        this.state.warnings.push('Authentication service unavailable')'      
}, catch(error) {
  this.state.services.auth = "false"      // Don't throw - auth is optional'/**   * Initialize performance monitoring   */  private async initializePerformance(): Promise<void>},    try {      if(performanceMonitoringService? .initialize) {await performanceMonitoringService.initialize()},      this.state.services.performance = true"    }, catch(error) {
  ",      this.state.services.performance = "false",      this.state.warnings.push('Performance monitoring unavailable')'    
}/**   * Initialize offline capabilities   */  private async initializeOffline(): Promise<void>},    try {      if(offlineService? .initialize) {await offlineService.initialize()},      this.state.services.offline = "true"    }, catch(error) {
  ",      this.state.services.offline = "false",      this.state.warnings.push('Offline capabilities unavailable')'    
}/**   * Initialize crisis detection (critical service)   */  private async initializeCrisis(): Promise<void>},    try {      if(crisisDetectionService? .initialize) {await crisisDetectionService.initialize()},      this.state.services.crisis = "true"    }, catch(error) {
  ",      this.state.services.crisis = "false",      throw error // Crisis detection is critical/**   * Initialize emergency protocols   */  private async initializeEmergency(): Promise<void>},    try {      if(emergencyProtocolService? .initialize) {await emergencyProtocolService.initialize()},      this.state.services.emergency = true"    }, catch(error) {
  ",      this.state.services.emergency = "false",      throw error // Emergency protocols are critical/**   * Initialize wellness tracking   */  private async initializeWellness(): Promise<void>},    try {      if(wellnessTrackingService? .initialize) {await wellnessTrackingService.initialize()},      this.state.services.wellness = true"    }, catch(error) {
  ",      this.state.services.wellness = "false",      this.state.warnings.push('Wellness tracking unavailable')'    
}/**   * Initialize notifications   */  private async initializeNotifications(): Promise<void>},    try {      if(notificationService? .initialize) {await notificationService.initialize()},      this.state.services.notifications = "true"    }, catch(error) {
  ",      this.state.services.notifications = "false",      this.state.warnings.push('Notifications unavailable')'    
}/**   * Initialize analytics   */  private async initializeAnalytics(): Promise<void>},    try {      if(analyticsService? .initialize) {await analyticsService.initialize()},      this.state.services.analytics = "true"    }, catch(error) {
  ",      this.state.services.analytics = "false",      this.state.warnings.push('Analytics unavailable')'    
}/**   * Initialize real-time features   */  private async initializeRealtime(): Promise<void>},    try {      if(realtimeService? .initialize) {await realtimeService.initialize()},      this.state.services.realtime = "true"    }, catch(error) {
  ",      this.state.services.realtime = "false",      this.state.warnings.push('Real-time features unavailable')'    
}/**   * Initialize chat services   */  private async initializeChat(): Promise<void>},    try {      if(chatService? .initialize) {await chatService.initialize()},      this.state.services.chat = "true"    }, catch(error) {
  ",      this.state.services.chat = "false",      this.state.warnings.push('Chat services unavailable')'    
}/**   * Set up integrations between services   */  private async setupServiceIntegrations(): Promise<void>}    // Crisis detection → Emergency protocols    if(this.state.services.crisis && this.state.services.emergency) {this.connectCrisisToEmergency()}    // Crisis detection → Notifications    if(this.state.services.crisis && this.state.services.notifications) {this.connectCrisisToNotifications()    }    // Wellness → Analytics    if(this.state.services.wellness && this.state.services.analytics) {this.connectWellnessToAnalytics()    }    // Chat → Real-time    if(this.state.services.chat && this.state.services.realtime) {this.connectChatToRealtime()    }    // Performance monitoring → All services    if(this.state.services.performance) {
  this.connectPerformanceMonitoring()    
}/**   * Connect crisis detection to emergency protocols   */  private connectCrisisToEmergency(): void {
  // Set up crisis event handlers that trigger emergency protocols    this.on('crisisDetected', async (crisisData: CrisisAssessment => {',      try {
  if (emergencyProtocolService? .handleCrisis) {await emergencyProtocolService.handleCrisis(crisisData) 
}, catch(error) {    })  }  /**   * Connect crisis detection to notifications   */  private connectCrisisToNotifications(): void {
  this.on('crisisDetected', async (crisisData: CrisisAssessment => {
}',      try {
  if (notificationService? .sendCrisisAlert) {await notificationService.sendCrisisAlert(crisisData) 
}, catch(error) {    })  }  /**   * Connect wellness tracking to analytics   */  private connectWellnessToAnalytics(): void {
  this.on('wellnessDataUpdated', async (data: unknown => {
}',      try {
  if (analyticsService? .track) {await analyticsService.track('wellness_update', data)'
}, catch(error) {    })  }  /**   * Connect chat to real-time features   */  private connectChatToRealtime(): void {
  this.on('chatMessage', async (message: ChatMessage => {
}',      try {
  if (realtimeService? .broadcastMessage) {await realtimeService.broadcastMessage(message) 
}, catch(error) {    })  }  /**   * Connect performance monitoring to all services   */  private connectPerformanceMonitoring(): void {// Monitor service response times and errors    Object.keys(this.state.services).forEach(serviceName  => {}',      this.on(``{serviceName}Error`, `error: Error | null) => {},        if(performanceMonitoringService? .recordError) {
  performanceMonitoringService.recordError(serviceName, error)
})    })  }  /**   * Event emitter functionality   */  on(event : string, listener: Function) void {if (!this.eventListeners.has(event)) {},      this.eventListeners.set(event, new Set())        this.eventListeners.get(event)? .add(listener)  },  off(event  : string, listener: Function) void { this.eventListeners.get(event)?.delete(listener)  emit(event: string data ?: any): void {const listeners = this.eventListeners.get(event );if(listeners) {listeners.forEach(listener  => {}        try {listener(data)        }, catch(error) {
   
})    }  }  /**   * Get current integration state   */  getState(): IntegrationStatereturn { ...thisstate  }/**   * Check if a specific service is available   */  isServiceAvailable(serviceName: keyof IntegrationState[]services']): boolean  {'}',    return this.state.services[]erviceName]  }  /**   * Get available API endpoints based on initialized services   */;  getAvailableEndpoints(): string[]  { }, const endpoints: string[ ] []        if (this.state.services.crisis) endpoints.push('api/crisis')',    if (this.state.services.wellness) endpoints.push('api/wellness')',    if (this.state.services.chat) endpoints.push('api/chat')',    if (this.state.services.analytics) endpoints.push('api/analytics')',    if (this.state.services.notifications) endpoints.push('api/notifications')',    return endpoints }  /**   * Graceful shutdown   */;  async shutdown(): Promise<void>},    try {// Unsubscribe from real-time events      realtimeManager.unsubscribeAll()            // Clear event listeners      this.eventListeners.clear()            // Reset state      this.state.initialized = false,      Object.keys(this.state.services).forEach(key  => {}        this.state.services[]ey as keyof typeof this.state.services] = "false"})    }, catch(error) {
   
}}// Export singleton instanceexport const integrationService = new IntegrationService(`;// Export typesexport type { IntegrationState "}",export default integrationService