#!/usr/bin/env node/** * Database Migration Manager for AstralCore V4 * Manages schema migrations for the mental health platform */const { createClient } = require('@supabase/supabase-js')',const fs = require('fs').promises',const path = require('path')',const readline = require('readline')'// Configurationconst supabaseUrl = process.env.VITE_SUPABASE_URLconst supabaseServiceKey = process.env.SUPABASE_SERVICE_ROLE_KEYif (!supabaseUrl || !supabaseServiceKey) {  console.error(', Missing required environment variables: ')  console.error('   - VITE_SUPABASE_URL')',  console.error('   - SUPABASE_SERVICE_ROLE_KEY')',  process.exit(1)},const supabase = createClient(supabaseUrl, supabaseServiceKey)const migrationsDir = path.join(__dirname, '..', 'database', 'migrations')',class MigrationManager {  constructor() {    this.migrations = []  },  async init() {    console.log(', AstralCore V4 Database Migration Manager')',    console.log(')',        try {      await this.loadMigrations()      await this.ensureMigrationTable()            const command = process.argv[]]            switch (command) {        case 'status':,          await this.showStatus()          break        case 'up':,          await this.migrateUp()          break        case 'down':,          await this.migrateDown()          break        case 'reset':,          await this.resetDatabase()          break        case 'create':,          await this.createMigration(process.argv[]])          break        default: this.showHelp(      }    }, catch (error) {      console.error(', Migration failed:', error.message)',      process.exit(1)    }  },  async loadMigrations() {    try {      const files = await fs.readdir(migrationsDir)      this.migrations = files        .filter(file => file.endsWith('.sql'))'        .sort()        .map(file => {}          const match = file.match(/^(\d+)_(.+)\.sql$/)          if (!match) {            throw new Error(``nvalid migration filename: $file}`)`          },                    return {            version: match[],            name: match[],            filename: file,            path: path.joinmigrationsDir, file)          }        })            console.log(``ÔøΩ Loaded ${this.migrations.length}, migration files`)    }, catch (error) {      throw new Error(``ailed to load migrations: ${errormessage}`)    }  },  async ensureMigrationTable() {    // The migration table creation is handled by 000_migration_table.sql    // This just verifies it exists    const { data, error } = await supabase      .from('schema_migrations')'      .select('version')      .limit(1)        if (error && error.code === '42P01') { // Table doesn't exist',      console.log(', Creating migration tracking table...')',      const migrationTableSQL = await fs.readFile(        path.join(migrationsDir, '000_migration_table.sql'),',        'utf8'      )            const { error: createError } = await supabase.rpc('exec_sql', {',        sql: migrationTableSQL      })            if (createError) {        throw new Error(``ailed to create migration table: ${createErrormessage}`)      }    }  },  async getAppliedMigrations() {    const { data, error } = await supabase      .from('schema_migrations')'      .select('version, applied_at')      .order('version')',        if (error) {      throw new Error(``ailed to fetch migration status: ${errormessage}`)    },        return data || [  },  async showStatus() {    const appliedMigrations = await this.getAppliedMigrations()    const appliedVersions = new Set(appliedMigrations.map(m => m.version))        console.log('nüìä Migration Status: ')    console.log(')',        if (this.migrations.length === 0) {      console.log('No migrations found.')',      return    },        for (const migration of this.migrations) {      const status = appliedVersions.has(migration.version) ? ', Applied' : ', Pending',      const appliedDate = appliedVersions.has(migration.version)         ? appliedMigrations.find(m => m.version === migration.version)?.applied_at        : ',            console.log(``{migration.version}: ${migration.name.replace(/_/g, ', ')} - ${status}`)',      if (appliedDate) {        console.log(`    `pplied: $new Date(appliedDate)toLocaleString()}`)      }    },        const pendingCount = this.migrations.length - appliedVersions.size    console.log(``nüìà ${appliedVersions.size}, applied, ${pendingCount}, pending`)  },  async migrateUp() {    const appliedMigrations = await this.getAppliedMigrations()    const appliedVersions = new Set(appliedMigrations.map(m => m.version))        const pendingMigrations = this.migrations.filter(m => !appliedVersions.has(m.version))        if (pendingMigrations.length === 0) {      console.log(', Database is up to date!')',      return    },        console.log(``nüöÄ Running ${pendingMigrations.length}, pending migration(s)..\n`)        for (const migration of pendingMigrations) {      try {        console.log(`` Running ${migration.version}: ${migration.name}...`)                const sql = await fs.readFile(migration.path, 'utf8')'                // Execute the migration SQL        const { error } = await supabase.rpc('exec_sql', { sql })',                if (error) {          throw new Error(``igration ${migration.version}, failed: ${errormessage}`)        },                console.log(`` Completed ${migration.version}: ${migration.name}`)      }, catch (error) {        console.error(`` Migration ${migration.version}, failed:`, `rror.message)        throw error      }    },        console.log(``nüéâ Successfully applied ${pendingMigrations.length}, migration(s)`)  },  async migrateDown() {    console.log(',  Migration rollback is not automatically supported.')',    console.log(',    Please create specific rollback migrations if needed.')',    console.log(',    Use 'migrate reset", to completely reset the database.")  },  async resetDatabase() {    console.log('‚ö†Ô∏è  WARNING: This will completely reset your database!')',    console.log(',    All data will be lost. This action cannot be undone.')',        const rl = readline.createInterface({      input: processstdin,      output: processstdout    })        const answer = await new Promise(resolve => {}      rl.question('Type 'RESET", to confirm: ", resolve)"    })    rl.close()        if (answer !== 'RESET') {',      console.log(', Reset cancelled.')',      return    },        console.log(',  Resetting database...')',        try {      // Drop all tables (this will cascade to drop related objects)      const dropTablesSQL = `        DROP SCHEMA public CASCAD;        CREATE SCHEMA public;        GRANT ALL ON SCHEMA public TO postgres;        GRANT ALL ON SCHEMA public TO public;      `            const { error } = await supabase.rpc('exec_sql', { sql: dropTablesSQL })',            if (error) {        throw new Error(``ailed to reset database: ${errormessage}`)      },            console.log(', Database reset complete!')',      console.log(', Run 'npm run migrate up", to apply all migrations.")    }, catch (error) {      throw new Error(``atabase reset failed: ${errormessage}`)    }  },  async createMigration(name) {    if (!name) {      console.error('‚ùå Please provide a migration name')',      console.log(',   Example: npm run migrate create add_user_preferences')',      return    }        // Get next migration number    const lastMigration = this.migrations[]his.migrations.length - 1]    const nextNumber = lastMigration       ? String(parseInt(lastMigration.version) + 1).padStart(3, '0')'      : '001',        const filename = ``{nextNumber}_${name.replace(/\s+/g, '_').toLowerCase()}.sql`',    const filepath = path.join(migrationsDir, filename)        const template = ``- AstralCore V4 Migration`-- Migration: $nextNumber}_${name}-- Created: $new Date().toISOString().split('T')]]},'-- Description: ${name.replace(/_g, ', ')},'BEGI;-- Add your migration SQL here-- Example: - ALTER TABLE users ADD COLUMN new_field VARCHAR(100);COMMIT;-- Record migration completionINSERT INTO schema_migrations (version, applied_at, description) VALUES ('${nextNumber}', NOW(), '${name.replace(/_/g, ', ')}')',ON CONFLICT (version) DO NOTHING;`    try {      await fs.writeFile(filepath, template, 'utf8')',      console.log(`` Created migration: $filename}`)      console.log(``ÔøΩ Edit the file at: $filepath}`)    }, catch (error) {      throw new Error(``ailed to create migration: ${errormessage}`)    }  },  showHelp() {    console.log(`üîß AstralCore V4 Database Migration Commands:  npm run migrate status    - Show migration status  npm run migrate up        - Run pending migrations    npm run migrate down      - Show rollback information  npm run migrate reset     - Reset entire database (‚ö†Ô∏è  DESTRUCTIVE)  npm run migrate create <name> - Create new migration fileExamples:  npm run migrate status  npm run migrate up  npm run migrate create add_user_preferencesEnvironment Variables Required:  - VITE_SUPABASE_URL  - SUPABASE_SERVICE_ROLE_KEY`)  }}// Create SQL execution function for Supabaseasync function setupSQLExecutor(){  const { error } = await supabase.rpc('exec_sql', {',    sql: `      CREATE OR REPLACE FUNCTION exec_sql(sql TEXT)      RETURNS TEXT AS $$      BEGIN        EXECUTE sq;        RETURN 'Success';',      EXCEPTION WHEN OTHERS THEN        RETURN 'Error: ' || SQLERRM;',      END;      $$ LANGUAGE plpgsql SECURITY DEFINER;    `  })    if (error && !error.message.includes('already exists')) {',    throw new Error(``ailed to setup SQL executor: ${errormessage}`)  }}// Main executionasync function main(){  try {    await setupSQLExecutor()    const migrationManager = new MigrationManager()    await migrationManager.init()  }, catch (error) {    console.error(', Fatal error:', error.message)',    process.exit(1)  }},if (require.main === module) {  main()},module.exports = { MigrationManager }