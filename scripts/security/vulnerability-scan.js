/**
 * Vulnerability Scanning Script for CoreV2
 * Performs automated security vulnerability detection
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

class VulnerabilityScanner {
  constructor() {
    this.scanResults = {
      timestamp: new Date().toISOString(),
      scans: [],
      totalVulnerabilities: 0,
      criticalCount: 0,
      highCount: 0,
      mediumCount: 0,
      lowCount: 0,
    };
  }

  async runScan() {
    console.log('🔍 Starting Vulnerability Scan...\n');
    
    await this.scanDependencies();
    await this.scanCodePatterns();
    await this.scanSensitiveData();
    await this.scanCryptoWeakness();
    await this.scanInjectionPoints();
    await this.scanAuthenticationFlaws();
    await this.scanSessionManagement();
    await this.scanCORS();
    await this.scanHeaders();
    await this.scanFileUploads();
    
    this.generateReport();
  }

  /**
   * Scan npm dependencies for known vulnerabilities
   */
  async scanDependencies() {
    console.log('📦 Scanning dependencies...');
    const vulnerabilities = [];
    
    try {
      // Run npm audit
      const auditResult = execSync('npm audit --json', { 
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'ignore']
      });
      const audit = JSON.parse(auditResult);
      
      if (audit.vulnerabilities) {
        Object.entries(audit.vulnerabilities).forEach(([pkg, data]) => {
          vulnerabilities.push({
            package: pkg,
            severity: data.severity,
            via: data.via,
            range: data.range,
            fixAvailable: data.fixAvailable,
          });
          
          this.updateCounts(data.severity);
        });
      }
    } catch (error) {
      // npm audit returns non-zero exit code when vulnerabilities found
      if (error.stdout) {
        try {
          const audit = JSON.parse(error.stdout);
          if (audit.vulnerabilities) {
            Object.entries(audit.vulnerabilities).forEach(([pkg, data]) => {
              vulnerabilities.push({
                package: pkg,
                severity: data.severity,
                via: data.via,
              });
              
              this.updateCounts(data.severity);
            });
          }
        } catch (parseError) {
          console.error('Failed to parse npm audit results');
        }
      }
    }
    
    // Check for outdated packages
    try {
      const outdated = execSync('npm outdated --json', { 
        encoding: 'utf8',
        stdio: ['pipe', 'pipe', 'ignore']
      });
      if (outdated) {
        const packages = JSON.parse(outdated);
        Object.entries(packages).forEach(([pkg, versions]) => {
          if (versions.current !== versions.latest) {
            vulnerabilities.push({
              package: pkg,
              severity: 'info',
              issue: `Outdated: ${versions.current} → ${versions.latest}`,
            });
          }
        });
      }
    } catch (error) {
      // npm outdated returns non-zero exit when packages are outdated
    }
    
    this.scanResults.scans.push({
      name: 'Dependency Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan code for vulnerable patterns
   */
  async scanCodePatterns() {
    console.log('🔍 Scanning code patterns...');
    const vulnerabilities = [];
    
    const patterns = [
      {
        pattern: /eval\s*\(/g,
        severity: 'high',
        message: 'Use of eval() detected',
      },
      {
        pattern: /innerHTML\s*=/g,
        severity: 'medium',
        message: 'Direct innerHTML assignment (XSS risk)',
      },
      {
        pattern: /document\.write/g,
        severity: 'medium',
        message: 'Use of document.write() detected',
      },
      {
        pattern: /\.exec\s*\(/g,
        severity: 'high',
        message: 'Command execution detected',
      },
      {
        pattern: /new Function\s*\(/g,
        severity: 'high',
        message: 'Dynamic function creation',
      },
      {
        pattern: /\$\{.*\}/g,
        severity: 'low',
        message: 'Template literal in SQL query context',
      },
      {
        pattern: /localStorage\.(setItem|getItem)/g,
        severity: 'low',
        message: 'localStorage usage (sensitive data risk)',
      },
      {
        pattern: /console\.(log|error|warn)/g,
        severity: 'low',
        message: 'Console logging in production code',
      },
    ];
    
    const scanDirectory = (dir) => {
      const files = fs.readdirSync(dir);
      
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules') && !file.startsWith('.')) {
          scanDirectory(filePath);
        } else if (file.endsWith('.js') || file.endsWith('.ts') || file.endsWith('.jsx') || file.endsWith('.tsx')) {
          const content = fs.readFileSync(filePath, 'utf8');
          
          patterns.forEach(({ pattern, severity, message }) => {
            const matches = content.match(pattern);
            if (matches) {
              vulnerabilities.push({
                file: filePath.replace(process.cwd(), ''),
                severity,
                issue: message,
                occurrences: matches.length,
              });
              
              this.updateCounts(severity);
            }
          });
        }
      });
    };
    
    scanDirectory(path.join(__dirname, '../../src'));
    
    this.scanResults.scans.push({
      name: 'Code Pattern Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan for exposed sensitive data
   */
  async scanSensitiveData() {
    console.log('🔐 Scanning for sensitive data...');
    const vulnerabilities = [];
    
    const sensitivePatterns = [
      {
        pattern: /api[_-]?key\s*[:=]\s*["'][^"']+["']/gi,
        type: 'API Key',
        severity: 'critical',
      },
      {
        pattern: /secret[_-]?key\s*[:=]\s*["'][^"']+["']/gi,
        type: 'Secret Key',
        severity: 'critical',
      },
      {
        pattern: /password\s*[:=]\s*["'][^"']+["']/gi,
        type: 'Hardcoded Password',
        severity: 'critical',
      },
      {
        pattern: /token\s*[:=]\s*["'][^"']+["']/gi,
        type: 'Token',
        severity: 'high',
      },
      {
        pattern: /\b\d{3}-\d{2}-\d{4}\b/g,
        type: 'SSN Pattern',
        severity: 'critical',
      },
      {
        pattern: /\b(?:\d{4}[-\s]?){3}\d{4}\b/g,
        type: 'Credit Card Pattern',
        severity: 'critical',
      },
    ];
    
    const scanFile = (filePath) => {
      if (!fs.existsSync(filePath)) return;
      
      const content = fs.readFileSync(filePath, 'utf8');
      
      sensitivePatterns.forEach(({ pattern, type, severity }) => {
        const matches = content.match(pattern);
        if (matches) {
          vulnerabilities.push({
            file: filePath.replace(process.cwd(), ''),
            type,
            severity,
            found: matches.length,
          });
          
          this.updateCounts(severity);
        }
      });
    };
    
    // Scan common files
    ['.env', '.env.local', '.env.production'].forEach(file => {
      scanFile(path.join(__dirname, '../../', file));
    });
    
    // Scan source files
    const scanSourceFiles = (dir) => {
      if (!fs.existsSync(dir)) return;
      
      const files = fs.readdirSync(dir);
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules')) {
          scanSourceFiles(filePath);
        } else if (file.endsWith('.js') || file.endsWith('.ts')) {
          scanFile(filePath);
        }
      });
    };
    
    scanSourceFiles(path.join(__dirname, '../../src'));
    
    this.scanResults.scans.push({
      name: 'Sensitive Data Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan for cryptographic weaknesses
   */
  async scanCryptoWeakness() {
    console.log('🔓 Scanning cryptographic implementations...');
    const vulnerabilities = [];
    
    const weakPatterns = [
      {
        pattern: /md5/gi,
        issue: 'MD5 hash usage (weak)',
        severity: 'high',
      },
      {
        pattern: /sha1/gi,
        issue: 'SHA1 hash usage (weak)',
        severity: 'medium',
      },
      {
        pattern: /Math\.random/g,
        issue: 'Math.random for cryptographic purposes',
        severity: 'high',
      },
      {
        pattern: /DES|3DES/g,
        issue: 'Weak encryption algorithm',
        severity: 'high',
      },
      {
        pattern: /rc4/gi,
        issue: 'RC4 cipher (broken)',
        severity: 'critical',
      },
    ];
    
    const scanDirectory = (dir) => {
      if (!fs.existsSync(dir)) return;
      
      const files = fs.readdirSync(dir);
      
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules')) {
          scanDirectory(filePath);
        } else if (file.endsWith('.js') || file.endsWith('.ts')) {
          const content = fs.readFileSync(filePath, 'utf8');
          
          weakPatterns.forEach(({ pattern, issue, severity }) => {
            if (pattern.test(content)) {
              vulnerabilities.push({
                file: filePath.replace(process.cwd(), ''),
                issue,
                severity,
              });
              
              this.updateCounts(severity);
            }
          });
        }
      });
    };
    
    scanDirectory(path.join(__dirname, '../../src'));
    
    this.scanResults.scans.push({
      name: 'Cryptographic Weakness Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan for injection vulnerabilities
   */
  async scanInjectionPoints() {
    console.log('💉 Scanning for injection points...');
    const vulnerabilities = [];
    
    const injectionPatterns = [
      {
        pattern: /query\s*\(\s*['"`].*\$\{.*\}/g,
        type: 'SQL Injection',
        severity: 'critical',
      },
      {
        pattern: /query\s*\(\s*['"`].*\+.*\+/g,
        type: 'SQL Injection',
        severity: 'critical',
      },
      {
        pattern: /exec\s*\(\s*.*\$\{.*\}/g,
        type: 'Command Injection',
        severity: 'critical',
      },
      {
        pattern: /findOne\s*\(\s*\{.*\$where/g,
        type: 'NoSQL Injection',
        severity: 'high',
      },
      {
        pattern: /\$\{.*\}.*<\/script>/g,
        type: 'XSS Injection',
        severity: 'high',
      },
    ];
    
    const scanDirectory = (dir) => {
      if (!fs.existsSync(dir)) return;
      
      const files = fs.readdirSync(dir);
      
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules')) {
          scanDirectory(filePath);
        } else if (file.endsWith('.js') || file.endsWith('.ts')) {
          const content = fs.readFileSync(filePath, 'utf8');
          
          injectionPatterns.forEach(({ pattern, type, severity }) => {
            if (pattern.test(content)) {
              vulnerabilities.push({
                file: filePath.replace(process.cwd(), ''),
                type,
                severity,
              });
              
              this.updateCounts(severity);
            }
          });
        }
      });
    };
    
    scanDirectory(path.join(__dirname, '../../src'));
    
    this.scanResults.scans.push({
      name: 'Injection Vulnerability Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan authentication mechanisms
   */
  async scanAuthenticationFlaws() {
    console.log('🔑 Scanning authentication...');
    const vulnerabilities = [];
    
    // Check for weak JWT configurations
    const jwtConfigPath = path.join(__dirname, '../../src/config/security.config.ts');
    if (fs.existsSync(jwtConfigPath)) {
      const content = fs.readFileSync(jwtConfigPath, 'utf8');
      
      if (content.includes('HS256') && !content.includes('RS256')) {
        vulnerabilities.push({
          file: '/src/config/security.config.ts',
          issue: 'Using HS256 instead of RS256 for JWT',
          severity: 'medium',
        });
        this.updateCounts('medium');
      }
      
      if (content.includes('expiresIn: \'24h\'') || content.includes('expiresIn: \'7d\'')) {
        vulnerabilities.push({
          file: '/src/config/security.config.ts',
          issue: 'JWT expiration time too long',
          severity: 'low',
        });
        this.updateCounts('low');
      }
    }
    
    this.scanResults.scans.push({
      name: 'Authentication Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan session management
   */
  async scanSessionManagement() {
    console.log('🍪 Scanning session management...');
    const vulnerabilities = [];
    
    const sessionPatterns = [
      {
        pattern: /httpOnly\s*:\s*false/g,
        issue: 'Session cookie without httpOnly flag',
        severity: 'high',
      },
      {
        pattern: /secure\s*:\s*false/g,
        issue: 'Session cookie without secure flag',
        severity: 'high',
      },
      {
        pattern: /sameSite\s*:\s*['"`]none['"`]/g,
        issue: 'Session cookie with sameSite=none',
        severity: 'medium',
      },
    ];
    
    const configFiles = [
      'src/config/security.config.ts',
      'src/middleware/security.middleware.ts',
    ];
    
    configFiles.forEach(file => {
      const filePath = path.join(__dirname, '../../', file);
      if (fs.existsSync(filePath)) {
        const content = fs.readFileSync(filePath, 'utf8');
        
        sessionPatterns.forEach(({ pattern, issue, severity }) => {
          if (pattern.test(content)) {
            vulnerabilities.push({
              file: '/' + file,
              issue,
              severity,
            });
            
            this.updateCounts(severity);
          }
        });
      }
    });
    
    this.scanResults.scans.push({
      name: 'Session Management Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan CORS configuration
   */
  async scanCORS() {
    console.log('🌐 Scanning CORS configuration...');
    const vulnerabilities = [];
    
    const configPath = path.join(__dirname, '../../src/config/security.config.ts');
    if (fs.existsSync(configPath)) {
      const content = fs.readFileSync(configPath, 'utf8');
      
      if (content.includes('origins: [\'*\']')) {
        vulnerabilities.push({
          file: '/src/config/security.config.ts',
          issue: 'CORS allows all origins (*)',
          severity: 'critical',
        });
        this.updateCounts('critical');
      }
      
      if (content.includes('credentials: true') && content.includes('\'*\'')) {
        vulnerabilities.push({
          file: '/src/config/security.config.ts',
          issue: 'CORS allows credentials with wildcard origin',
          severity: 'critical',
        });
        this.updateCounts('critical');
      }
    }
    
    this.scanResults.scans.push({
      name: 'CORS Configuration Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan security headers
   */
  async scanHeaders() {
    console.log('📋 Scanning security headers...');
    const vulnerabilities = [];
    
    const requiredHeaders = [
      'Strict-Transport-Security',
      'X-Content-Type-Options',
      'X-Frame-Options',
      'Content-Security-Policy',
      'Referrer-Policy',
    ];
    
    const configPath = path.join(__dirname, '../../src/config/security.config.ts');
    if (fs.existsSync(configPath)) {
      const content = fs.readFileSync(configPath, 'utf8');
      
      requiredHeaders.forEach(header => {
        const headerKey = header.replace(/-/g, '').toLowerCase();
        if (!content.toLowerCase().includes(headerKey)) {
          vulnerabilities.push({
            header,
            issue: `Missing ${header} configuration`,
            severity: 'medium',
          });
          this.updateCounts('medium');
        }
      });
    }
    
    this.scanResults.scans.push({
      name: 'Security Headers Scan',
      vulnerabilities,
    });
  }

  /**
   * Scan file upload security
   */
  async scanFileUploads() {
    console.log('📤 Scanning file upload security...');
    const vulnerabilities = [];
    
    const uploadPatterns = [
      {
        pattern: /upload.*\(.*\)/g,
        checkFor: 'fileFilter|mimetype|limits',
        issue: 'File upload without validation',
        severity: 'high',
      },
      {
        pattern: /multer\s*\(\s*\{[^}]*\}/g,
        checkFor: 'limits|fileFilter',
        issue: 'Multer without file restrictions',
        severity: 'high',
      },
    ];
    
    const scanDirectory = (dir) => {
      if (!fs.existsSync(dir)) return;
      
      const files = fs.readdirSync(dir);
      
      files.forEach(file => {
        const filePath = path.join(dir, file);
        const stat = fs.statSync(filePath);
        
        if (stat.isDirectory() && !file.includes('node_modules')) {
          scanDirectory(filePath);
        } else if (file.endsWith('.js') || file.endsWith('.ts')) {
          const content = fs.readFileSync(filePath, 'utf8');
          
          uploadPatterns.forEach(({ pattern, checkFor, issue, severity }) => {
            const matches = content.match(pattern);
            if (matches) {
              matches.forEach(match => {
                if (!checkFor.split('|').some(check => match.includes(check))) {
                  vulnerabilities.push({
                    file: filePath.replace(process.cwd(), ''),
                    issue,
                    severity,
                  });
                  
                  this.updateCounts(severity);
                }
              });
            }
          });
        }
      });
    };
    
    scanDirectory(path.join(__dirname, '../../src'));
    
    this.scanResults.scans.push({
      name: 'File Upload Security Scan',
      vulnerabilities,
    });
  }

  /**
   * Update vulnerability counts
   */
  updateCounts(severity) {
    this.scanResults.totalVulnerabilities++;
    
    switch (severity.toLowerCase()) {
      case 'critical':
        this.scanResults.criticalCount++;
        break;
      case 'high':
        this.scanResults.highCount++;
        break;
      case 'medium':
      case 'moderate':
        this.scanResults.mediumCount++;
        break;
      case 'low':
      case 'info':
        this.scanResults.lowCount++;
        break;
    }
  }

  /**
   * Generate scan report
   */
  generateReport() {
    const reportPath = path.join(__dirname, '../../audit-reports');
    if (!fs.existsSync(reportPath)) {
      fs.mkdirSync(reportPath, { recursive: true });
    }
    
    const filename = `vulnerability-scan-${Date.now()}.json`;
    const filepath = path.join(reportPath, filename);
    
    fs.writeFileSync(filepath, JSON.stringify(this.scanResults, null, 2));
    
    console.log('\n' + '='.repeat(60));
    console.log('VULNERABILITY SCAN REPORT');
    console.log('='.repeat(60));
    console.log(`Timestamp: ${this.scanResults.timestamp}`);
    console.log(`Total Vulnerabilities: ${this.scanResults.totalVulnerabilities}`);
    console.log('\nSeverity Breakdown:');
    console.log(`  🔴 Critical: ${this.scanResults.criticalCount}`);
    console.log(`  🟠 High: ${this.scanResults.highCount}`);
    console.log(`  🟡 Medium: ${this.scanResults.mediumCount}`);
    console.log(`  🟢 Low: ${this.scanResults.lowCount}`);
    
    console.log('\nScan Results:');
    this.scanResults.scans.forEach(scan => {
      console.log(`\n${scan.name}:`);
      if (scan.vulnerabilities.length === 0) {
        console.log('  ✅ No vulnerabilities found');
      } else {
        scan.vulnerabilities.slice(0, 5).forEach(vuln => {
          console.log(`  - ${JSON.stringify(vuln)}`);
        });
        if (scan.vulnerabilities.length > 5) {
          console.log(`  ... and ${scan.vulnerabilities.length - 5} more`);
        }
      }
    });
    
    console.log('\n' + '='.repeat(60));
    console.log(`Full report saved to: ${filepath}`);
    console.log('='.repeat(60));
    
    // Exit with error code if critical vulnerabilities found
    if (this.scanResults.criticalCount > 0) {
      console.error('\n❌ Critical vulnerabilities found!');
      process.exit(1);
    } else if (this.scanResults.highCount > 0) {
      console.warn('\n⚠️ High severity vulnerabilities found');
      process.exit(0);
    } else {
      console.log('\n✅ No critical or high severity vulnerabilities found');
    }
  }
}

// Run the scanner
const scanner = new VulnerabilityScanner();
scanner.runScan().catch(error => {
  console.error('Scan failed:', error);
  process.exit(1);
});