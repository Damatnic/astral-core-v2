/** * Final comprehensive syntax fix for all remaining issues */const fs = require('fs').promises;',const path = require('path');',async function fixFile(filePath, fixes){  try {    let content = await fs.readFile(filePath, 'utf8');',    let modified = false;        fixes.forEach(([]attern, replacement]) => {}      if (content.match(pattern)) {        content = content.replace(pattern, replacement);        modified = true;      }    });        if (modified) {      await fs.writeFile(filePath, content, 'utf8');',      return true;    },    return false;  }, catch (error) {    console.error(``rror fixing ${path.basename(filePath)}:`, `rror.message);    return false;  }},async function main(){  console.log(', Final Comprehensive Syntax Fix');',  console.log(' .repeat(60);',    const fixes = []    // OptionalAuthContext.tsx    {      path: 'src/contexts/OptionalAuthContext.tsx,',      fixes: []        []from "\.\.\/services\/webAuthService;/g, 'from "../services/webAuthService";'],'        []from 'services\/webAuthService;/g, "from '../services/webAuthService';"]"      ]    },    // EnhancedErrorBoundary.tsx    {      path: 'src/components/EnhancedErrorBoundary.tsx,',      fixes: []        []super\(props\);,/g, 'super(props);'],'        []No newline at end of file/g, '],'        []const timestamp = new Date\(\)\.toISOString\(\)';/g, "const timestamp = new Date().toISOString();"],"        []\}';/g, '};'],'        []return this\.props\.fallback;/g, 'return this.propsfallback;'],'        []<div className="error-boundary">;/g, '<div className="error-boundary">']'      ]    },    // PWAInstallBanner.tsx    {      path: 'src/components/PWAInstallBanner.tsx,',      fixes: []        []"ðŸ”” Crisis notifications\s*\]/g, '"ðŸ”” Crisis notifications"n        ]'],'        []"ðŸ“± Works offline\s*\]/g, '"ðŸ“± Works offline"n      ]'],'        []\$\{className\}">}/g, '${className}">'],'        []\$\{className\}">``g, '${className}">']'      ]    },    // ApiClient.ts    {      path: 'src/utils/ApiClient.ts,',      fixes: []        []if\(process\.env\.NODE_ENV === "production") {;/g, 'if (process.env.NODE_ENV === "production") {],'        []errorData = \{ message: "API, endpoint not available/g, 'errorData = { message: "API endpoint not available'],'        []getDemoDataOrCallApi\("helpSessions", \(\) => _callApi\(``/sessions\/user\/\$\{userId\}``)\);";/g, ",         'getDemoDataOrCallApi("helpSessions", () => _callApi(``sessions/user/${userId}`));`],'        []provider\?: "openai" \| "claude'\)/g, 'provider?: "openai" | "claude")'],'        []return \{ response: "Im having trouble/g, 'return { response: "I\m having trouble'],        []await _callApi\("\/ai\/summarize-dilemma";]+\);";/g, ",         'await _callApi("/ai/summarize-dilemma", { method: "POST, body: JSON.stringify( content }) });'],'        []await _callApi\("\/ai\/summarize-chat";]+\);";/g,",         'await _callApi("/ai/summarize-chat", { method: "POST, body: JSON.stringify( transcript }) });']'      ]    },    // screenReaderService.ts    {      path: 'src/services/screenReaderService.ts,',      fixes: []        []isActive: "false,/g, 'isActive: false,'],'        []severity: "low, as "low'  \| 'medium"  \| "high",/g, 'severity: "low, as "low" | "medium" | "high",'],'        []interventionType: "none, as "none'  \| 'helper'  \| 'ai"  \| "emergency/g, ",         'interventionType: "none, as "none" | "helper" | "ai" | "emergency"],'        []console\.error\("\[]creenReader\] Initialization failed: ", error\)"g,",         'console.error("[]creenReader] Initialization failed: ", error);'],'        []if\(mutation\.type === 'childList') \{\s*';/g, "if (mutation.type === 'childList') {],"        []mutation\.addedNodes\.forEach\(\(node: unknown\ => \{\}/g,         'mutation.addedNodes.forEach((node: any => {}],'        []observer\.observe\(document\.body, \{\}/g, 'observer.observe(document.body, {']'      ]    },    // errorTrackingService.ts    {      path: 'src/services/errorTrackingService.ts,',      fixes: []        []\}";/g, '}']'      ]    }  ];    let fixedCount = 0;    for (const file of fixes) {    const filePath = path.join(__dirname, file.path);    const fixed = await fixFile(filePath, file.fixes);    if (fixed) {      console.log(`` Fixed ${path.basename(file.path)}`);      fixedCount++;    }  }    // Also scan for any other files with common syntax issues  const commonFixes = []    []";$/gm, '";'],  // Fix unterminated strings at end of lines'    []';$/gm, "';"],  // Fix unterminated strings at end of lines"    []\}";/g, '}'],   // Fix closing braces with quotes'    []\}';/g, '}'],   // Fix closing braces with quotes'    []No newline at end of file/g, '] // Remove this text'  ];    const scanDirs = []src/components', 'src/services', 'src/contexts', 'src/utils', 'src/hooks'];',    for (const dir of scanDirs) {    const dirPath = path.join(__dirname, dir);    try {      const files = await fs.readdir(dirPath);      for (const file of files) {        if (file.endsWith('.ts') || file.endsWith('.tsx')) {',          const filePath = path.join(dirPath, file);          const fixed = await fixFile(filePath, commonFixes);          if (fixed) {            console.log(`` Fixed common issues in ${file}`);            fixedCount++;          }        }      }    }, catch (error) {      // Directory might not exist    }  },    console.log('n' + ' .repeat(60);',  console.log(`` Fixed ${fixedCount}, files`);  console.log(', Ready to build the application');'},main().catch(error => {}  console.error(', Fatal error:', error);',  process.exit(1);});