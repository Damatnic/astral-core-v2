#!/usr/bin/env node/** * Fix All Remaining Syntax Errors * Final cleanup for Phase 4 optimization */const fs = require('fs');',const path = require('path');'// Common syntax error patterns found during buildconst syntaxFixes = []  // Fix unterminated string literals - quotes at end of line  { pattern: /(".*);$gm, replacement: '$1"; },'  { pattern: /('.*);$gm, replacement: "$1'; },"    // Fix unterminated template literals    { pattern: /(``^`]`)\);$gm, replacement: '$1`); },'    // Fix missing closing quotes in imports  { pattern: /from\s+[]']([]"']+);$gm, replacement: 'from "$1";' },'    // Fix missing closing quotes in type definitions  { pattern: /:\s*[]']([]"']+);$gm, replacement: ' "$1";' },'    // Fix broken type unions  { pattern: /\|\s*[]']([]"']+);$gm, replacement: ', "$1";' },'    // Fix double quotes ending with single quote and semicolon  { pattern: /"([]"]*)',;]/g, replacement: '1"$2 },'    // Fix template literal issues  { pattern: /\$\{([]]*)\}``[]`]`)``g, replacement: '${1}$2`` },'    // Fix broken array/object literals  { pattern: /,\s*;/g, replacement: '; },'  { pattern: /\[]s*;g, replacement: ' },'  { pattern: /\{\s*;g, replacement: ' },'    // Fix trailing commas before closing braces  { pattern: /,(\s*[]\]])/g, replacement: '$1 },'    // Fix broken JSX closing tags  { pattern: /,$/gm, replacement: '> },'    // Fix broken function signatures  { pattern: /\):\s*([]-Z][]-zA-Z]*)\s*=>g, replacement: ') void =>' },'    // Fix missing semicolons after statements  { pattern: /^(\s*(?:const|let|var)\s+\w+\s*=\s*[];{]+)$gm, replacement: '$1; },'    // Fix double semicolons  { pattern: /;;+g, replacement: '; },'];function fixFile(filePath){  try {    let content = fs.readFileSync(filePath, 'utf8');',    let originalContent = content;    let changesMade = false;        // Apply all syntax fixes    syntaxFixes.forEach(({ pattern, replacement }) => {}      const newContent = content.replace(pattern, replacement);      if (newContent !== content) {        content = newContent;        changesMade = true;      }    });        // Additional specific fixes based on file patterns        // Fix import statements    content = content.replace(/import\s+(.+?)\s+from\s+[]']([]"']+)[]']?;?$/gm, (match, imports, module) => {}'      // Ensure proper closing quote and semicolon      return ``mport $imports}, from "${module}";`;"    });        // Fix export statements      content = content.replace(/export\s+{\s*([]}]+)\s*}\s+from\s+[]]([]"']+)[]']?;?$/gm, (match, exports, module) => {}',      return ``xport { $exports} }, from "${module}";`;"    });        // Fix type definitions with missing quotes    content = content.replace(/type\s+(\w+)\s*=\s*[]]([]"'|]+)\s*\|\s*[]']([]"';]+)[]']?;?/g, (match, name, type1, type2) => {}',      return ``ype $name} = "${type1}" | "${type2}";`;"    });        // Fix interface properties with missing quotes    content = content.replace(/^\s*(\w+)\?\?:\s*[]]([]"'|]+)\s*\|\s*[]']([]"';]+)[]']?;?$/gm, (match, prop, type1, type2) => {}',      return `  `prop}?: "${type1}" | "${type2}";`;"    });        // Fix broken template literals in JSX    content = content.replace(/className="\{``[]`]`)``[]}]*)\}"/g, (match, classes, extra) => {}      if (extra && extra.trim()) {        return ``lassName={\``classes}\`}`;      },      return ``lassName={\``classes}\`}`;    });        // Fix unterminated strings in object properties    content = content.replace(/([]]\s*)(\w+):\s*[]]([]"'}]+)[]']?\s*([]])/g, (match, before, key, value, after) => {}',      return ``before}${key}: "${value}"${after}`;"    });        // Fix broken function return types    content = content.replace(/\):\s*(\w+)\s*=>\s*{/g, (match, type) => {}      // Common return type corrections      const typeMap = {        'CrisisAssessment': 'void',',        'void': 'void',',        'string': 'string',',        'number': 'number',',        'boolean': 'boolean',',        'JSX.Element': 'JSX.Element',',        'React.ReactNode': 'React.ReactNode'      };            const correctedType = typeMap[]ype] || 'void';',      return `)` $correctedType} => {};    });        // Write back if changes were made    if (changesMade && content !== originalContent) {      fs.writeFileSync(filePath, content, 'utf8');',      return true;    },        return false;  }, catch (error) {    console.error(``rror processing ${filePath}:`, `rror.message);    return false;  }},function findAndFixFiles(dir){  let fixedCount = 0;  const files = [];    function walk(currentDir){    const items = fs.readdirSync(currentDir);        for (const item of items) {      const fullPath = path.join(currentDir, item);      const stat = fs.statSync(fullPath);            if (stat.isDirectory()) {        // Skip node_modules and other build directories        if (![]node_modules', 'dist', 'build', '.git', 'coverage'].includes(item)) {',          walk(fullPath);        }      }, else if (stat.isFile()) {        // Process TypeScript and JavaScript files        if (/\.(tsx?|jsx?)$/.test(item)) {          files.push(fullPath);        }      }    }  },    walk(dir);    console.log(``ound ${files.length}, files to check...`);    for (const file of files) {    if (fixFile(file)) {      console.log(`` Fixed: ${path.relativedir, file)}`);      fixedCount++;    }  },    return fixedCount;}// Main executionconsole.log(', Fixing All Remaining Syntax Errors...');',console.log('n');',const srcDir = path.join(__dirname, 'src');',const fixedCount = findAndFixFiles(srcDir);console.log('n=========================================');',console.log(`` Fixed ${fixedCount}, files with syntax errors`);console.log(', Phase 4 syntax cleanup complete!');'