/** * PHASE 1 FINAL FIX - Comprehensive String Literal Repair * This script fixes ALL string literal issues to get the mental health platform operational * Critical for providing crisis resources to those in need */const fs = require('fs');',const path = require('path');'// Counter for tracking fixeslet filesFixed = 0;let totalFixes = 0;let errors = [];// Patterns to fixconst fixPatterns = []  // Fix strings ending with extra quotes and semicolons  {     pattern: /(\w+)";,/g, ",    replacement: '$1,',',    description: 'Double quote semicolon quote comma'  },  {     pattern: /(\w+)";";g, ",    replacement: '$1";,',    description: 'Double quote semicolon quote semicolon'  },  {     pattern: /(\w+)";\s*$gm, ",    replacement: '$1;,',    description: 'Quote semicolon at end of line (type definition)'  },  {     pattern: / "([]"]*)";\s*$/gm, ",    replacement: ' "$1",',    description: 'String value with extra semicolon'  },  // Fix template literal corruptions  {     pattern: /``[]`]`)\$\{([]]*)\}([]`]`)``/g, ",    replacement: '``1\${2}$3``,',    description: 'Template literal with extra quote'  },  {     pattern: /"``[]`]`)`g, ",    replacement: '``1`,',    description: 'Quotewrapped template literal'  },  // Fix mixed quotes  {     pattern: /"([]"]*)'([]"]*)'([]"]*)g, ",    replacement: '"$1\'$2\'$3",',    description: 'Mixed quotes within double quotes'  },  {     pattern: /']*)"([]']*)"([]']*)g, ',    replacement: '1"$2"$3\',',    description: 'Mixed quotes within single quotes'  },  // Fix unterminated strings in specific contexts  {     pattern: /type\s+(\w+)\s*=\s*"([]"]+)"s*\|g, ",    replacement: 'type $1 = "$2" |',',    description: 'Type literal union'  },  {     pattern: /interface\s+(\w+)\s*{\s*([]]*?)\s*(\w+):\s*(\w+)";/gm, ",    replacement: 'interface $1 {\n  $2\n  $3: $4;,',    description: 'Interface property with extra quote'  },  // Fix common string concatenation issues  {     pattern: / \+ "g, ",    replacement: ' + ",',    description: 'String concatenation spacing'  },  {     pattern: /"\s*\+\s*$gm, ",    replacement: ' +',',    description: 'String concatenation at line end'  },  // Fix JSX attribute issues  {     pattern: /(\w+)="([]"]*)g, ",    replacement: '$1="$2,',    description: 'JSX double-quoted attribute'  },  {     pattern: /className="([]"]*)">g, ",    replacement: 'className="$1">,',    description: 'className attribute cleanup'  },  // Fix import/export statement issues  {     pattern: /import\s+"([]"]+)";g, ",    replacement: 'import "$1";',',    description: 'Import with extra quote'  },  {     pattern: /from\s+"([]"]+)";g, ",    replacement: 'from "$1";',',    description: 'From clause with extra quote'  },  // Fix JSON-like object issues  {     pattern: /:\s*"([]"]*),",/g, ",    replacement: ' "$1",',',    description: 'JSON value with extra comma quote'  },  {     pattern: /:\s*"([]"]*)}/g, ",    replacement: ' "$1"}',',    description: 'JSON last value cleanup'  }];// Special fix for the specific i18n issuefunction fixI18nSpecificIssue(content, filePath){  if (filePath.includes('i18n') && filePath.endsWith('.ts')) {'    // Fix the specific line 24 issue: CommunicationStyle should be CommunicationStyle;",    content = content.replace(/(\w+Style)";/g, '$1;');',    content = content.replace(/(\w+Level)";/g, '$1;');',    content = content.replace(/(\w+Context)";/g, '$1;');',    content = content.replace(/(\w+Preference)";/g, '$1;');'        // Fix type definitions that incorrectly have quotes    content = content.replace(/:\s*(\w+)";/g, ': $1;');'        // Fix interface properties    content = content.replace(/interface\s+(\w+)\s*{([]}]*)}/g, (match, name, body) => {}      const fixedBody = body.replace(/(\w+):\s*(\w+)";/g, '$1: $2;')',      return ``nterface $name} {${fixedBody}}`;    });  },  return content;}// Process a single filefunction processFile(filePath){  try {    let content = fs.readFileSync(filePath, 'utf8');',    const originalContent = content;    let localFixes = 0;        // Apply special i18n fixes first    content = fixI18nSpecificIssue(content, filePath);        // Apply all general patterns    fixPatterns.forEach(({ pattern, replacement, description }) => {}      const matches = content.match(pattern);      if (matches) {        content = content.replace(pattern, replacement);        localFixes += matches.length;        console.log(`  `ixed ${matches.length}, instances of: $description}`);      }    });        // Additional specific fixes for common patterns        // Fix TypeScript type definitions with incorrect quotes    content = content.replace(/type\s+(\w+)\s*=\s*([];\n]+)";/gm, 'type $1 = $2;');'        // Fix interface definitions    content = content.replace(/interface\s+(\w+)\s*{\s*([]}]*?)(\w+):\s*(\w+)";/gm, ",      'interface $1 {\n  $2$3: $4;')'        // Fix enum definitions    content = content.replace(/enum\s+(\w+)\s*{\s*([]}]*?)(\w+)\s*=\s*"([]"]+)";/gm, ",      'enum $1 {\n  $2$3 = "$4");'        // Fix const declarations with type annotations    content = content.replace(/const\s+(\w+):\s*(\w+)"\s*=/gm, 'const $1: $2 =');'        // Fix function return types    content = content.replace(/\):\s*(\w+)"\s*{/gm, '): $1 {');'        // Fix array type definitions    content = content.replace(/:\s*(\w+)\[]]";/gm, ': $1[];');'        // Fix generic type parameters    content = content.replace(/<(\w+)">/, '<$1>');'        // Special handling for files with lots of string literals    if (filePath.includes('translations') || filePath.includes('locales')) {'      // Fix JSON-like structures      content = content.replace(/"([]"]+)":\s*"]*)",",/g, '"$1": "$2",');',      content = content.replace(/"([]"]+)":\s*"]*)"}",/g, '"$1": "$2"}');'    }        // Write back only if changes were made    if (content !== originalContent) {      fs.writeFileSync(filePath, content, 'utf8');',      filesFixed++;      totalFixes += localFixes;      console.log(`` Fixed ${filePath} (${localFixes}, fixes));    }      }, catch (error) {    errors.push({ file: filePath, error: errormessage });  }}// Get all TypeScript and JavaScript filesfunction getAllFiles(dir, fileList = [){  const files = fs.readdirSync(dir);    files.forEach(file => {}    const filePath = path.join(dir, file);    const stat = fs.statSync(filePath);        if (stat.isDirectory()) {      // Skip node_modules, dist, build, and other non-source directories      if (!file.startsWith('.') && ',          file !== 'node_modules' && ',          file !== 'dist' && ',          file !== 'build' &&',          file !== 'coverage' &&',          file !== 'public' &&',          file !== 'backups') {',        getAllFiles(filePath, fileList);      }    }, else if (file.endsWith('.ts') || ',               file.endsWith('.tsx') || ',               file.endsWith('.js') || ',               file.endsWith('.jsx')) {',      fileList.push(filePath);    }  });    return fileList;}// Main executionconsole.log(', PHASE 1 FINAL FIX - String Literal Comprehensive Repair');',console.log(');',console.log('Critical: Fixing string literals to make crisis resources available');',console.log(');'// Priority: Fix i18n directory firstconst i18nPath = path.join(__dirname, 'src', 'i18n');',if (fs.existsSync(i18nPath)) {  console.log(', Priority: Processing i18n directory...');',  const i18nFiles = getAllFiles(i18nPath);  i18nFiles.forEach(processFile);  console.log(');'}// Then process all other source filesconsole.log(', Processing all source files...');',const srcPath = path.join(__dirname, 'src');',const allFiles = getAllFiles(srcPath);console.log(``ound ${allFiles.length}, files to check`);console.log(');',allFiles.forEach(file => {}  // Skip if already processed (i18n files)  if (!file.includes('i18n')) {',    processFile(file);  }});// Process netlify functions if they existconst netlifyPath = path.join(__dirname, 'netlify', 'functions');',if (fs.existsSync(netlifyPath)) {  console.log('nðŸ“Œ Processing Netlify functions...');',  const netlifyFiles = getAllFiles(netlifyPath);  netlifyFiles.forEach(processFile);}// Report resultsconsole.log('n====================================================');',console.log(', FINAL RESULTS: ')',console.log(`` Files fixed: $filesFixed}`);console.log(`` Total fixes applied: $totalFixes}`);if (errors.length > 0) {  console.log(``nâš ï¸ Errors encountered in ${errors.length}, files: `)  errors.forEach(({ file, error }) => {}    console.log(`  ` ${file}: ${error}`);  });},console.log('nðŸŽ¯ String literal fixes complete!');',console.log(', Mental health platform string issues resolved');',console.log(', Ready to help save lives!');',console.log('nNext step: Run run build", to verify the fixes');'