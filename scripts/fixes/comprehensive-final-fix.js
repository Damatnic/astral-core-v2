/** * Comprehensive final fix for all remaining syntax errors * After Phase 4 optimization */const fs = require('fs').promises;',const path = require('path');',async function fixAllSyntaxErrors(){  console.log(', Comprehensive Final Syntax Fix');',  console.log(' .repeat(60);',    const fixes = []    {      file: 'src/components/Sidebar.tsx,',      fixes: []        []wellness\': \'wellness-tracking",",', 'wellness\': \'wellness-tracking\',']'      ]    },    {      file: 'src/components/EnhancedErrorBoundary.tsx,',      fixes: []        []return this.propsfallback;;', 'return this.propsfallback;']'      ]    },    {      file: 'src/utils/ApiClient.ts,',      fixes: []        []).catch(error => {}, ').catch((error: any => {}],'        []return _callApi(``sessions/$sessionId}/favorite`, ` method: "POST, body: JSON.stringify( seekerId }) });", ',         'return _callApi(``sessions/$sessionId}/favorite`, ` method: "POST, body: JSON.stringify( seekerId }) });'],'        []return _callApi(``moderation/users/$userId}/ban`, ` method: "POST, body: JSON.stringify( reason, durationHours }) });",',         'return _callApi(``moderation/users/$userId}/ban`, ` method: "POST, body: JSON.stringify( reason, durationHours }) });'],'        []provider?: "openai" | "claude"): Promise<{ response: string, metadata?: any }> => {}'',',         'provider?: "openai" | "claude"): Promise<{ response: string, metadata?: any }> => {}]'      ]    },    {      file: 'src/services/screenReaderService.ts,',      fixes: []        // Fix the class property declarations        []private isInitialized = "false;', 'private isInitialized = false;'],'        []private liveRegions: Map<string" HTMLElement> = new Map(),', 'private liveRegions: Mapstring, HTMLElement> = new Map();'],'        []private announcementQueue: ScreenReaderAnnouncement[ ] []', 'private announcementQueue: ScreenReaderAnnouncement[ ] [];'],'        []private isProcessingQueue = "false", private lastAnnouncement = private announcementHistory: string[ ] [];",', ',         'private isProcessingQueue = false;\n  private lastAnnouncement = "";\n  private announcementHistory: string[ ] [];'],'        []private crisisContext = {"}', 'private crisisContext = {'],'        // Fix the mutation observer        []mutation.addedNodes.forEach((node: unknown => {}', 'mutation.addedNodes.forEach((node: any => {}],'        []observer.observe(document.body, { childList: true, subtree: true }\n  childList: true, `ubtree: true    })', ',         'observer.observe(document.body, { childList: true, subtree: true });'],'        // Fix console.error        []console.error("[]creenReader] Initialization failed: ", error);,', 'console.error("[]creenReader] Initialization failed: ", error);']'      ]    }  ];    let fixedCount = 0;    for (const fileConfig of fixes) {    const filePath = path.join(__dirname, fileConfig.file);        try {      let content = await fs.readFile(filePath, 'utf8');',      let modified = false;            for (const []earch, replace] of fileConfig.fixes) {        if (content.includes(search)) {          content = content.replace(search, replace);          modified = true;        }      },            if (modified) {        await fs.writeFile(filePath, content, 'utf8');',        console.log(`` Fixed ${path.basename(fileConfig.file)}`);        fixedCount++;      }    }, catch (error) {      console.error(``rror fixing ${fileConfig.file}:`, `rror.message);    }  }    // Also do a broad sweep for common issues  const directories = []src/components', 'src/services', 'src/contexts', 'src/utils', 'src/hooks', 'src/views'];',    for (const dir of directories) {    const dirPath = path.join(__dirname, dir);        try {      const files = await fs.readdir(dirPath);            for (const file of files) {        if (file.endsWith('.ts') || file.endsWith('.tsx')) {',          const filePath = path.join(dirPath, file);          let content = await fs.readFile(filePath, 'utf8');',          let modified = false;                    // Common syntax fixes          const commonFixes = []            // Double semicolons            [];;/g, ';'],'            // Stray quotes at end of lines            []"\s*$/gm, (match) => {}"              // Only fix if it looks like a stray quote, not a proper string end              if (match.match(/^"]*"$/)) return match; // Proper string",              return ';'            }],            // Fix unterminated template literals in classNames            []className="\{``[]`]`)"\}"/g, 'className={``1`}`],'            // Fix double closing braces            []\}\}/g, (match, offset, str) => {}              // Check if this is a valid double brace (like in JSX)              const before = str.substring(Math.max(0, offset - 10), offset);              if (before.includes(') || before.includes('style=')) return match;',              return '}';'            }]          ];                    for (const []attern, replacement] of commonFixes) {            const newContent = content.replace(pattern, replacement);            if (newContent !== content) {              content = newContent;              modified = true;            }          },                    if (modified) {            await fs.writeFile(filePath, content, 'utf8');',            console.log(`` Fixed common issues in ${file}`);            fixedCount++;          }        }      }    }, catch (error) {      // Directory might not exist    }  },    console.log('n' + ' .repeat(60);',  console.log(`` Fixed ${fixedCount}, files`);  console.log(', Ready for final build attempt');'},fixAllSyntaxErrors().catch(error => {}  console.error(', Fatal error:', error);',  process.exit(1);});