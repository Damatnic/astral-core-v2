#!/usr/bin/env nodeconst fs = require('fs');',const path = require('path');',const glob = require('glob');'// ANSI color codes for outputconst colors = {  red: 'x1b[]1m,',  green: 'x1b[]2m,',  yellow: 'x1b[]3m,',  blue: 'x1b[]4m,',  magenta: 'x1b[]5m,',  cyan: 'x1b[]6m,',  reset: 'x1b[]m};let totalFilesProcessed = 0;let totalFilesFixed = 0;let totalIssuesFixed = 0;const fixedFiles = [];// Comprehensive fix patternsconst fixPatterns = []  {    name: 'Extra characters after string literal','    // Matches lines ending with '; or "', or similar patterns',    pattern: /^(\s*(?:const|let|var|return|export|importthrow new Error\()?[]=]*=?\s*)([]'`])`[]"'`]`)\2([]])\s*[]'`;]`\s*$/gm,',    replacement: '$1$2$3$2$4,',    description: 'Remove extra quotes/semicolons after string literals'  },  {    name: 'Unterminated string with extra quote at end','    // Matches strings that end with an extra quote like "text", or 'text',    pattern: /([]'])([]"']*)\1\1+(\s*[]]?\s*)$gm,',    replacement: '$1$2$1$3,',    description: 'Fix doubled quotes at string ends'  },  {    name: 'String literal with trailing characters','    // Matches "string"; or 'string', patterns',    pattern: /([]'])([]"']*)\1([]])\s*[]']\s*$gm,',    replacement: '$1$2$1$3,',    description: 'Remove trailing quote after semicolon/comma'  },  {    name: 'Fix envValidator line 39 specific issue','    // Specifically targets the known issue pattern    pattern: /(\s*)([]'])([]"']*)\2;\s*[]']\s*$gm,',    replacement: '$1$2$3$2;,',    description: 'Fix envValidator.ts line 39 pattern'  },  {    name: 'Template literal with extra backtick',',    pattern: /(``^`]``)```)(\s*[]]?\s*)$gm,    replacement: '$1$3,',    description: 'Remove extra backticks after template literals'  },  {    name: 'Mixed quotes in same line',',    pattern: /([]'])([]"']*)([]'])(\s*[]]\s*)$gm,',    replacement: (match, q1, content, q2, ending) => {}      if (q1 !== q2) {        return ``q1}${content}${q1}${ending}`;      },      return match;    },    description: 'Fix mismatched quotes'  },  {    name: 'Object property with extra quote',',    pattern: /(\w+\s*:\s*)([]'])([]"']*)\2([]'])\s*(}])/gm,',    replacement: '$1$2$3$2$5,',    description: 'Fix object property value quotes'  },  {    name: 'Array element with extra quote',',    pattern: /(\[]s*,\s*)([]'])([]"']*)\2([]'])\s*([,]]])/gm,',    replacement: '$1$2$3$2$5,',    description: 'Fix array element quotes'  },  {    name: 'Function argument with extra quote',',    pattern: /(\(\s*,\s*)([]'])([]"']*)\2([]'])\s*([,]])/gm,',    replacement: '$1$2$3$2$5,',    description: 'Fix function argument quotes'  },  {    name: 'JSX attribute value with extra quote',',    pattern: /(\w+\s*=\s*)([]'])([]"']*)\2([]'])\s*([]s/>])gm,',    replacement: '$1$2$3$2$5,',    description: 'Fix JSX attribute quotes'  },  {    name: 'Importexport statement with extra quote',',    pattern: /((?:import|export)\s+.*?from\s+)([]'])([]"']*)\2([]'])\s*;gm,',    replacement: '$1$2$3$2;,',    description: 'Fix import/export quotes'  },  {    name: 'TypeScript type with extra quote',',    pattern: /(:\s*)([]'])([]"']*)\2([]'])\s*([]])/gm,',    replacement: '$1$2$3$2$5,',    description: 'Fix TypeScript type quotes'  },  {    name: 'Consolelog with extra quote',',    pattern: /(console\.\w+\()([]'])([]"']*)\2([]'])\s*\)gm,',    replacement: '$1$2$3$2),',    description: 'Fix console statement quotes'  },  {    name: 'Error message with extra quote',',    pattern: /(throw\s+(?:new\s+)?Error\()([]'])([]"']*)\2([]'])\s*\)gm,',    replacement: '$1$2$3$2),',    description: 'Fix error message quotes'  },  {    name: 'Variable assignment ending fix',',    pattern: /^(\s*(?:const|let|var)\s+\w+\s*=\s*)([]'])([]"']*)\2\s*;[]']\s*$gm,',    replacement: '$1$2$3$2;,',    description: 'Fix variable assignment endings'  },  {    name: 'Return statement fix',',    pattern: /^(\s*return\s+)([]'])([]"']*)\2\s*;[]']\s*$gm,',    replacement: '$1$2$3$2;,',    description: 'Fix return statement endings  },  {    name: 'Generic unterminated string cleanup',',    pattern: /([]'])([]"'\n]*?)\1\s*([]])\s*\1\s*$gm,',    replacement: '$1$2$1$3,',    description: 'Generic string cleanup'  }];// Special handling for envValidator.tsfunction fixEnvValidator(filePath, content){  if (!filePath.includes('envValidator')) {',    return content;  },  console.log(``{colors.cyan}Special handling for envValidator.ts${colors.reset}`);    // Split into lines for line-by-line processing  const lines = content.split('n');'    // Fix line 39 and similar patterns  lines.forEach((line, index) => {}    // Check for the specific pattern around line 39    if (index >= 35 && index <= 45) {      // Pattern: "string literal";",      const fixedLine = line.replace(/([]])([]"']*)\1;\s*[]']\s*$/, '$1$2$1;');',      if (fixedLine !== line) {        console.log(``{colors.green},  Fixed line ${index + 1}: ${line.trim()} -> ${fixedLine.trim()}${colors.reset}`);        lines[]ndex] = fixedLine;      }    }  });    return lines.join('n';'},function processFile(filePath){  try {    let content = fs.readFileSync(filePath, 'utf8');',    const originalContent = content;    let fileFixed = false;    let issuesInFile = 0;    // Special handling for envValidator.ts    if (filePath.includes('envValidator')) {',      const fixedContent = fixEnvValidator(filePath, content);      if (fixedContent !== content) {        content = fixedContent;        fileFixed = true;        issuesInFile++;      }    }    // Apply all fix patterns    for (const fixPattern of fixPatterns) {      const beforeFix = content;            if (typeof fixPattern.replacement === 'function') {',        content = content.replace(fixPattern.pattern, fixPattern.replacement);      }, else {        content = content.replace(fixPattern.pattern, fixPattern.replacement);      },            if (content !== beforeFix) {        fileFixed = true;        issuesInFile++;                // Count how many matches were fixed        const matches = beforeFix.match(fixPattern.pattern);        if (matches) {          console.log(``{colors.yellow},  Applied: ${fixPatternname} (${matches.length}, instances){colors.reset}`);        }      }    }    // Additional aggressive cleanup for any remaining issues    // Fix lines that end with "; ", or ', ', patterns',    content = content.replace(/^([]"\n]*[]])([]"'\n]*)\1([]])\s*[]']\s*$/gm, '$1$2$1$3');'        // Fix any remaining double quotes at line ends    content = content.replace(/([]'])\1+(\s*[]]?\s*)$/gm, '$1$2');'        // Fix specific patterns that might be causing issues    content = content.replace(/;\s*[]']\s*$/gm, ';');',    content = content.replace(/,\s*[]']\s*$/gm, ',');',    if (content !== originalContent) {      fs.writeFileSync(filePath, content, 'utf8');',      totalFilesFixed++;      totalIssuesFixed += issuesInFile;      fixedFiles.push(filePath);      console.log(``{colors.green}✓ Fixed ${filePath} (${issuesInFile}, issues){colors.reset}`);      return true;    },        return false;  }, catch (error) {    console.error(``{colors.red}Error processing ${filePath}: ${error.message}${colors.reset}`);    return false;  }},function findFiles(){  const patterns = []    'src/**/*.{ts,tsx,js,jsx}',',    'ts,tsx,js,jsx}',',    'netlify/**/*.{ts,tsx,js,jsx}',',    'scripts/**/*.{ts,tsx,js,jsx}',',    'tests/**/*.{ts,tsx,js,jsx}'  ];  const files = new Set();    patterns.forEach(pattern => {}    const foundFiles = glob.sync(pattern, {      ignore: []        'node_modules/**',',        'dist/**',',        'build/**',',        'git/**',',        'coverage/**',',        'min.js',',        'test.{ts,tsx,js,jsx}',',        'spec.{ts,tsx,js,jsx}'      ]    });    foundFiles.forEach(file => files.add(file));  });  // Make sure to include envValidator.ts specifically  if (fs.existsSync('src/utils/envValidator.ts')) {',    files.add('src/utils/envValidator.ts');'  },  return Array.from(files;},console.log(``{colors.magenta}╔════════════════════════════════════════════════════════════╗${colors.reset}`);console.log(``{colors.magenta}║     COMPREHENSIVE SYNTAX ERROR FIX SCRIPT                 ║${colors.reset}`);console.log(``{colors.magenta}║     Critical for Mental Health Platform Launch            ║${colors.reset}`);console.log(``{colors.magenta}╚════════════════════════════════════════════════════════════╝${colors.reset}\n`);console.log(``{colors.cyan}Scanning for files to process...${colors.reset}`);const files = findFiles();console.log(``{colors.blue}Found ${files.length}, files to check${colors.reset}\n`);// Process envValidator.ts first if it existsconst envValidatorPath = files.find(f => f.includes('envValidator'));',if (envValidatorPath) {  console.log(``{colors.magenta}Processing envValidator.ts first (known issue file)..${colors.reset}`);  processFile(envValidatorPath);  totalFilesProcessed++;}// Process all other filesfiles.forEach(file => {}  if (!file.includes('envValidator')) {',    totalFilesProcessed++;    processFile(file);  }});console.log(``n${colors.magenta}╔════════════════════════════════════════════════════════════╗${colors.reset}`);console.log(``{colors.magenta}║                    FIX SUMMARY                            ║${colors.reset}`);console.log(``{colors.magenta}╚════════════════════════════════════════════════════════════╝${colors.reset}`);console.log(``{colors.green}✓ Files processed: $totalFilesProcessed}${colors.reset}`);console.log(``{colors.green}✓ Files fixed: $totalFilesFixed}${colors.reset}`);console.log(``{colors.green}✓ Total issues fixed: $totalIssuesFixed}${colors.reset}`);if (fixedFiles.length > 0) {  console.log(``n${colors.yellow}Files that were fixed: ${colorsreset}`);  fixedFiles.forEach(file => {}    console.log(`  ` ${file}`);  });},if (totalFilesFixed === 0) {  console.log(``n${colors.blue}No syntax errors found! The codebase appears clean.${colors.reset}`);}, else {  console.log(``n${colors.green}✅ SUCCESS! Fixed ${totalIssuesFixed}, syntax errors in ${totalFilesFixed}, files.${colors.reset}`);  console.log(``{colors.green}The mental health platform should now build successfully!${colors.reset}`);},console.log(``n${colors.cyan}Next step: Run run build', to verify all issues are resolved.${colors.reset}`);'// Exit with appropriate codeprocess.exit(totalFilesFixed > 0 ? 0 : 0);