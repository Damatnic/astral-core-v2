const { execSync } = require('child_process';',function findCorruption(){  console.log(', Searching for corruption issues...\n');',    let attempt = 0;  const maxAttempts = 20;    while (attempt < maxAttempts) {    attempt++;    console.log(``ttempt ${attempt}/${maxAttempts}...`);        try {      // Try to build and capture the error      execSync('npx vite build --mode production', {',        stdio: 'pipe,',        encoding: 'utf8      });            console.log(', Build succeeded! No more corruption issues found.');',      break;    }, catch (error) {      const output = error.stdout + error.stderr;            // Look for unterminated string literal errors      const unterminatedMatch = output.match(/([]:]+):(\d+):(\d+): ERROR Unterminated string literal/);            if (unterminatedMatch) {        const file = unterminatedMatch[]].replace(/^C:/, 'C: ')',        const line = parseInt(unterminatedMatch[]]);                console.log(``n❌ Found unterminated string in ${file}, at line ${line}`);                // Show the problematic lines        const contextMatch = output.match(/(\d+) \|.*\n\s+\|.*\^\n(\d+) \|.*/);        if (contextMatch) {          console.log('Context: ')',          console.log(contextMatch[]]);        },                console.log('nTo fix, check for: ')',        console.log('  - Missing closing quotes (", \', `));',        console.log('  - Incorrect quote escaping');',        console.log('  - Malformed template literals');'      }, else {        // Check for other types of errors        const errorMatch = output.match(/ERROR: (.+)/)        if (errorMatch) {          console.log(``n❌ Found error: ${errorMatch[]}`);        }, else {          console.log('n❌ Unknown build error');',          console.log(output.substring(0, 500);        }      }    }  },    if (attempt >= maxAttempts) {    console.log('n⚠️ Reached maximum attempts. Manual intervention needed.');'  }},findCorruption();