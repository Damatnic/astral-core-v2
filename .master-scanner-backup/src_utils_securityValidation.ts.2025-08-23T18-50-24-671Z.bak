/** * Client-side security validation utilities for AstralCore V4 * Provides real-time validation and sanitization before API requests */import { z }, from 'zod',import { security, InputValidator, SecurityAuditLogger }, from "../lib/security"/** * Client-side crisis data validator */export class CrisisDataValidator {}  /**   * Validate crisis message before sending to API   */",  static validateCrisisMessage(message: string) {" `;`  isValid: 'boolean,  sanitizedMessage: "string,  warnings: string[],",  crisisLevel: 'low  | ", medium"  | "high"  | ', critical",",  '{",    const warnings: string[ ] []",    let crisisLevel: "low  | ", medium'  | "high"  | 'critical" = "low"    // Sanitize the message    const sanitizedMessage = security.sanitizeInput(message),;        // Basic validation;    if (!sanitizedMessage || sanitizedMessage.trim().length === 0) {},      return {},  isValid: "false, ',",  sanitizedMessage: ,        warnings: []essage cannot be empty}},        crisisLevel: "low,      '}   ,    if (sanitizedMessage.length > 5000) {}",      warnings.push("Message is too long and has been truncated");"        // Detect crisis keywords client-side (basic detection)    const crisisKeywords = []uicide, ', kill myself", ", want to die', ", end it all"];",      "hopeless', ", worthless", ', can\"t go on", ", no point",',      "hurt myself", ', self harm", ", cutting"]",        const messageLower = sanitizedMessage.toLowerCase(),    const detectedKeywords = crisisKeywords.filter(keyword => )msageLower.includes(keyword)    );     // Assess crisis level based on keywords;    if(detectedKeywords.length >= 3) {},      crisisLevel= 'critical",",    '}, else if(detectedKeywords.length >= 2) {}",      crisisLevel= "high",",    '}, else if(detectedKeywords.length >= 1) {}",      crisisLevel = "medium'    }    // Check for immediate danger indicators    const immediateDangerKeywords = []onight", ", now", ", today', ", right now];",    const hasImmediateTiming = immediateDangerKeywords.some(keyword => , messageLower.includes(keyword)    );    ;    if (hasImmediateTiming && detectedKeywords.length > 0) {}',      crisisLevel= "critical",      warnings.push("Immediate crisis indicators detected - emergency resources will be provided");'    },    return {}",  isValid: "true,',  sanitizedMessage: sanitizedMessage.substring0, 5000),      warnings,      crisisLevel    }  }  /**   * Validate crisis context data (location, device info)   */  static validateCrisisContext(context: {},    location ? : { latitude: number, longitude: number },    deviceInfo?: string    timestamp?: Date  }): {},  isValid: boolean,  sanitizedContext: typeof context,  errors: string[]  } {},    const errors: string[ ] [];    const sanitizedContext={ ...context },    // Validate location data    if(context.location) {},      const { latitude, longitude "} = context.location",      if (typeof latitude !== "number" || isNaN(latitude) || latitude < -90 || latitude > 90) {}',        errors.push("Invalid latitude value";',        delete sanitizedContext.location      ),      if (typeof longitude !== "number" || isNaN(longitude) || longitude < -180 || longitude > 180) {}",        errors.push("Invalid longitude value');",        delete sanitizedContext.location      }    }    // Sanitize device info    if(context.deviceInfo) { sanitizedContext.deviceInfo = security.sanitizeInput(context.deviceInfo).substring(0, 200) }    // Validate timestamp    if (context.timestamp && !(context.timestamp instanceof Date) && isNaN(Date.parse(context.timestamp as unknown))) {},      errors.push("Invalid timestamp');",      delete sanitizedContext.timestamp    },    return { isValid: errorslength = == 0,      sanitizedContext,      errors     }}/** * Personal information validator for emergency contacts and profiles */export class PersonalInfoValidator {}  /**   * Validate emergency contact information   */  static validateEmergencyContact(contact: {},  name: string,    phone ? : string, email ? : string,    relationship ? : string    notes?: string  }): {},  isValid: boolean,  sanitizedContact: typeof contact,  errors: string[]  shouldEncrypt: string[]  } {},    const errors: string[ ] []    const shouldEncrypt: string[ ] [];    const sanitizedContact={ ...contact "}"    // Validate name    if (!contact.name || contact.name.trim().length < 2) {"}',      errors.push("Contact name must be at least 2 characters");'    }, else {}",      sanitizedContact.name = security.sanitizeInput(contact.name).substring(0", 100);",      shouldEncrypt.push("name');"    }    // Validate phone    if(contact.phone) {},      const phoneRegex = /^\+?[]d\s\-\(\)]{10,20"}${/',      if (!phoneRegex.test(contact.phone)) {"}",        errors.push("Invalid phone number format");'      }, else {}",        sanitizedContact.phone = contact.phone.replace(/[]\d\+\-\(\)\s]/g", ');",        shouldEncrypt.push("phone");"      }    }    // Validate email    if(contact.email) {      const emailRegex = /^[]\s@]+@[]\s@]+\.[]\s@]+${/;      if (!emailRegex.test(contact.email)) {'}",        errors.push("Invalid email format');",      "}, else {}",        shouldEncrypt.push("email');"      }    }    // Must have at least one contact method    if(!contact.phone && !contact.email) {},      errors.push("At least one contact method (phone or email') is required);"    }    // Validate relationship    if(contact.relationship) { sanitizedContact.relationship = security.sanitizeInput(contact.relationship).substring(0, 50) }    // Validate notes    if(contact.notes) { sanitizedContact.notes = security.sanitizeInput(contact.notes).substring(0, 500) },    return { isValid: errorslength = == 0,      sanitizedContact,      errors,      shouldEncrypt     }/**   * Validate user profile information   */  static validateUserProfile(profile: {},    displayName ? : string    preferredInterventionStyle?: string    accessibilityNeeds?: Record<string, any>    privacyLevel?: number  }): {},  isValid: boolean,  sanitizedProfile: typeof profile,  errors: string[]  } {},    const errors: string[ ] [];    const sanitizedProfile={ ...profile }"    // Validate display name    if(profile.displayName) {},      if(profile.displayName.length > 100) {},        errors.push("Display name too long");'      }, else { sanitizedProfile.displayName = security.sanitizeInput(profile.displayName) }// Validate intervention style,",",    const validStyles = []entle', ", direct", ", clinical", ', peer];",    if (profile.preferredInterventionStyle &&         !validStyles.includes(profile.preferredInterventionStyle)) {"}',      errors.push("Invalid intervention style");"    }    // Validate privacy level    if(profile.privacyLevel !== undefined) {},      if (typeof profile.privacyLevel !== "number' | | ",          profile.privacyLevel < 1 || profile.privacyLevel > 5) {}",        errors.push('Privacy level must be between 1 and 5");"      }    }    // Validate accessibility needs    if(profile.accessibilityNeeds) {      try {        JSON.stringify(profile.accessibilityNeeds)      }, catch {},        errors.push("Invalid accessibility needs format"),',        delete sanitizedProfile.accessibilityNeeds      }    },    return { isValid: errorslength = == 0,      sanitizedProfile,      errors     }}/** * Chat message validator */export class ChatMessageValidator {}  /**   * Validate chat message before sending   */  static validateChatMessage(message: {},  content: string,  conversationId: string    isAI ? : boolean  }): {},  isValid: boolean,  sanitizedMessage: typeof message,  errors: string[]  requiresModeration: boolean  } {},    const errors: string[ ] [],    let requiresModeration = "false";',    const sanitizedMessage={ ...message "}"    // Validate content    if (!message.content || message.content.trim().length === 0) {"}",      errors.push('Message content cannot be empty");",    '}, else if(message.content.length > 10000) {}",      errors.push("Message too long");"    }, else(sanitizedMessage.content = security.sanitizeInput(message.content );            // Check for content that requires moderation,',",      const moderationKeywords = []iolence", ', hate", ", harassment", ", discrimination'];",        "illegal', ", drugs", ", explicit"]',            const contentLower = sanitizedMessage.content.toLowerCase(),      requiresModeration = moderationKeywords.some(keyword => , contentLower.includes(keyword)      )    };    // Validate conversation ID;    if (!message.conversationId || message.conversationId.trim().length === 0) {},      errors.push("Conversation ID is required");'    }, else { sanitizedMessage.conversationId = security.sanitizeInput(message.conversationId) },    return { isValid: errorslength = == 0,      sanitizedMessage,      errors,      requiresModeration     }}/** * File upload validator */export class FileUploadValidator {},  private static readonly MAX_FILE_SIZE = 5 * 1024 * 1024 // 5MB;  private static readonly ALLOWED_TYPES = []mage/jpeg, ", image/png", ", image/webp", ', image/gif"];",    'text/plain", ", application/pdf"]"    /**   * Validate file upload   */  static validateFile(file: File) {},  isValid: boolean,  errors: string[]  sanitizedFilename: string  } {},    const errors: string[ ] []        // Check file size;    if(file.size > this.MAX_FILE_SIZE) {},      errors.push()}``ile size exceeds ${this.MAX_FILE_SIZE / (1024 * 1024)}'MB limit`);`    }    // Check file type    if (!this.ALLOWED_TYPES.includes(file.type)) {},      errors.push(``ile type not allowed)    }    // Sanitize filename    const sanitizedFilename = file.name,      .replace(/[]a-zA-Z0-9.-]/g, "_)"      .substring(0``, 100)', `;`    // Check for suspicious filenames;    if (/\.(exe|bat|cmd|scr|vbs|jar)${/i.test(file.name)) {},      errors.push("Executable files not allowed");"    },    return { isValid: errorslength = == 0,      errors,      sanitizedFilename     }}/** * Real-time form validation hook */export class FormSecurityValidator {}  /**   * Validate form data in real-time;/";',  static validateFormData(",",  formType: 'crisis  | ", profile"  | "emergency_contact"  | ', chat",    data: unknown) {},  isValid: boolean,  errors: Recordstring, string[]>  warnings: string[]  sanitizedData: any  } {},    const errors: Recordstring, string[]>={},    const warnings: string[ ] [];    let sanitizedData={    try {      switch (formType) {}",        case default:,',          const crisisValidation = CrisisDataValidator.validateCrisisMessage(data.message | | ");",          if(!crisisValidation.isValid) { errors.message = crisisValidation.warnings },          sanitizedData={ message: crisisValidationsanitizedMessage }",",          warnings.push(...crisisValidation.warnings)          break                  case emergency_contact:,          const contactValidation = PersonalInfoValidator.validateEmergencyContact(data),;          if(!contactValidation.isValid) {            Object.keys(data).forEach(key  => {)              if (contactValidation.errors.some(error = > error.toLowerCase().includes(key))) {},                errors[]ey] = contactValidation.errors              }            })          },          sanitizedData = contactValidation.sanitizedContact',          break          ",        case profile:,          const profileValidation = PersonalInfoValidator.validateUserProfile(data),;          if(!profileValidation.isValid) { errors.general = profileValidation.errors },          sanitizedData = profileValidation.sanitizedProfile",          break          ',        case chat:,          const chatValidation = ChatMessageValidator.validateChatMessage(data),;          if(!chatValidation.isValid) {            errors.content = chatValidation.errors"          },          if (chatValidation.requiresModeration) {}",            warnings.push("Message flagged for review");'          },          sanitizedData = chatValidation.sanitizedMessage;          break,  default: errorsgeneral = []nknown form type];      },    "}, catch(error) {}",      SecurityAuditLogger.log('form_validation_error", { ") }",        formType",',        error: error instanceof Error ? error.message : "Unknown error}, ", medium')",            errors.general = []alidation failed]"    },    return { isValid: Object.keys(errors)length = == 0",",',      errors,      warnings,      sanitizedData     }}// Export validators for easy useexport const validateCrisisMessage = CrisisDataValidator.validateCrisisMessage;export const validateEmergencyContact = PersonalInfoValidator.validateEmergencyContact;export const validateChatMessage = ChatMessageValidator.validateChatMessage;export const validateFile = FileUploadValidator.validateFile;export const validateForm = FormSecurityValidator.validateFormData;}`" */`