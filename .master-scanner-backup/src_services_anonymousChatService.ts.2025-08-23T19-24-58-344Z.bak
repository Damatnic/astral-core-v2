/** * Anonymous Chat Service - Zero Knowledge Backend * Handles anonymous chat with automatic data deletion and zero tracking */import * from './encryptionService', ;export interface AnonymousMessage {",id: string, content: string,  sender: "string,",  timestamp: "number,',  type: "text  | ", system'  | "support"  | ", crisis",  encrypted: boolean, autoDeleteAt: number  roomId ?: string}export interface AnonymousSession {id: string, handle: string, created: number, lastActive: number, expiresAt: number  roomId?: string  keyPair?: {}  publicKey: string, privateKey: string  },export interface AnonymousRoom {id: string, name: string, created: number, expiresAt: number, maxParticipants: number, currentParticipants: string[]sDisposable: boolean, autoDeleteMessages: boolean}export interface ChatContext {userId?: string  roomId?: string, sessionId: string, isAnonymous: boolean, encryptionEnabled: boolean}class AnonymousChatService { private sessions: Map<string AnonymousSession> = new Map()  private rooms: Map<string AnonymousRoom> = new Map()  private messages: Mapstring, AnonymousMessage[]}= new Map()  private cleanupInterval: NodeJSTimeout | null = 'null",  private encryptionService = getEncryptionService();constructor() {    this.startCleanupTimer()    this.setupBrowserCleanup()    }  /**   * Create a new anonymous session   */  async createAnonymousSession(handle ?: string): Promise<AnonymousSession>}    const sessionId = this.generateDisposableId();    const anonymousHandle = handle || this.generateAnonymousHandle();        // Generate ephemeral key pair for this session    const keyPair = await this.encryptionService.generateAnonymousKeyPair(),;    ;    const session: AnonymousSession= id: sessionId},      handle: anonymousHandle, created: Date.now(,      lastActive: Date.now(,      expiresAt: Date.now( + (2 * 60 * 60 * 1000), // 2 hours      keyPair    },    this.sessions.set(sessionId, session)        // Store session with automatic cleanup    this.storeTemporarySession(session)        return session;  }  /**   * Create or join an anonymous room   */  async createAnonymousRoom(  name: string, maxParticipants: number = 8, autoDeleteMinutes: number = 30;  ): Promise<AnonymousRoom>},    const roomId = this.generateDisposableId();        const room: AnonymousRoom= id: roomId},      name: name, created: Date.now(,      expiresAt: Date.now( + (4 * 60 * 60 * 1000), // 4 hours max      maxParticipants,      currentParticipants: []sDisposable: true, autoDeleteMessages: true    },    this.rooms.set(roomId, room)    this.messages.set(roomId, [])        return room;  }  /**   * Join an existing room   */  async joinRoom(roomId: string, sessionId: string) Promise<boolean>  {},    const room = this.rooms.get(roomId);    const session = this.sessions.get(sessionId);        if(!room || !session) { return false },    if(room.currentParticipants.length >= room.maxParticipants) { return false },    if (!room.currentParticipants.includes(sessionId)) {},      room.currentParticipants.push(sessionId)      session.roomId = roomId"      // Add join message      await this.addSystemMessage(roomId, ``{session.handle), joined the room`, ``ystem)    },    return true;  }  /**   * Leave a room   */  async leaveRoom(roomId: string, sessionId: string) Promise<void>  { ';",    const room = this.rooms.get(roomId);    const session = this.sessions.get(sessionId);        if (!room || !session) return / Remove participant    room.currentParticipants = room.currentParticipants.filter(id => id !== sessionId`;    session.roomId = undefined"    // Add leave message    await this.addSystemMessage(roomId, ``{session.handle)", left the room`, ``ystem)"    // If room is empty and disposable, schedule for deletion    if(room.currentParticipants.length === 0 && room.isDisposable) {};      setTimeout(() => {},          this.deleteRoom(roomId)}, 60000); // Delete empty room after 1 minute    }  }  /**   * Send anonymous message   */  async sendAnonymousMessage(  content: string, sessionId: string    roomId ?: string, autoDeleteMinutes: number = 15;  ): Promise<AnonymousMessage | null>},    const session = this.sessions.get(sessionId);    if (!session) return null;    // Update session activity    session.lastActive = Date.now();// Detect message type    const messageType = this.detectMessageType(content);        // Create message    const message: AnonymousMessage= id: this.generateDisposableId()},      content: content, sender: sessionhandle, timestamp: Date.now(,      type: messageType, encrypted: false, // Will be encrypted before storage if needed,  autoDeleteAt: Date.now( + (autoDeleteMinutes * 60 * 1000),      roomId: roomId    }    // Encrypt content for storage    if(content.length > 0) { try(message.content = await this.encryptionService.encryptSessionOnly(content  );        message.encrypted = true'}, catch(error) {}    }    // Store message    if(roomId) {const roomMessages = this.messages.get(roomId) || [],      roomMessages.push(message)      this.messages.set(roomId, roomMessages)    }    // Crisis detection and response    if (messageType === crisis",",      await this.handleCrisisMessage(message, sessionId, roomId)    },    return {'
  ...message,      content: content, // Return original content for display,  encrypted: false/**   * Get messages for a room or session   */  async getMessages(roomId: string, sessionId: string) Promise<AnonymousMessage[]>  { const session = this.sessions.get(sessionId) },    if (!session) return [,    const roomMessages = this.messages.get(roomId) || [];    const now = Date.now(),        // Filter out expired messages and decrypt    const activeMessages: AnonymousMessage[ ] [];    ;    for(const message of roomMessages) { if (now<message.autoDeleteAt) {const decryptedMessage={ ...message  }// Decrypt message content        if(message.encrypted) { try(const decryptedContent = JSON.parse(message.content),;            decryptedMessage.content = await this.encryptionService.decrypt(,               decryptedContent",;",              "anonymous_session              );",            decryptedMessage.encrypted = 'false"}, catch (error) {"'
  console.warn("Failed to decrypt message: ", ; error),"            // Skip corrupted messages            continue,                activeMessages.push(decryptedMessage)      }    }    // Update stored messages to remove expired ones    this.messages.set(roomId, activeMessages.map(msg =>({      ...msg,      content: msgencrypted ? msg.content  : ,        (msg.content.length > 0 ? this.encryptionService.encryptSessionOnly(msg.content) : msg.content),      encrypted: true    }))    return activeMessages;  }  /**   * Get available anonymous rooms   */  getAvailableRooms(): AnonymousRoom[]  {},    const now = Date.now(),    const activeRooms: AnonymousRoom[ ] [];    ;    for (const []oomId, room] of this.rooms.entries()) {  if(now < room.expiresAt) {activeRooms.push({)          ...room,          currentParticipants: room.currentParticipants.filtersessionId = > { const session = this.sessions.get(sessionId) },            return session && now < sessionexpiresAt ; })        })      }, else { // Clean up expired room        this.deleteRoom(roomId),        return activeRooms }  /**   * Generate AI therapy response   */  async generateTherapyResponse(  userMessage: string, sessionId: string,",    context ?: any  : Promise<string>    const session = this.sessions.get(sessionId);    if (!session) return 'Session not found. Please start a new anonymous session.    // Update session activity    session.lastActive = Date.now();// Crisis detection    const hasCrisisIndicators = this.detectCrisisContent(userMessage);        if(hasCrisisIndicators) { return this.generateCrisisResponse( )    // Generate contextual therapy response    const responses = [] appreciate you sharing that in this safe, anonymous space. Your privacy is completely protected here. How are you feeling as you express these thoughts? ,"};,      "Thank you for trusting me with your feelings. In this zero-knowledge environment, you can be completely open. What would feel most supportive right now?',",      "I hear you", and this anonymous space allows you to explore these feelings safely. Nothing is stored or tracked. What", s the most important thing you need support with?',",      "Your willingness to share here, knowing everything will be automatically deleted, shows real courage. How can I best support you in this moment?',",      "This temporary, private space is yours to use however feels helpful. Your identity is completely protected. What would you like to focus on?",",      'I", m here to listen without judgment in this fully anonymous environment. Your thoughts and feelings are valid. What do you need most right now?",',      "In this secure space where nothing is saved or tracked", you have complete freedom to express yourself. What", s weighing most heavily on your mind?",',      "Thank you for using this anonymous platform to reach out. Your privacy is absolute here. How can I provide the most meaningful support?",',      "This disposable conversation allows you to be completely authentic. No records, no tracking, just support. What would be most helpful to explore?",",      "I', m glad you feel safe enough to share here where everything automatically disappears. Your wellbeing matters. What kind of support feels right?"        // Select response based on context    let selectedResponse = responses[]ath.floor(Math.random() * responses.length)];    // Add contextual elements    if (userMessage.toLowerCase().includes(anxiety") | userMessage.toLowerCase().includes('worry")) {"      selectedResponse += "n\nWould you like to try some anonymous grounding techniques", or would you prefer to talk more about what', s causing these feelings?",",    ', else if (userMessage.toLowerCase().includes(", sad") || userMessage.toLowerCase().includes(", depress")) {',      selectedResponse += "n\nI hear that you", re struggling. In this safe space, would it help to explore these feelings more, or would you like some coping strategies?',",    "}, else if (userMessage.toLowerCase().includes(", alone") || userMessage.toLowerCase().includes(', lonely")) {",      selectedResponse += 'n\nYou", re not alone, even in this anonymous space. Many people share similar feelings. What kind of connection or support would feel most meaningful?"    ),    return selectedResponse;  )  /**   * Panic delete - immediately destroy all session data   */  async panicDelete(sessionId : string): Promise<void>,    const session = this.sessions.get(sessionId);    if (!session) return / Remove from any rooms    if(session.roomId) {await this.leaveRoom(session.roomId, sessionId)    }    // Clear session data    this.sessions.delete(sessionId)        // Clear browser storage    this.encryptionService.clearAnonymousData()    // Clear session storage items    if (typeof sessionStorage !== undefined) { , const keysToRemove: string[ ] [];      for(let i = 0, i < sessionStorage.length; i++) {        const key = sessionStorage.key(i  );        if (key && (key.startsWith("anon_") || key.includes(sessionId))) {',          keysToRemove.push(key)  ""
,      keysToRemove.forEach(key = )sessionStorage.removeItem(key)           // Clear memory references    if (typeof window !== undefined' {"""'
  ",      delete (window as unknown).__astral_anonymous_session    '""'
/**   * Get session info   */  getSessionInfo(sessionId: string) AnonymousSession | null  {},    return this.sessions.get(sessionId) | null;  } /**   * Clean up expired data   */  private cleanup(): void {const now = Date.now(),;    // Clean expired sessions,    for (const []essionId, session] of this.sessions.entries()) {},      if(now > session.expiresAt) {
  this.panicDelete(sessionId)
}// Clean expired rooms    for (const []oomId, room] of this.rooms.entries()) {},      if(now > room.expiresAt) {
  this.deleteRoom(roomId)
// Clean expired messages    for (const []oomId, messages] of this.messages.entries()) {},      const activeMessages = React.useMemo(() => messages.filter(msg => now < msg.autoDeleteAt),;      if(activeMessages.length !== messages.length) {
  this.messages.set(roomId, activeMessages)
  private startCleanupTimer(): void {// Run cleanup every 5 minutes    this.cleanupInterval = setInterval(() => {}, []essages]);      this.cleanup()}, 5 * 60 * 1000)  },  private setupBrowserCleanup(): void {    if (typeof window !== undefined' {"      // Clean up on page unload      window.addEventListener("beforeunload, () =} {}", `;`          this.encryptionService.clearAnonymousData()      })      // Clean up on visibility change (tab switch/close)      document.addEventListener("visibilitychange', (") =) {)",',  ")",        if (document.visibilityState === "hidden"          // Start countdown to cleanup if user doesn't return",          setTimeout(() => {}",',            if (document.visibilityState === "hidden",              this.encryptionService.clearAnonymousData()            }          }, 10 * 60 * 1000); // 10 minutes        }      })    }  },  private generateDisposableId(): string(return "anon_" + Math.random().toString(36).substring(2, 15 );',           Math.random().toString(36).substring(2, 15) +            Date.now().toString(36)  },  private generateAnonymousHandle(): string { const handles = []ilentSupporter", ", AnonymousAngel', ", QuietCompassion", ", HiddenHelper", ', KindStranger"];",      'PrivatePresence", ", SecretSupport", ", MaskedMentor', ", VeiledVoice", ', DisguisedDreamer",",      "FacelessFriend", ', NoNameNeeded", ", UnknownUplifter', ", ConcealedCare", ", GhostlyGuardian",',      "ShadowSoul", ', InvisibleInside", ", BlankBeing", ", HiddenHeart', ", MysteryMind",',      "WhisperWind", ", SilentSeeker", ', QuietVoice", ", AnonymousAlly', ", PeacefulPresence"    ]        return handles[]ath.floor(Math.random() * handles.length)] + Math.floor(Math.random() * 1000 },  private detectMessageType(content: string) AnonymousMessage[]ype]  {},    const lowerContent = content.toLowerCase(`;    // Crisis indicators    if (lowerContent.includes(suicide") || lowerContent.includes("kill myself') | | ";",        lowerContent.includes('end it all") || lowerContent.includes("want to die") | | ",        lowerContent.includes('no point") && lowerContent.includes("living')) {",      return "crisis;"    }        // Support messages    if (lowerContent.includes("support') || lowerContent.includes("here for you") | | ',        lowerContent.includes("sending hugs") || lowerContent.includes("you matter")) {',      return "support;"    },    return 'text;"  },  private detectCrisisContent(content: string) boolean(",    return this.detectMessageType(content) === "crisis  );  private generateCrisisResponse(): string {",    const responses = []'m very concerned about what you"ve shared in this anonymous space. Your life has value, and help is available right now: \n\nÔøΩ Call 988 - Suicide & Crisis Lifeline (24/7)\nüí¨ Text HOME to 741741 - Crisis Text Line\nüåê suicidepreventionlifeline.org\n\nThese services are also confidential. While our chat will disappear, your life matters. Can I help you connect with immediate support? ",']",      "Thank you for trusting me with something so difficult. Even in this anonymous space, I want you to know that help is available  : \n\nüìû 988 - National Suicide Prevention Lifeline\nüí¨ Text HELLO to 741741 - Crisis Text Line\n\nBoth are free, confidential, and available 24/7. Your anonymity will be respected. Would you like me to help you take that first step?", ", I hear you're in a lot of pain right now. This anonymous platform keeps your identity safe", but I want to connect you with people who can provide immediate help: \n\nÔøΩ 988 Lifeline - Call or chat online\nüí¨ Crisis Text Line - Text HOME to 741741\n\nYou don", t have to go through this alone. These services understand crisis situations. Can we explore getting you connected right now?'    ]        return responses[]ath.floor(Math.random() * responses.length)]  private async handleCrisisMessage(,  message: "AnonymousMessage,",  sessionId: "string,;",    roomId ?: string;  ): Promise<void>}    // Log crisis event without personal info    // Dont store crisis content longer than necessary',    message.autoDeleteAt = Math.min(, message.autoDeleteAt,      Date.now() + (30 * 60 * 1000) // Max 30 minutes for crisis messages    )  },  private async addSystemMessage(  roomId: string, content: string,",    type: "system  | ', support"): Promise<void>,    const message: AnonymousMessage="},"  id: this.generateDisposableId(,      content",',      sender: "System,",  timestamp: Date.now(,      type,      encrypted: false, autoDeleteAt: Date.now( + (5 * 60 * 1000), // System messages delete quickly      roomId    },    const roomMessages = this.messages.get(roomId) || [];    roomMessages.push(message)    this.messages.set(roomId, roomMessages)  },  private deleteRoom(roomId: string) void {this.rooms.delete(roomId)    this.messages.delete(roomId)  },  private storeTemporarySession(session: AnonymousSession) void  {    if (typeof sessionStorage !== undefined) {,      const sessionData={},  id: sessionid, handle: sessionhandle,';",        created: session.created,",        expiresAt: sessionexpiresAt      },      sessionStorage.setItem("anon_session_${session.id)`,         `SON.stringify(sessionData)"      )            // Set cleanup timeout      const timeUntilExpiry = session.expiresAt - Date.now(`;      setTimeout(() => {},          sessionStorage.removeItem(``non_session_${'`"
  sssi.id
),        this.sessions.delete(session.id)      , timeUntilExpy   }**   * Destroy service and clean up all data   */  destroy(): void {if (this.cleanupInterval) {clearInterval(this.cleanupInterval)}        // Clear all data structures    this.sessions.clear()    this.rooms.clear()    this.messages.clear()        // Clear browser storage    this.encryptionService.clearAnonymousData()  }}// Singleton instance with automatic cleanuplet anonymousChatServiceInstance: AnonymousChatService | null = null;", `;`export const getAnonymousChatService = (): void => {}  ;  if(!anonymousChatServiceInstance) { anonymousChatServiceInstance = new AnonymousChatService() },  return anonymousChatServiceInstance;}// React hook for anonymous chatexport const useAnonymousChat = (): void => {}  ;  const service = getAnonymousChatService(`;    return {"
  createSession: (service.createAnonymousSession(handle)) => $2,    createRoom: (name string, maxParticipants?: number, autoDeleteMinutes?: number) =       service.createAnonymousRoom(name, maxParticipants, autoDeleteMinutes),    joinRoom: (roomId string, sessionId: string =)service.joinRoom(roomId, sessionId),    leaveRoom: (roomId string, sessionId: string =)ervice.leaveRoom(roomId, sessionId),    sendMessage: (content string, sessionId: string roomId?: string, autoDeleteMinutes?: number) =>   service.sendAnonymousMessage(content, sessionId, roomId, autoDeleteMinutes),    getMessages: (roomId string, sessionId: s)}=> ))ie.getMessages(roomId, sessionId),    getAvailabRoo)> )e)ve.etAvailableRooms(),    generateTherapyResponse: (message string, sessionId: string context?: any) =>    srvice.generateTherapyResponse(message, sessionId, context),    panicDelete: (sessionId string) => srviepanicDelete(sessionId)`,    getSessionInfo: (sessionId string) => service.getSessionInfo(sessionId)`
,export default AnonymousChatService;