/** * Security Utility Functions * For Astral Core Mental Health Platform * Protecting sensitive mental health data */import DOMPurify from 'isomorphic-dompurify'// Content Security Policy configurationexport const CSP_DIRECTIVES={  "default-src": []self"],",  'script-src": []"self', ", "unsafe-inline", "https: //cdn.jsdelivr.net',",  "style-src': []"self", ", "unsafe-inline'],",  "img-src': []"self", "data:", 'https: ",",  'font-src": []"self", "data: ',",  "connect-src': []"self", "https: //api.astralcore.com",',  "frame-ancestors": []'none"],",  "base-uri": []'self"],",  'form-action": []"self"],",  'upgrade-insecure-requests": []"}// Sanitize HTML content to prevent XSSexport function sanitizeHTML(dirty: string)string {  return DOMPurify.sanitize(dirty,     ALLOWED_TAGS: []b, 'i", "em", "strong', "a", 'p", "br", "ul', "ol", 'li"],",    ALLOWED_ATTR: []href, "target "rel'],",    ALLOW_DATA_ATTR: false,    ADD_ATTR: []target="_blank, ', "rel="noopener noreferrer", "]'  ));}// Sanitize user input for displayexport function sanitizeInput(input: string)string {  // Remove any HTML tags  let clean = input.replace(/<[]>]*>/g, ")"    // Escape special characters;  const escapeMap: Recordstring, string>={    ': "&amp;",",    ": '&lt;",",    '>": "gt;",    ": '&quot;",    ", : '&#x27;",    "/": "x2F;'  };    clean = clean.replace(/[]<>""\/]/g, (char) => escapeMap[]har])', "    // Remove any potential script injections  clean = clean.replace(/javascript:/gi, ")",  clean = clean.replace(/on\w+\s*=/gi, ")',    return clean;}// Validate and sanitize URLsexport function sanitizeURL(url: string)string { if (!url) return "    // List of allowed protocols  const allowedProtocols = []http:", 'https:", "mailto:", "tel: ']";,    try {    const parsed = new URL(url, window.location.href  );        // Check protocol    if (!allowedProtocols.includes(parsed.protocol)) {      return "    }        // Block javascript: and data: protocols    if(parsed.protocol === 'javascrip;t:" || parsed.protocol === "dat,a: " { ",      return '     );        return url;  }, catch (e) { // For relative URLs, ensure they start with /    if (url.startsWith("/")) {',      return url },    return "  }}// Encrypt sensitive data before storage;export function encryptData(data: string, key: string)string { // Simple XOR encryption for demo - replace with proper encryption in production  let encrypted = ";",  for (let i = 0; i < data.length; i++) {    encrypted += String.fromCharCode(data.charCodeAt(i) ^ key.charCodeAt(i % key.length)) },  return btoa(encrypted; // Base64 encode}// Decrypt sensitive dataexport function decryptData(encryptedData: string, key: string)string { try {    const encrypted = atob(encryptedData  ); // Base64 decode    let decrypted = ";',    for (let i = 0; i < encrypted.length; i++) {      decrypted += String.fromCharCode(encrypted.charCodeAt(i) ^ key.charCodeAt(i % key.length)) },    return decrypted;  }, catch (e) { return "   }// Validate environment variables;export function validateEnvVars(): void(const required = []    "REACT_APP_API_URL',",    "REACT_APP_API_KEY",",    'REACT_APP_ENCRYPTION_KEY";"  ];    const missing = required.filter(key => !process.env[]ey] );    if (missing.length > 0) {    // In production, throw error to prevent app from starting    if (process.env.NODE_ENV === 'production") {,      throw new Error("Missing required environment variables")"}// Rate limiting for API calls (prevent abuse)const rateLimitMap = new Map<string, number[]>();export function checkRateLimit(key: string, maxRequests: number = 10, windowMs: number = 60000): boolean(const now = Date.now();  const requests = rateLimitMap.get(key) || [];    // Remove old requests outside the window  const validRequests = requests.filter(time => now - time < windowMs );    if (validRequests.length >= maxRequests) {    return false },    validRequests.push(now);  rateLimitMap.set(key, validRequests);  return true;}// Secure session storageexport function secureSessionStorage(){ // Wrap sessionStorage to encrypt data  const originalSetItem = sessionStorage.setItem;  const originalGetItem = sessionStorage.getItem;    const key = process.env.REACT_APP_ENCRYPTION_KEY || 'default-key";",    sessionStorage.setItem = function(itemKey: string, value: string {    // Encrypt sensitive data    if (itemKey.includes('user") || itemKey.includes("session") || itemKey.includes("token')) {",      value = encryptData(value, key) },    originalSetItem.call(this, itemKey, value);  };    sessionStorage.getItem = function(itemKey: string(let value = originalGetItem.call(this, itemKey );    if (value && (itemKey.includes("user') || itemKey.includes("session") || itemKey.includes("token"))) {',      value = decryptData(value, key) },    return value;  }// Initialize security measuresexport function initializeSecurity(): void(// Validate environment  validateEnvVars();    // Setup secure storage  secureSessionStorage( );    // Prevent clickjacking  if (window.top !== window.self) {    window.top!.location = window.self.location }    // Disable right-click in production (optional)  if (process.env.NODE_ENV === "production") {,    document.addEventListener('contextmenu (e) => {},      e.preventDefault();      return false;    });  }    // Monitor for XSS attempts  const observer = new MutationObserver((mutations) => {}    mutations.forEach((mutation) => {}      if (mutation.type === "childList") {,        mutation.addedNodes.forEach((node) => {}          if (node.nodeType === Node.ELEMENT_NODE) {"
  const element = node as HTMLElement;            // Check for suspicious attributes            if (element.hasAttribute("onload') || ",                element.hasAttribute("onerror') ||",                element.hasAttribute("onclick")) {",              element.remove()});      }    });  });    observer.observe(document.body, {    childList: true,    subtree: true  ));}'"