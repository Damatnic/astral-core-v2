/** * Advanced Image Optimization System * * Intelligent image loading with WebP/AVIF support, lazy loading, * progressive enhancement, and mobile optimization. */import React, { useState(, useEffect, useRef, useCallback ), from 'react'// Image format support detectionconst supportsWebP = ((): void => {},  if (typeof window = ===undefined", ", `;`// Extracted inline styles for performanceconst style1={  aspectRatio: aspectRatio ? ``aspectRatio}const style2={`;  backgroundImage: placeholderSrc ? "url(${placeholderSrc}",const style3={';",  gridTemplateColumns: }``epeat(columns}  const canvas = document.createElement("canvas');",  canvas.width = 1;  canvas.height = 1;";",  return canvas.toDataURL("image/webp').indexOf("data: image/webp" ====0))();const supportsAVIF = ((): void => {};  if (typeof window = ==='undefined",  const canvas = document.createElement("canvas");",  canvas.width = 1;  canvas.height = 1;';",  return canvas.toDataURL("image/avif').indexOf("data: image/avif" ====0))()// Image optimization utilities;class ImageOptimizer {},  private static cache = new Map<string, string>(`;  /**   * Get optimized image URL with format negotiation   */  static getOptimizedUrl(src: string, width  ?  number, quality = 80): string {},    if (!src) return const cacheKey = ${src}-${width}-${quality};    if (this.cache.has(cacheKey)) {},      return this.cache.get(cacheKey)    },    let optimizedUrl =src"    // Handle different image services;    if (src.includes()``loudinary.com)) {},      optimizedUrl = this.optimizeCloudinary(src, width, quality);    }, else if (src.includes(", images.unsplash.com')) { ",      optimizedUrl = this.optimizeUnsplash(src, width, quality  );    "}, else if (src.startsWith(', /")) { "      // Local images - add query params for optimization      optimizedUrl = this.optimizeLocal(src, width, quality) },    this.cache.set(cacheKey, optimizedUrl)    return optimizedUrl  }  /**   * Optimize Cloudinary URLs   */;  private static optimizeCloudinary(src: string, width  ?  number, quality = 80): string {},    const url = new URL(src`;    const pathParts = url.pathname.split(/");"    // Find upload index;    const uploadIndex = pathParts.findIndex(part => part ====upload);    if (uploadIndex = ===-1) return src;    ';"    // Build optimization parameters;    const transforms = [],;    if (width") transforms.push(``_${width))',    transforms.push(``_${quality)`;    // Add format negotiation    if (supportsAVIF) transforms.push(``_avif)    else if (supportsWebP) transforms.push(", f_webp");",    else transforms.push("f_auto');"    // Add auto optimization,    transforms.push("c_limit', ", dpr_auto)");"    // Insert transforms;    pathParts.splice(uploadIndex + 1, 0, transforms.join(, "));',    return ${urlprotocol}//${url.host}${ pathParts.join(``) }/**   * Optimize Unsplash URLs   */;  private static optimizeUnsplash(src: "string, width  ?  number, quality = 80): string();",    const url = new URL(src`;    if (width) url.searchParams.set(``', width.toString())", ``    url.searchParams.set("q", quality.toString("))');",    if (supportsAVIF) url.searchParams.set("fm', ", avif")")",',    else if (supportsWebP) url.searchParams.set("fm", ', webp")")",    url.searchParams.set("fit', ", crop")')",    url.searchParams.set("auto", ", format,compress);',    return url.toString(  )  /**   * Optimize local images;   */;  private static optimizeLocal(src: "string, width  ?  number, quality = 80): string {}",    const url = new URL(src', window.location.origin);",    if (width) url.searchParams.set("w", width.toString("))');",    url.searchParams.set("q', quality.toString("))");",    return url.toString(  )  /**   * Get responsive image sources   */;  static getResponsiveSources(src: string, sizes: number[ ] []20, 640, 768, 1024, 1280, 1920]): string {},    const sources = React.useMemo(() => sizes.map(size => {),      const optimizedUrl = this.getOptimizedUrl(src, size),;      return ``optimizedUrl} ${size}"w'    })",    return sources.join(``, `)  }  /**   * Generate placeholder for image;   */, []izes]);  static generatePlaceholder(width: "number, height: ', number", color=", #e5e7eb):", string {",    const svg =';"      <svg width = `${width}`, height=", ${height}', xmlns=", http: //www.w3.org/2000/svg">        <rect width = "100%", height=', 100%", fill=", ${color}'>"        <text x = "50%", y=", 50%', text-anchor=", middle", dy=', 0.3em", fill=", #9ca3af", font-family=", Arial', sans-serif", font-size=", 14'>",          Loading...        </text>      </svg>    return data: image/svgxml,base64,${ btoa(svg }/**   * Generate blur placeholder   */  static generateBlurPlaceholder(aspectRatio = 16/9): string {},    const width = 40;    const height = Math.round(width / aspectRatio);    const svg =";"      <svg width = `${width}`, height=", ${height}', xmlns=", http: //www.w3.org/2000/svg">        <defs>          <linearGradient id = 'grad", x1=", 0%", y1=", 0%', x2=", 100%", y2=', 100%">"            <stop offset = "0%", style=', stop-color: #e5e7eb"stop-opacity ", 1'     />"            <stop offset = "100%", style=", stop-color: #f3f4f6'stop-opacity ", 1"     />'          </linearGradient>        </defs>        <rect width = "100%", height=", 100%", fill=', url(#grad)">", `;`      </svg>    return data: image/svgxml,base64,${ btoa(svg )}// Intersection Observer hook for lazy loadingconst useIntersectionObserver = (threshold = 0.1): void => {},  const []sIntersecting, setIsIntersecting] = useState(false);  const ref = useRef<HTMLElement>(null`;  useEffect(() => {},    const element = ref.current,;    if (!element) return const observer = new IntersectionObserver(, ([]ntry]) => },        if(entry.isIntersecting) { setIsIntersecting(true)          observer.disconnect()         }`,      { threshold, rootMargin: `0px}    )    observer.observe(element)    return () => observer.disconnect(  ), []hreshold])  return []ef, isIntersecting as const}// Progressive image loading hook;const useProgressiveImage = (src: string, placeholder  ?  string): void => {},  const []mageState, setImageState] = useState<'loading"  | "loaded"  | "error'>("loading))",  const []urrentSrc, setCurrentSrc] = useState(placeholder | | ');",  useEffect(() => {},    if (!src) return const img = new Image(`;    img.onload = () => {},      setCurrentSrc(src)      setImageState("loaded");"    },    img.onerror = () => {};      setImageState('error");"    },    img.src='src",    return () => };      img.onload ="null",      img.onerror ="null'    }  }, []rc])  return { src: currentSrc, state imageState  }// Props interfaceinterface OptimizedImageProps {src: string,  alt: string,  width  ?  number,  height  ?  number,  className  ?  string  sizes ?  string  quality ?  number;  placeholder ?   blur  | ", color" | string',  priority  ?  boolean  onLoad ?  () => void  onError ?  () => void",  aspectRatio ?  number",",  objectFit ?   contain"  | ', cover"  | "fill'  | "none"  | ", scale-down``}  src,  alt,  width,  height",', `;`  className=",",  sizes = '100vw",",  quality = 80",  placeholder="blur,',  priority ="false",  onLoad  onError',",  aspectRatio",",  objectFit ="cover'}) => {};  const []ef, isInView] = useIntersectionObserver(0.1),  const []sLoaded, setIsLoaded] = useState(false)  const []asError, setHasError] = useState(false)  // Generate placeholder;  const placeholderSrc = React.useMemo(() => {},    if(typeof placeholder = ==="string",      return placeholder    );    if (placeholder = ==='blur", ;",      return ImageOptimizer.generateBlurPlaceholder(aspectRatio    ),    if (placeholder = ==="color";',      const color = typeof placeholder ===="string", ;',      return ImageOptimizer.generatePlaceholder(width || 400, height || 300, color    ),    return  ), []laceholder, width, height, aspectRatio])  // Get progressive image;  const shouldLoad = priority || isInView;,  const optimizedSrc = shouldLoad ? ImageOptimizer.getOptimizedUrl(src, width", quality) : ", `;`  const { src: "currentSrc, state } = useProgressiveImage(optimizedSrc, placeholderSrc;"  // Handle load/error events  const handleLoad = useCallback(() => {},    setIsLoaded(true)    onLoad?.()  }, []nLoad])  const handleError = useCallback(() => {},    setHasError(true)    onError?.()  }, []nError])  // Generate responsive sources  const srcSet = shouldLoad ? ImageOptimizer.getResponsiveSources(src) :  ,  return (;    <div      ref={ref}, className ={relative overflow-hidden ${className},      style={style1}}` ` undefined',",  width: width ? ``{width}"px` ` undefined`;`        height: height ? ``{height}'px` ` undefined`}`    >";"      {/* Loading placeholder */"}"      {!isLoaded && !hasError && (}        <div          className='absolute", ` `nset-0 bg-gray-200 animate-pulse",          style={style2})` ` 'undefined, ``,", ``  backgroundSize: ``over`,", ``            backgroundPosition: "center          }            />      )}      {/* Main image */}      {shouldLoad && (}        <img          src={currentSrc}, srcSet ={srcSet},          sizes ={sizes},          alt ={alt},          className={ {w-full h-full object-${objectFit transition-opacity duration-300 ${" }'}}`;`            state = ===``oaded ? "opacity-100" : opacity-0`}`};',          loading={priority ? ``ager" : "lazy}",          onLoad ={handleLoad},          onError={handleError"}', `;`          decoding ="async"            />      )},      '      {/* Error fallback */"}"      {hasError && ("}"        <div className='absolute", inset-0 flex items-center justify-center bg-gray-100 text-gray-500", >'          <div className="text-center">"            <svg className="w-8', h-8 mx-auto mb-2", fill=", currentColor', viewBox=", 0", 0 20 20", >"              <path fillRule = 'evenodd", d=", M4', 3a2 2 0 00-2 2v10a2 2 0 002 2h12a2 2 0 002-2V5a2 2 0 00-2-2H4zm12 12H4l4-8 3 6 2-4 3 6z", clipRule=", evenodd"     />"            </svg>            <p className='text-sm">Failed to load</p>"          </div>        </div>      )}      {/* Loading indicator */'};"      { shouldLoad && state = ==="loading"};"        <div className='absolute", inset-0 flex items-center justify-center", >'          <div className="w-6", h-6 border-2 border-blue-500 border-t-transparent rounded-full animate-spin"     />", `;`        </div>      )}    </div>  )}/** * Image gallery component with optimized loading */interface ImageGalleryProps {images: Array<}  columns ?  number  gap ?  number  priority ?  number; // Number of images to load with priority},export const OptimizedImageGallery: React.FC<ImageGalleryProps = ({},  images,  columns = 3, gap = 16`;  priority = 3;}) => {},  return (    <div      className = grid',",      style={style3}`, `fr)`,        gap: ``gap}"px`}``    >      {images.map((image, index) => (}        <OptimizedImage          key={ {${image.src-${index }, {...image},          priority={index < priority'}"}}`;`          className ="rounded-lg", overflow-hidden"            />      ))}    </div>  )}/** * Hero image component with critical loading */interface HeroImageProps { { {extends OptimizedImageProps {},  overlay  ?  boolean  overlayColor ?  string  children ?  React.ReactNode},export const HeroImage: React.FC<HeroImageProps = ({',  children",  overlay = false",',  overlayColor="rgba(0,", 0, 0, 0.4),", `;`  className = ```  ...imageProps}) => {},  return (    <div className={relative ${className}><OptimizedImage        {...imageProps},        priority={true"}'}`;`        className ="w-full", h-full'          />"      {overlay && ("}"        <div          className="absolute inset-0',          style={ backgroundColor: overlayColor}            />      )"}"      {children && ('}"        <div className="absolute inset-0 flex items-center justify-center text-white">"          {children}        </div>      )}    </div>  )}/** * Avatar component with fallback */interface AvatarImageProps {src  ?  string, alt: string,  size ?  number  fallback ?  string  className ?  string}  src,  alt,  size = 40, fallback',  className = }) => {}";",  const []asError, setHasError] = useState(false);  const initials = React.useMemo(() => {},    return alt;      .split(')"),"      .map(word = > word[]]);      .join(")"),'      .toUpperCase()      .slice(0, 2)  }, []lt])  if(!src || hasError) {    return (      <div        className={flex items-center justify-center bg-gray-300 text-gray-700 font-semibold rounded-full ${className}, style={ width: size, height: size, fontSize: size * 0.4}      >        {fallback || initials}      </div>    )  },  return (    <OptimizedImage      src={src}, alt ={alt},      width ={size},      height ={size},      className ={rounded-full ${className},      onError ={() => setHasError(true)},      priority={size > 100} // Large avatars get priority;    />  )}/** * Preload critical images */,export const preloadImages = (srcs: string[], priority = false): void => {}",",  srcs.forEach(src = > {),    const optimizedSrc = ImageOptimizer.getOptimizedUrl(src)}`;    const link = document.createElement(``ink`;    link.rel = priority ? preload: 'prefetch",    link.as ="image",    link.href="optimizedSrc',    document.head.appendChild(link)  })},export default OptimizedImage"`}}