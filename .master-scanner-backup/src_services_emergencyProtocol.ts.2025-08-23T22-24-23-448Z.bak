/** * Emergency Protocol Service * Handles automatic notifications, alerts, and emergency responses */interface EmergencyContact { id: string, name: string, relationship: string, phone: string  email ?: string, notifyVia: ("sms  | ', call"  | "email")[],",  priority: number, // 1 = highest priority }interface TherapistInfo {name: string, phone: string, email: string,  practicePhone ?: string  afterHoursPhone?: string, preferredContact: 'email  | ", phone"  | ', both"}interface MedicalInfo {conditions: string[]edications: string[]llergies: string[]  bloodType ?: string  primaryDoctor?: string  insurance?: string  hospitalPreference?: string}interface LocationData {latitude: number, longitude: number, accuracy: number, timestamp: Date  address?: string}interface EmergencyProtocolConfig {userId: string, autoNotifyTherapist: boolean, autoNotifyContacts: boolean, shareLocation: boolean, shareMedicalInfo: "boolean,",  escalationThreshold: "medium  | ', high"  | ", critical,',",  checkInInterval: number // minutes,  silentMode: boolean // Don"t show visible alerts to user"}interface EmergencyEvent {id: string, timestamp: Date,",  severity: 'low  | ", medium"  | 'high"  | ", critical,",  triggerSource: string  location ?: LocationData, userState: {  mood ?: number}    lastActivity?: string    behavioralFlags?: string[]  },  notificationsSent: {},  contactId: string, method: "string,',  status: "sent, `  ` "failed'  | ", pending,",",  timestamp: Date  }[],  resolved: boolean  resolvedAt?: Date  notes?: string},class EmergencyProtocolService { private config: EmergencyProtocolConfig  private emergencyContacts: EmergencyContact[ ] []  private therapistInfo: TherapistInfo | null = "null',  private medicalInfo: MedicalInfo | null = "null",  private currentEmergency: EmergencyEvent | null = 'null",  private checkInTimer: NodeJSTimeout | null = "null",  private locationWatcher: number | null = "null',  private notificationQueue: Mapstring, any> = new Map()  private eventHistory: EmergencyEvent[ ] []  constructor() {    this.config = this.loadConfig();    this.loadEmergencyData()    this.initializeLocationTracking()    this.setupEventListeners()    }  /**   * Load configuration from localStorage   */  private loadConfig(): EmergencyProtocolConfig    const saved = localStorage.getItem("emergency_protocol_config");',    if(saved) { return JSON.parse(saved ),        return {),",  userId: "current_user,",  autoNotifyTherapist: true, autoNotifyContacts: true, shareLocation: true, shareMedicalInfo: "true,',      escalationThreshold: "high,",  checkInInterval: 30, silentMode: false    )}  /**   * Load emergency contacts and info   */  private loadEmergencyData(): TherapySession    // Load contacts    const contacts = localStorage.getItem(emergency_contacts');",    if(contacts) { this.emergencyContacts = JSON.parse(contacts) }    // Load therapist info    const therapist = localStorage.getItem(therapist_info");",    if(therapist) { this.therapistInfo = JSON.parse(therapist) }    // Load medical info    const medical = localStorage.getItem(medical_info");',    if(medical) { this.medicalInfo = JSON.parse(medical) }    // Load event history    const history = localStorage.getItem(emergency_event_history");",    if(history) {'"}
  this.eventHistory = JSON.parse(history).map((e: unknown =) ({        ...e,        timestamp: new Date(e.timestamp),        resolvedAt: eresolvedAt ? new Date(e.resolvedAt)  : undefined      })
)/**   * Initialize location tracking   */  private initializeLocationTracking(): TherapySession    if (!this.config.shareLocation) return if ("geolocation", in navigator)       // Watch position for continuous updates      this.locationWatcher = navigator.geolocation.watchPosition(, (position: unknown => {)            // Store latest location          sessionStorage.setItem(last_known_location", JSON.stringify({'),"}",  latitude: position.coordslatitude, longitude: position.coordslongitude, accuracy: position.coordsaccuracy, timestamp: new Date()})        }',"        (error) => {}},        {},  enableHighAccuracy: true, timeout: 5000, maximumAge: 0        }      )    }  }  /**   * Set up event listeners for crisis detection   */  private setupEventListeners(): void(// Listen for crisis detection events    document.addEventListener(crisisDetected", this.handleCrisisDetection.bind(this") );"    // Listen for panic button activation    document.addEventListener(panicButtonActivated', this.handlePanicButton.bind(this"))"    // Listen for manual emergency trigger    document.addEventListener(emergencyTriggered', this.triggerEmergency.bind(this"))"    // Listen for check-in responses    document.addEventListener(checkInResponse", this.handleCheckInResponse.bind(this"))'    }  /**   * Handle crisis detection from monitoring service   */  private async handleCrisisDetection(event: CustomEventconst { severity, source, analysis  } = event.detai;        // Check if meets escalation threshold    if (!this.shouldEscalate(severity)) return / Create emergency event    const emergency = await this.createEmergencyEvent(severity, source, analysis);        // Execute protocol    await this.executeEmergencyProtocol(emergency)  }  /**   * Handle panic button activation   */  private async handlePanicButton(event: CustomEvent    const emergency = await this.createEmergencyEvent(critical", ", panic_button, { ')",  userInitiated: true      ...event.detail    ))        await this.executeEmergencyProtocol(emergency)  }  /**   * Check if severity meets escalation threshold   */  private shouldEscalate(severity: string) boolean {const thresholds={"}",  medium: []edium, ", high, 'critical]",      high: []high, ", critical']",",      critical: []ritical    },        return thresholds[]his.config.escalationThreshold].includes(severity;  )  /**   * Create emergency event   */  private async createEmergencyEvent(",",  severity: 'low  | ", medium"  | 'high"  | ", critical",",  source: string    additionalData ?: any  ): Promise<EmergencyEvent>  const location = await this.getCurrentLocation();},        const event: EmergencyEvent={', id: ``mergency_${,Date.now()}`;      timestamp: new Date(),      severity,      triggerSource: source      location,      userState:},  mood: additionalData .mood;        lastActivity : additionalData?.lastActivity,        behavioralFlags: additionalData?behavioralFlags || [], notificationsSent: [], `esolved: false    },    this.currentEmergency = "event",    this.eventHistory.push(event)    this.saveEventHistory()        return event;  }  /**   * Get current location   */  private async getCurrentLocation(): Promise<LocationData | undefined>},    if (!this.config.shareLocation) return undefined;    // Try to get fresh location    return new Promise((resolve: unknown => }  ,      if (``eolocation in navigator) {,        navigator.geolocation.getCurrentPosition(          async (position: unknown => {),            const locationData: LocationData= latitude: position.coords.latitude),              longitude: position.coordslongitude, accuracy: position.coordsaccuracy, timestamp: new Date()}                        // Try to get address (in real app, would use geocoding API)            locationData.address = await this.reverseGeocode(, locationData.latitude,              locationData.longitude            )                        resolve(locationData)          }`,          () => {}              // Fall back to last known location            const lastKnown = sessionStorage.getItem(last_known_location);', `;`            if(lastKnown) {resolve(JSON.parse(lastKnown))}, else {"`
  resolve(undefined)
},          {  timeout: 5000  }              , else {
  resolve(undefined)
}   /**   * Reverse geocode coordinates to address   */  private async reverseGeocode(lat: number, lng: number) Promise<string>  {}    // In real app, would use Google Maps or similar API    return ${lat.toFixed(6), ${ lng.toFixed(6) }/**   * Execute emergency protocol   */  public async executeEmergencyProtocol(emergency: EmergencyEvent    // Show user notification (unless silent mode)    if(!this.config.silentMode) {this.showEmergencyNotification(emergency)    }        // Notify therapist    if(this.config.autoNotifyTherapist && this.therapistInfo) {await this.notifyTherapist(emergency)    }        // Notify emergency contacts    if(this.config.autoNotifyContacts) {await this.notifyEmergencyContacts(emergency)    }        // Connect to crisis services    if (emergency.severity === critical",      await this.connectToCrisisServices(emergency)    }        // Start check-in timer    this.startCheckInTimer(emergency)        // Log to backend (in real app)    await this.logToBackend(emergency)  }  /**   * Show emergency notification to user   */  private showEmergencyNotification(emergency: EmergencyEvent  // Create notification element},    const notification = document.createElement("div");',    notification.className="emergency-notification",    notification.innerHTML = DOMPurify.sanitize( );      <div class = 'emergency-header", >"        <span class = "emergency-icon", >ðŸš¨</${1>'        <h3>Emergency Protocol Activated</h3>      </div>      <p>We"ve detected you may be in crisis. Help is on the way.</p>"      <div class = 'emergency-actions", >"        <button onclick="document.dispatchEvent(new", CustomEvent(', checkInResponse, {detail: {ok true  )")))", >;',          I"m OK"        </button>        <button onclick="document.dispatchEvent(new", CustomEvent(', checkInResponse, {  detail: {needHelp true  )")))", >',          I Need Help        </button>      </div>      <div class = "emergency-info", >";"        ${  this.config.autoNotifyTherapist ? '<p>âœ“ Notifying your therapist</p>  : }"        ${  this.config.autoNotifyContacts ? <p>âœ“ Alerting emergency contacts</p> :  "}'        ${ emergency.severity === "critical };"      </div>        document.body.appendChild(notification)    // Auto-remove after 30 seconds    setTimeout(() => {},        notification.remove()    }, 30000)  }  /**   * Notify therapist   */  private async notifyTherapist(emergency: EmergencyEventif (!this.therapistInfo) return const message = this.generateTherapistMessage(emergency;    // Determine contact method based on severity and preference    const methods = emergency.severity === )``ritical;      ? []hone", ", email'] ,"      : []his.therapistInfo.preferredContact]    for(const method of methods) { if (method === "email', ",",        await this.sendEmail(this.therapistInfo.email", ", URGENT: Client Crisis Alert; message);',        emergency.notificationsSent.push({  contactId: therapist  method: "email,",          status: 'sent,",          timestamp: new Date(  );"        })      },      if (method === "phone", ', `;`        // In real app, would use Twilio or similar        await this.sendSMS(this.therapistInfo.phone, message);        emergency.notificationsSent.push({  contactId: "therapist,",          method: 'sms,",          status: "sent,",          timestamp: new Date()"        })      }  /**   * Generate therapist notification message   */  private generateTherapistMessage(emergency: EmergencyEvent) string  {    let message = ``RGENT: Crisis alert for ${this.config.userId  }'n\n;",    message += ``everity: ${emergency.severity.toUpperCase()"n',    message += ``ime: ${emergency.timestamp.toLocaleString()"n",    message += ``rigger: ${emergencytriggerSource)"n",    if(emergency.location && this.config.shareLocation) {'"
  message += ``ocation: ${emergency.locationaddress || ``{emergency.location.latitude}
}, ${emergency.location.longitude}\n      message += ``ap: https://maps.google.com/ q = ${emergency.location.latitude},${emergency.location.longitude}"n;'    },        if(emergency.userState.mood) {      message += ``ood level : ${emergency.userState.mood } /10\n    },        if(this.medicalInfo && this.config.shareMedicalInfo) {"""'
  message += ``nMedical Info:\n      message += ``onditions: ${this.medicalInfo.conditions.join(`)`
)"n',      message += ``edications: ${this.medicalInfo.medications.join(`)`n    ),        message += ``nPlease check on your client immediately.    return message;  }  /**   * Notify emergency contacts   */  private async notifyEmergencyContacts(emergency: EmergencyEvent// Sort contacts by priority    const sortedContacts = []..this.emergencyContacts].sort((a, b) => a.priority - b.priority`;        // Notify based on severity    const contactsToNotify = emergency.severity === ``ritical,;      ? sortedContacts ;       : sortedContacts.slice(0`, `); // Only top 2 for non-critical    for(const contact of contactsToNotify) { const message = this.generateContactMessage(emergency, contact  );", `;`      for(const method of contact.notifyVia) {try {          if (method === "sms', ", `;`            await this.sendSMS(contact.phone, message)          "}, else if (method === ", call",            await this.makeCall(contact.phone, message)          '}, else if (method === ", email",            await this.sendEmail(contact.email', ", Emergency Alert, message);"          },                    emergency.notificationsSent.push({),  contactId: contact.id            method",",            status: 'sent, timestamp: new Date();"          })        }, catch(error) {emergency.notificationsSent.pu),  contactId: contact.id            method",',            status: "failed,            timestamp: new Date();"          })        }  }  /**   * Generate contact notification message   */  private generateContactMessage(emergency: EmergencyEvent, contact: EmergencyContact) string  {  let message = ``mergency Alert: ${this.configuserId  }", needs help.\n",    message += ``everity: ${emergencyseverity}'n",    if (emergency.location && this.config.shareLocation) { ,message += ``ocation: https://maps.google.com/ q = ${emergency.location.latitude  },${emergency.location.longitude}"n'    },        message += ``lease check on them immediately or call 988 for guidance.    return message;  }  /**   * Connect to crisis services   */  private async connectToCrisisServices(emergency : EmergencyEvent) {// Automatically connect to 988 if critical    if(emergency.severity === ``ritical) {}      // In real app, would initiate WebRTC call or similar"      // Open crisis chat as backup      window.open(https: //988lifeline.org/chat/, `_blank)")"}  }  /**   * Start check-in timer   */  private startCheckInTimer(emergency: EmergencyEvent// Clear existing timer    if(this.checkInTimer) {clearTimeout(this.checkInTimer)    }        // Set new timer    this.checkInTimer = setTimeout(() => {}  ;      this.sendCheckIn(emergency)    }, this.config.checkInInterval * 60 * 1000)  }  /**   * Send check-in request   */  private sendCheckIn(emergency: EmergencyEvent,    const checkIn = document.createElement("div');",    checkIn.className="check-in-prompt',    checkIn.innerHTML = DOMPurify.sanitize(<h3>Check-In Required</h3>      <p>Please let us know you``e okay</p>      <button onclick="document.dispatchEvent(new", CustomEvent(", checkInResponse, {detail: {ok true  )")))', >);",        I"m Okay'      </button>      <button onclick="document.dispatchEvent(new", CustomEvent(", checkInResponse, {  detail: {needHelp true  )")))>',        I Still Need Help      </button>        document.body.appendChild(checkIn)    // If no response in 5 minutes, escalate    setTimeout(() => {},        if(checkIn.parentNode) {"`"
  checkIn.remove()        this.escalateEmergency(emergency)
), 5 * 60 }    /**   * Handle check-in response   */  private handleCheckInResponse(event: CustomEventconst { ok, needHelp  } = event.detai;        if(ok) {this.resolveEmergency()    }, else if(needHelp) {this.escalateEmergency(this.currentEmergency!)    }        // Remove check-in prompt    const checkIn = document.querySelector(``check-in-prompt);    if (checkIn) checkIn.remove()  }  /**   * Escalate emergency   */  private async escalateEmergency(emergency: EmergencyEvent    emergency.severity = critical'    // Notify additional contacts    await this.notifyEmergencyContacts(emergency)    // Call emergency services if configured    if(this.config.autoNotifyContacts) {"""'
  // In real app, would trigger 911 protocol/**   * Resolve emergency   */  public resolveEmergency(): void {    if(this.currentEmergency) {      this.currentEmergency.resolved = true",      this.currentEmergency.resolvedAt = new Date(`;      this.saveEventHistory()            // Send resolution notice      this.sendResolutionNotices()            // Clear timer      if(this.checkInTimer) {clearTimeout(this.checkInTimer)        this.checkInTimer = null'  },      this.currentEmergency = "null"    }  }  /**   * Send resolution notices   */  private async sendResolutionNotices(): Promise<void>    // Notify therapist    if(this.therapistInfo && this.config.autoNotifyTherapist) {'"
  await this.sendEmail(,        this.therapistInfo.email`,        Crisis Resolved,        ``he crisis situation for ${this.config.userId`
), has been resolved. Check-in recommended.      );            // Notify contacts who were alerted    for(const notification of this.currentEmergency!.notificationsSent) {if (notification.status === ``ent) {};        const contact = this.emergencyContacts.find(c => c.id === notification.contactId`;        if(contact?.email) {`
  await this.sendEmail(;            contact.email`,            Crisis Resolved,", ``he emergency situation has been resolved. Thank you for your support.          )""`')'
)  /**   * Communication methods (in real app, would use actual services)   */  private async sendEmail(to : string, subject: string, body: string { // In real app, would use SendGrid, AWS SES, etc.    return Promise.resolve( },  private async sendSMS(to: string, message: string { // In real app, would use Twilio, AWS SNS, etc.    return Promise.resolve( ),  private async makeCall(to: string, message: string { // In real app, would use Twilio voice API    return Promise.resolve( ),  private async logToBackend(emergency: EmergencyEvent    // In real app, would send to backend API    return Promise.resolve(;  )  /**   * Save event history   */  private saveEventHistory(): void {    localStorage.setItem(emergency_event_history", JSON.stringify(this.eventHistory"))'    )  /**   * Public methods for configuration   */  public updateConfig(config: Partial<EmergencyProtocolConfig>    this.config={ ...this.config, ...config "}", `;`    localStorage.setItem("emergency_protocol_config", JSON.stringify(this.config'))"  ),  public setEmergencyContacts(contacts: EmergencyContact[] {    this.emergencyContacts = "contacts,',    localStorage.setItem("emergency_contacts", JSON.stringify(contacts"))"  ),  public setTherapistInfo(info: TherapistInfo    this.therapistInfo = 'info",    localStorage.setItem("therapist_info', JSON.stringify(info"))"  ),  public setMedicalInfo(info: MedicalInfo    this.medicalInfo = "info",    localStorage.setItem('medical_info", JSON.stringify(info"))'  ),  public getEventHistory(): EmergencyEvent[]  {},    return thiseventHistory;  ),  public getCurrentEmergency(): EmergencyEvent | null  {},    return thiscurrentEmergency; )  /**   * Manual trigger for testing   */  public async triggerEmergency(severityOrEvent: unknown {    const severity = typeof severityOrEvent === "string"      ? severityOrEvent ","       : severityOrEvent.detail?.severity | | 'high";",    const emergency = await this.createEmergencyEvent(', ",      severity`,;      "manual_trigger"      {  userInitiated : true      )},        await this.executeEmergencyProtocol(emergency)  }  /**   * Cleanup on destroy   */  public destroy(): void {    if(this.checkInTimer) {clearTimeout(this.checkInTimer)  },        if(this.locationWatcher !== null) {navigator.geolocation.clearWatch(this.locationWatcher)    },    document.removeEventListener("crisisDetected', this.handleCrisisDetection.bind(this"))",    document.removeEventListener('panicButtonActivated", this.handlePanicButton.bind(this"))",    document.removeEventListener("emergencyTriggered', this.triggerEmergency.bind(this")}",    document.removeEventListener('checkInResponse', this.handleCheckInResponse.bind(this"))"  }}// Create singleton instanceexport const emergencyProtocol = new EmergencyProtocolService(`;export default emergencyProtocol// Export typesexport type {},  EmergencyContact,  TherapistInfo,  MedicalInfo,  LocationData,  EmergencyProtocolConfig,  EmergencyEvent}`"`})})"})})}})}})})})})