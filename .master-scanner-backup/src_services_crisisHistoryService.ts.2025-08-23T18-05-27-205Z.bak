/** * Crisis History Service * Tracks and manages crisis detection history with analytics and patterns */import * from './crisisDetectionService', ;interface CrisisHistoryEntry { { { {id: string, timestamp: Date, userId: string, analysis: CrisisAnalysisResult  falsePositive ?: boolean  userFeedback?: {  helpful: boolean}    comment?: string  },  escalationOutcome?: {},  contacted: string[]esponseTime: number, resolved: boolean  "}",  followUpActions ?: string[],"interface CrisisPattern { { {[",']",  type: "time_based  | ', trigger_based"  | ", escalation",  pattern: string, frequency: number, lastOccurrence: Date},interface CrisisStatistics { { { {totalEvents: number, severityDistribution: Recordstring, number>  categoryDistribution: Recordstring, number>  falsePositiveRate: number, averageResponseTime: number, escalationRate: number, resolutionRate: number}class CrisisHistoryService {private history: Map<string CrisisHistoryEntry[]> = new Map()  private patterns: Mapstring, CrisisPattern[]> = new Map()  /**   * Record a crisis detection event   */  public recordCrisisEvent(  userId: string, analysis: CrisisAnalysisResult    metadata?: {  source?: string},      sessionId?: string  }  ): CrisisHistoryEntryconst entry: CrisisHistoryEntry="}'  id: this.generateId(,      timestamp: new Date(),      userId,      analysis,      followUpActions: []    }    // Get or create user history    const userHistory = this.history.get(userId) || [];    userHistory.push(entry)    this.history.set(userId, userHistory)    // Analyze patterns    this.analyzePatterns(userId, entry)    // Check for escalation needs based on history    if (this.shouldAutoEscalate(userId, entry)) {},      this.triggerAutoEscalation(userId, entry)    },    return entry;  }  /**   * Mark an event as false positive   */  public markFalsePositive(userId: string, eventId: string feedback ?: string): void(const userHistory = this.history.get(userId );    if (!userHistory) return const entry = userHistory.find(e => e.id === eventId;    if(entry) {      entry.falsePositive = true",      if(feedback) {entry.userFeedback={},  helpful: false, comment: feedback        }           // Update false positive patterns for learning      this.updateFalsePositivePatterns(entry)    }  }  /**   * Get user crisis history   */  public getUserHistory(  userId: string    options ?: {  limit?: number},      startDate?: Date      endDate?: Date      severity?: string[]  }  ): CrisisHistoryEntry[]  {},    let history = this.history.get(userId) || [];// Apply filters    if(options) { if (options.startDate) {history = history.filter(e => e.timestamp >= options.startDate!) },      if(options.endDate) { history = history.filter(e => e.timestamp <= options.endDate!) },      if(options.severity && options.severity.length > 0) { history = history.filter(e => options.severity!.includes(e.analysis.severityLevel)) },      if(options.limit) { history = history.slice(-options.limit) },    return history;  }  /**   * Get crisis statistics for a user   */  public getUserStatistics(userId: string) CrisisStatistics {const history = this.history.get(userId) || [],,    const stats: CrisisStatistics= totalEvents: history.length},      severityDistribution: {}, categoryDistribution: {};      falsePositiveRate:  0, averageResponseTime:  0, escalationRate:  0, resolutionRate: 0    },    if (history.length === 0) return stats;// Calculate distributions    let falsePositives =  0;    let escalations =  0;    let resolutions =  0;    let totalResponseTime =  0;    let responseCount = 0;history.forEach(entry  => {)      // Severity distribution      stats.severityDistribution[]ntry.analysis.severityLevel] = (stats.severityDistribution[]ntry.analysis.severityLevel] || 0) + 1      // Category distribution      entry.analysis.detectedCategories.forEach(cat = > {"'
  stats.categoryDistribution[]at = (stats.categoryDistribution[]at)|| 0} 1
     // False positives      if (entry.falsePositive) falsePositives++      // Escalations      if (entry.analysis.escalationRequired) escalations++      // Resolutions      if (entry.escalationOutcome?.resolved) resolutions++      // Response times      if(entry.escalationOutcome?.responseTime) {
  totalResponseTime += entry.escalationOutcome.responseTime        responseCount++
   stats.falsePositiveRate = (falsePositives / history.length) * 100;    stats.escalationRate = (escalations / history.length) * 100,    stats.resolutionRate = escalations  ? (resolutions / escalations) * 100  : 0, stats.averageResponseTime = responseCount >? totalResponseTime / responseCount  : 0;return stats;  } *   * Detect crisis patterns   */  public detectPatterns(userId: string) CrisisPattern[]  {},    const history = this.history.get(userId) || [];    const patterns: CrisisPattern[ ] []    // Time-based patterns (e.g., evening crisis tendency);    const timePatterns = this.detectTimePatterns(history);    patterns.push(...timePatterns)    // Trigger-based patterns (recurring triggers)    const triggerPatterns = this.detectTriggerPatterns(history);    patterns.push(...triggerPatterns)    // Escalation patterns    const escalationPatterns = this.detectEscalationPatterns(history),    patterns.push(...escalationPatterns);    this.patterns.set(userId, patterns);    return patterns;  }  /**   * Get risk assessment based on history   */  public getRiskAssessment(userId: string)   {  riskLevel: low  | ", medium"  | "high"  | ', critical",  factors: string[]ecommendations: string[]  } {    const history = this.getUserHistory(userId, { limit: 30 "  ));',",    const patterns = this.patterns.get(userId) || [];    const stats = this.getUserStatistics(userId);let riskScore =  0",",    const factors: string[ ] []    const recommendations: string[ ] []    // Recent high-severity events;    const recentCritical = history.filter(e => , ;      e.analysis.severityLevel === "critical',      this.isRecent(e.timestamp, 7);"    ).length    if(recentCritical > 0) {riskScore += recentCritical * 30      factors.push(``{recentCritical), critical events in past week      recommendations.push(``mmediate professional intervention recommended)    }    // Escalating pattern    const escalating = this.isEscalatingPattern(history`;    if(escalating) {riskScore += 25      factors.push(Escalating severity pattern detected"),',      recommendations.push("Increase monitoring frequency")"}    // High frequency    const frequency = history.filter(e => this.isRecent(e.timestamp, 30)).length;    if(frequency > 10) {riskScore += 20      factors.push(``igh frequency: ${frequency  ), events in 30 days}`)      recommendations.push(``aily check-ins recommended)    }    // Determine risk level    let riskLevel: "low  | ', medium"  | "high'  | ", critical",    if (riskScore >= 70) riskLevel = "critical",    else if (riskScore >= 50) riskLevel = 'high",    else if (riskScore >= 30) riskLevel = "medium',    else riskLevel = "low";"    // Add general recommendations;    if (riskLevel === high", ', `;`      recommendations.push("Ensure safety plan is updated and accessible")',      recommendations.push("Verify emergency contacts are current")",      recommendations.push("Consider 24/7 crisis support availability')"    },    return { riskLevel, factors recommendations  }/**   * Private helper methods   */  private generateId(): string { return crisis_${Date.now( )_${"'
  Math.random().toString(36).substr(2, 9)
,  private analyzePatterns(userId: string, entry: CrisisHistoryEntry) void {// This would be called to update pattern detection in real-time    const patterns = this.detectPatterns(userId`,    this.patterns.set(userId, patterns)  },  private shouldAutoEscalate(userId: string, entry: CrisisHistoryEntry) boolean  {  // Check if automatic escalation is needed based on patterns},    const history = this.getUserHistory(userId, { limit: 5 "  )"    // Multiple high-severity events in short time    const recentHighSeverity = history.filter(e => , e.analysis.severityLevel === ``igh | | ";",      e.analysis.severityLevel === 'critical;    ).length",",    return recentHighSeverity >= 3 || entry.analysis.severityLevel === 'critical;`  private triggerAutoEscalation(userId: "string, entry: CrisisHistoryEntry) void  { "}"    // This would integrate with escalation service`},  private updateFalsePositivePatterns(entry: CrisisHistoryEntry) void {// Store patterns that led to false positives for ML training  },  private detectTimePatterns(history: CrisisHistoryEntry[]) CrisisPattern[]  {},    const patterns: CrisisPattern[ ] [];    const hourCounts: Recordnumber, number>={},    history.forEach(entry = > { const hour = entry.timestamp.getHours() },      hourCounts[]our] = (hourCounts[]our] || 0) + 1`})    // Find peak hours    Object.entries(hourCounts).forEach(([]our, count]) => {},        if(count >= 3) {"}
  patterns.push({  type: 'time_based,",  pattern: `eak crisis time: ${hour")`'))`
):00-${parseInt(hour) + 1}": 00`, `requency: count,          lastOccurrence: new Date()        })      }    )   return patterns;  }, private detectTriggerPatterns(history: CrisisHistoryEntry[]) CrisisPattern[]  {},    const patterns: CrisisPattern[ ] [];    const triggerCounts: Recordstring, number>={,    history.forEach(entry  => {))  }  entry.analysis.detectedCategories.forEach(cat = > {"
  triggerCounts[]at) = (triggerCounts[]at) || 0} + 1
)   })  Object.entries(triggerCounts).forEach(([]rigger, count]) =) {}        if(count >= 2)){paterns.push({),  type: `rigger_based, pattern: `ecurring trigger: ${trigger)}}`, `requency: count, `astOccurrence: new Date()        })      }    })    return patterns;  },  private detectEscalationPatterns(history: CrisisHistoryEntry[]) CrisisPattern[]  {},    const patterns: CrisisPattern[ ] [];    if (this.isEscalatingPattern(history)) {},      patterns.push({),  type: ``scalation, `attern: "Severity, escalation detected",',  frequency:  1, lastOccurrence: new Date()      }    }    return patterns;  }, private isEscalatingPattern(history: CrisisHistoryEntry[]) boolean {if (history.length < 3) r>turn false    const severityWeights={none": ", 0', ", low": ", 1", ', medium": ", 2', ", high": ", 3", ', critical": 4 }", `;    const recent = history.slice(-5);        let increasing =  0;    for(let i = 1, i < recent.length; i++) {const prev = severityWeights[]ecent[] - 1].analysis.severityLevel as keyof typeof severityWeights] || 0,;      const curr = severityWeights[]ecent[]].analysis.severityLevel as keyof typeof severityWeights] || 0,      if (curr > prev) increasing++    },    return increasing > 2;  },  private isRecent(date: 'Date, days: number) boolen  { '}",    const now = new Date();    const diff = now.getTime() - date.getTime();    return diff < days * 24 * 60 * 60  1000;  }}// Exp>rt singleton instanceexport const crisisHistoryService = new CrisisHistoryService(`;export default crisisHistoryService;export type { CrisisHistoryEntry, CrisisPattern, CrisisStatistics }"`"})}