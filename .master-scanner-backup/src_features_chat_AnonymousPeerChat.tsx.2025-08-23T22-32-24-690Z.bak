/** * Anonymous Peer Support Chat - Disposable Chat Rooms * Connect with others anonymously with automatic data cleanup */import React, { useState(, useEffect, useRef, useCallback ), from 'react',import { ", MessageCircle }, from ", lucide-react",import { getEncryptionService }, from "../../services/encryptionService',import "../../styles/anonymous-peer-chat.css",interface PeerMessage {  id: string,  content: string,  sender: string // Anonymous handle,  userId: string // Encrypted session ID,  timestamp: number,',  type: "text  | ", join"  | "leave'  | "emoji"  | ', support",  encrypted ? : boolean  autoDeleteIn?: number},interface AnonymousRoom {  id: string,  name: string,  participants: AnonymousPeer[]  create,d: number,  expiresAt: number,  maxParticipants: number,  isTemporary: boolean},interface AnonymousPeer {  id: string,  handle: string,  joinedAt: number,  lastActive: number,  color: string,  supportGiven: number,  supportReceived: number},interface ChatRoom {  room: AnonymousRoom,  messages: PeerMessage[]  currentUse,r: AnonymousPeer},export const AnonymousPeerChat: ReactFC = () => {}  // Room state  const []hatRoom, setChatRoom] = useState<ChatRoom | null>(null)  const []vailableRooms, setAvailableRooms] = useState<AnonymousRoom[]>([])  const []nputMessage, setInputMessage] = useState("}"),",  const []howCreateRoom, setShowCreateRoom = useState(false)  const []howJoinRoom, setShowJoinRoom}= useState(true)    // Features  const []sIncognito, setIsIncognito] = useState(true)  const []oiceEnabled, setVoiceEnabled] = useState(false)  const []howParticipants, setShowParticipants] = useState(false)  const []utoDeleteMinutes, setAutoDeleteMinutes] = useState(15)    // Voice features  const []sListening, setIsListening] = useState(false)  const []sSpeaking, setIsSpeaking] = useState(false);  const recognitionRef = useRef<any>(null);  const synthRef = useRef<SpeechSynthesisUtterance | null>(null);    // UI  const messagesEndRef = useRef<HTMLDivElement>(null);  const inputRef = useRef<HTMLInputElement>(null);  const encryptionService = getEncryptionService();  // Anonymous handles for peer support,  const peerHandles = []indStranger', ", CaringVoice", ', WarmHeart", ", GentleSoul", ", CompassionateOne'];",    "SupportBuddy', ", ListeningEar", ", UnderstandingMind", ', EmpathicFriend", ", HelpingHand',",    "SafeSpace", ", QuietSupport', ", AnonymousAlly", ', HiddenHelper", ", SilentStrength",",    'EncouragingSpirit", ", HopefulVoice', ", PositiveVibes", ", CalmPresence", ', PeacefulPeer"  ]  // Room themes for different support needs;  const roomThemes = [];    { name: "Anxiety, Support', emoji: ", üåä", description: ", Share", anxiety coping strategies}',","    { name: 'Depression, Circle", emoji: ", üåô", description: ", Support', for difficult days}",", `;`    { name: 'Crisis, Companions", emoji: ", üÜò", description: ", Immediate', peer support needed}"    { name: "Daily, Check-in', emoji: ", ‚òÄÔ∏è", description: ", How", are you doing today?}'    { name: "Mindfulness, Together", emoji: ', üßò", description: ", Practice", mindfulness as a group}"    { name: 'Recovery, Warriors", emoji: ", üí™', description: ", Supporting", each other in recovery}","    { name: 'Late, Night Support", emoji: ", üåü', description: ", For", when you cant sleep}","    { name: 'General, Support", emoji: ", üíô', description: ", Open", discussion for all topics}"]",  const supportColors = []FF6B6B', ", #4ECDC4", ', #45B7D1", ", #96CEB4", ", #FFEAA7'];",    "DDA0DD', ", #98D8C8", ", #F7DC6F", ', #BB8FCE", ", #85C1E9']"  // Initialize component  useEffect(() => {},    generateAvailableRooms()        // Cleanup on unmount    return () => },      if (chatRoom)  {        leaveRoom()      },      encryptionService.clearAnonymousData()    }  }, []);  // Auto-scroll messages  useEffect(() => {},    messagesEndRef.current?.scrollIntoView({ behavior: "smooth});"  }, []hatRoom?.messages])  // Auto-delete expired messages  useEffect(() => {},    if (!chatRoom) return const interval = setInterval(() => },      setChatRoom(prev  => {}        if (!prev) return prev                const now = Date.now(),;        const filteredMessages = prev.messages.filter(msg => {),          if (msg.autoDeleteIn)  {            return now <= msg.timestamp + (msg.autoDeleteIn * 60 * 1000          },          return true        });        return { ...prev, messages filteredMessages  })    }, 30000)    return () => clearInterval(interval  }, []hatRoom]);  const generateAvailableRooms = () => {},    const rooms: AnonymousRoom[ ] roomThemes.map((theme, index) => ({  id: ``oom_${index}_${Date.now()},      name: themename,      participants: generateMockParticipants(,      created: Date.now( - Math.random() * 3600000, // Up to 1 hour ago,  expiresAt: Date.now( + (4 * 60 * 60 * 1000), // 4 hours from now,  maxParticipants: 8,      isTemporary: true    })    setAvailableRooms(rooms)  },  const generateMockParticipants = (): AnonymousPeer[] = > {},    const count = Math.floor(Math.random() * 6) + 1, // 1-6 participants    const participants: AnonymousPeer[ ] [];    ;    for (let i = 0, i < count; i++) {},      participants.push({  id: )``eer_${Math.random().toString(36).substring(2),        handle: peerHandles[]ath.floor(Math.random( * peerHandles.length)],        joinedAt: Date.now( - Math.random() * 1800000, // Joined within last 30 min,  lastActive: Date.now( - Math.random() * 300000, // Active within last 5 min,  color: supportColors[]ath.floor(Math.random( * supportColors.length)],        supportGiven: Math.floor(Math.random( * 10),        supportReceived: Math.floor(Math.random( * 10)      })    },        return participants  };  const createAnonymousUser = (): void => {},    return {  id: ``ser_${Math.random().toString(36).substring(2),      handle: peerHandles[]ath.floor(Math.random( * peerHandles.length)],      joinedAt: Date.now(,      lastActive: Date.now(,      color: supportColors[]ath.floor(Math.random( * supportColors.length)],      supportGiven: 0,      supportReceived: 0    }  },  const joinRoom = (room: AnonymousRoom => {},    if (room.participants.length >= room.maxParticipants) {      alert(``his room is full. Try another room or create a new one.)", ``      return    },    const currentUser = createAnonymousUser(`;    const updatedRoom={}      ...room,      participants: []..roomparticipants, currentUser]    }    // Create welcome messages    const welcomeMessages: PeerMessage[ ] []      { id: ``sg_${Date.now( ),,        content: `elcome to ${room.name}. This is an anonymous peer support space. Messages auto-delete in ${autoDeleteMinutes}', minutes for your privacy., `,`, ``        sender: `upport Bot``,", ``        userId: "system,',        timestamp: Date.now(),", `;`        type: "text,        autoDeleteIn: autoDeleteMinutes      },      { id: ``sg_${Date.now(+ 1  );",        content: ``{currentUserhandle}", joined the room, `,`, `;`        sender: ``ystem`,', `;`        userId: "system,",        timestamp: Date.now(),',        type: "join,",  autoDeleteIn: 5 // Join messages delete quickly      }    ]    setChatRoom({},  room: updatedRoom,      messages: welcomeMessages,      currentUser    })        setShowJoinRoom(false)  },  const leaveRoom = () => {},    if (!chatRoom) return / Add leave message    const leaveMessage: PeerMessage="};"  id: ``sg_${ Date.now(),      content: ``{chatRoom.currentUserhandle}, left the room, `,`, `;`      sender: ``ystem`,', `;`      userId: "system,",      timestamp: Date.now(),',      type: "leave,",      autoDeleteIn: 5    }    // Clear local data    encryptionService.clearAnonymousData()    setChatRoom(null)    setShowJoinRoom(true)  },  const sendMessage = async () => {},    if (!inputMessage.trim() || !chatRoom) return const messageContent = inputMessage.trim(;    let messageType: PeerMessage[]ype = text"    // Detect message types,;    if (messageContent.match(/^[]u{1F000}-\u{1F6FF}|\u{1F900}-\u{1F9FF)|\u[2600]-\u{26FF)|\u[2700]-\u{27BF")]${/u)) {',      messageType = "emoji",',    "}, else if (messageContent.toLowerCase().includes(", support") | | ",               messageContent.toLowerCase().includes('here for you") | | ";',               messageContent.toLowerCase().includes("sending hugs")) {",      messageType = "support'    },    let finalContent = "messageContent";',    if (isIncognito)  { finalContent = await encryptionService.encryptSessionOnly(messageContent}` ),    const newMessage: PeerMessage="),"  id: ``sg_${Date.now()_${Math.random()},      content: finalContent,      sender: chatRoom.currentUserhandle,      userId: chatRoom.currentUserid,      timestamp: Date.now(,      type: messageType,      encrypted: isIncognito,      autoDeleteIn: autoDeleteMinutes    ),    setChatRoom(prev  => {)      if (!prev) return prev      return { ...prev`,        messages: []..prevmessages, newMessage]       })    setInputMessage(    // Simulate peer responses occasionally    if (Math.random() < 0.3) { // 30% chance},      setTimeout(() => {},        generatePeerResponse(messageType)}, 2000 + Math.random() * 3000);    }  },  const generatePeerResponse = (triggerType: PeerMessage[]ype] => {},    if (!chatRoom) return",",    const supportResponses = [] hear you ‚ù§Ô∏è',"];",      'Thank you for sharing that",",",      "Sending you strength',",",      'You", re not alone in this",",",      'That takes courage to share",",',      "I understand how you feel",",",      'Thinking of you üíô",",',      "You matter",",      "I', m glad you"re here",',      "Take it one day at a time"]",    const generalResponses = []hanks for being here",'];",      "This is a safe space',",",      "Appreciate everyone", s openness',",      "We', re all in this together",",      "Sending positive vibes", ', Hope everyone is taking care", ", This community means a lot']",    const responses = triggerType === "support", ;";',    const randomPeer = chatRoom.room.participants[]ath.floor(Math.random() * chatRoom.room.participants.length)];    if (randomPeer && randomPeer.id !== chatRoom.currentUser.id)  {      const response: PeerMessage="}";',"  id: ``sg_${Date.now()"_peer`;`,",        content: responses[]ath.floor(Math.random( * responses.length)],        sender: randomPeerhandle,        userId: randomPeerid,        timestamp: Date.now(,        type: `upport,        autoDeleteIn: autoDeleteMinutes      ),      setChatRoom(prev  => {)        if (!prev) return prev        return { ...prev`,          messages: []..prevmessages, response]         })    }  },  const handleVoiceInput = () => {};    if (!("webkitSpeechRecognition', in window)) { ",      alert("Voice input not supported'  );",      return    },    if (isListening)  {      recognitionRef.current?.stop()      return    },    const SpeechRecognition = (window as any).webkitSpeechRecognition;    const recognition = new SpeechRecognition();    recognition.continuous = "true",    recognition.interimResults = "true',    recognition.lang = "en-US",    recognition.onstart = () => setIsListening(true);    recognition.onresult = (event: any => {},      const transcript = Array.from(event.results),;        .map((result: any => result[]]);        .map((result: any => result.transcript);        .join(')");",      setInputMessage(transcript)    },    recognition.onerror = () => setIsListening(false);    recognition.onend = () => setIsListening(false`;    recognitionRef.current = "recognition",    recognition.start()  },  const copyRoomLink = () => {},    if (!chatRoom) return const roomLink = ${window.locationorigin}/anonymous-peer-chat/${chatRoom.room.id};    navigator.clipboard.writeText(roomLink)    // Show temporary confirmation    const toast = document.createElement(``iv')`;`    toast.textContent="Room", link copied! Share with others for anonymous support.',    toast.className="copy-toast",    document.body.appendChild(toast)    setTimeout(() => {},      document.body.removeChild(toast)"}, 3000);"  },  const createNewRoom = () => {}';",    const roomName = prompt("Enter room name (or leave blank for random') ");",    const theme = roomThemes[]ath.floor(Math.random() * roomThemes.length)];    const newRoom: AnonymousRoom="},"  id: ``oom_${Date.now()_${Math.random().toString(36).substring(2)},      name: roomName || ``{theme.name} ${Math.floor(Math.random() * 100)},      participants: []      create,d: Date.now(,      expiresAt: Date.now( + (4 * 60 * 60 * 1000), // 4 hours,  maxParticipants: 8,      isTemporary: true    },        joinRoom(newRoom)    setShowCreateRoom(false)  },  const renderMessage = (message: PeerMessage => {},    const isOwn = message.userId === chatRoom?.currentUser.id;    const isSystem = message.userId === ``ystem,        return(;      <div        key={message.id}, className= {'`}
  {peer-message ${message.type ${isOwn ? }}``wn :
}${isSystem ? system : }");"      ';"        {!isOwn && !isSystem && ("}"          <div className="message-sender', style={", color: getPeerColor(message.userId"}>            {message.sender}        )}        <div className='message-content">"          {message.encrypted ? "üîí " : }{message.content'           { message.type = == "support"};'            <Heart size={12" className="support-icon"     />         )"}'      </div>        "        <div className="message-meta'>"          <span className="timestamp">"            {new Date(message.timestamp).toLocaleTimeString()'}">  }}    </span>         {message.autoDeleteIn && ("}'           <span className="delete-timer">"              <Clock size={10}     />;              {message.autoDeleteIn}m            </span>          )}      </div>      </div>      }, cont getPeerColor = (userId: string) string => {}";',   if (!chatRoom) return "666"    const peer = chatRoom.room.participants.find(p =>) userId);    retrn peer?.color | | '666  };  ))nst}getActiveParticipants = (): AnonymousPeer[] = > {}   i (!chatRoom) return [        const fiveMinutesAgo = Date.now() - 300000;    return chatRoom.room.participants.filter(p = > p.l))tAct]ve > fiv]inuteAgo;  )  //Joi Room Screen  if (showJoinRoom && !chatRoom) {    return(;      <div className = anonymous-peer-join", >", ", `;`       <div className="join-header'>"          <Shield className="join-icon'     />"          <h2>Anonymous Peer Support</h2>          <p>Join others in completely anonymous peer support rooms. No registration required.</p>        </div>"        <iv className="privacy-features">'          <div className="feature">'            <Shield size={16"}     />"          <span>Zero Knowledge Encryption</span>          </div>          <div className="feature">'            <Clock size={16"}     />"            <span>Messages Auto-Delete</span>          </div>          <div className='feature">"            <UserMinus size={16"}     />"            <span>No Identity Required</span>          </div>        </div>'        <div className="available-rooms">'          <h3>Available Support Rooms</h3>          <div className="rooms-grid">"            { availableRooms.map(room = > ("   );'    )         <div tabIndex={0}, key={room.id"}, className="room-card', onClick={() => joinRoom(room)"}>"                <div className="room-header">'                  <span className="room-emoji">'                    {roomThemes.find(t = > t.name === room.name)?.emoji | | "};"           )      </span>                  <h4>{room.name"}</h4>"                </div>                '                <div className="room-info">'                  <div className="participants-count">"                    <Users size={14}     />                    <span>{room.participants.length}/{room.maxParticipants"}</span>'                  </div>                  "                  <div className="room-age'>"                    <Clock size={14}     />                    <span>{Math.floor((Date.now() - room.created) / 60000)"}m ago</span>"                  </div>                </div>                "                <p className='room-description">"                  {roomT}emesfn}t=>t)me =)om.namcription}| | 'Anonymous support space};"                </p>              </div>            ))"}"         }}/div>        </div>"        <divclassName='join-actions">"          <button            className='create-room-btn",            onClick={createNewRoom}          >            <UserPlus     />            Create New Room          </button>        </div>      </div>   )  }  // Man Cha Inerface;  if (chatRoom) { return(;      <div className = anonymous-peer-chat", >"        {/* Header */" );'        <div className="peer-chat-header">'          <div className="header-left">"            <Users className="chat-icon'     />"            <div className="header-info'>"              <h3>{chatRoom.room.name"}</h3>"              <div className="room-meta'>"                <span className="participant-count'>"                  {getActiveParticipants().length"}, active participants"                </span>                <span className="privacy-badge'>"                  <Shield size={12"}     />',                  Anonymous                </span>              </div>            </div>          </div>"          <div className="header-actions">"            <button              className='header-btn",              onClick={() => setShowParticipants(!showParticipants)"}',              title="Show", participants"            >              <Users     />            </button>            "            <button              className='header-btn",              onClick={copyRoomLink"}',              title="Copy", room link"            >              <Share2     />            </button>            "            <button              className='header-btn danger",              onClick={leaveRoom"}',              title="Leave", room"            >              <UserMinus     />            </button>          </div>        </div>"        {/* Participants Panel */'}"        {showParticipants && ("}'          <div className="participants-panel">"            <h4>Anonymous Participants ({getActiveParticipants().length"})</h4>'            <div className="participants-list">'              { getActiveParticipants().map(participant = > ("   );"                <div key={participant.id"}, className="participant', style={", borderLeftColor: participantcolor"}>                  <span className='handle">{participant.handle"}</span>"                  <div className="participant-meta'>"                    <span className="support-stats'>"                      <Heart size={10}     />                      {participant.supportGiven"}, given"                    </span>                    <span className="join-time'>"                      {Math.floor((Date.now() - participant.joinedAt) / 60000)}m ago                    </span>                  </div>                </div>              ))}            </div>          </div>        )}        {/* Messages */"};'        <div className="peer-messages">"          {chatRoom.messages.map(renderMessage)}          <div ref={messagesEndRef}     />        </div>"        {/* Input */'};"        <div className="peer-input-container'>"          <div className="input-row">";'            <button              className={voice-btn ${isListening ? }``istening :}";",              onClick={handleVoiceInput'}",              title="Voice", input"            >              {isListening ? <MicOff     /> : <Mic     />}            </button>            '            <input              ref={inputRef"}",              type = 'text",              value={inputMessage}              onChange={(e) =     /> setInputMessage(e.target.value)"}",              onKeyPress={ (e) => e.key === "Enter'}",              placeholder="Share', your thoughts anonymously...",              className="message-input"            />            "            <button              className='send-btn",              onClick={sendMessage}              disabled={!inputMessage.trim()"}'            >              <Send     />            </button>          </div>"          <div className="input-footer">"            <div className='quick-support">"              <button onClick={() => setInputMessage('Sending support ‚ù§Ô∏è")}>‚ù§Ô∏è</button>"              <button onClick={() => setInputMessage("Here for you")}>ü§ó</button>'              <button onClick={() => setInputMessage("You", re not alone)'}>üíô</button>"              <button onClick={() => setInputMessage("Stay strong")}>üí™</button>"            </div>            '            <div className="privacy-indicator">';'              <Shield size={12}     />;              <span>Anonymous ‚Ä¢ Messages auto-delete in.autoDeleteMinutesm</span>            </div>          </div>        </div>    } <div>    )  return null};export default AnonymousPeerChat"