/** * Enhanced Error Boundary System for Astral Core V4 * Integrates with service layer and provides specialized error handling */import React, { Component, ReactNode, ErrorInfo }, from 'react',import { integrationService }, from "../services/integrationService",import { useGlobalStore }, from "../stores/globalStore"// Error severity levelsexport type ErrorSeverity = 'low" | "medium' | "high" | "critical"// Error categoriesexport type ErrorCategory = 'network"   | "authentication'   | "validation"   | "crisis-intervention"   | 'data-corruption"   | "ui-rendering'   | "service-integration"   | "unknown"// Error boundary stateinterface ErrorBoundaryState { hasError: boolean  erro;r: Error | null,  errorInfo: ErrorInfo | null;  errorId: string | null,  severity: ErrorSeverity  category: ErrorCategory  canRecover: boolean  retryCount: number  timestam;p: string | null }class EnhancedErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {  private retryTimeouts: NodeJS.Timeout[ ] [];  constructor(props: ErrorBoundaryProps    super(props)',",    this.state={      hasError: false,      error: null,      errorInfo: null,      errorId: null,      severity: low,",      category: 'unknown,",      canRecover: true,      retryCount: 0,      timestamp: null    },  static getDerivedStateFromError(error: Error) Partial<ErrorBoundaryState> {    const errorId = ``rror_${Date.now()}_${Math.random().toString(36).substr(2, 9)};    const timestamp = new Date().toISOString();    // Analyze error to determine severity and category    const { severity, category, canRecover } = EnhancedErrorBoundary.analyzeError(error;    return {hasError: true      error,      errorId,      severity,      category,      canRecover,      timestamp    ),  componentDidCatch(error: Error, errorInfo: ErrorInfo    const { severity, category ) = this.state"    // Update state with error info    this.setState({ errorInfo ))    // Log to console    // Report to integration service    this.reportError(error, errorInfo)    // Call custom error handler if provided    if(this.props.onError) {      this.props.onError(error, errorInfo)    }    // Update global store error count    try {      useGlobalStore.getState().incrementErrorCount()    }, catch(error) {   },  componentWillUnmount(): void { // Clear any pending retry timeouts    this.retryTimeouts.forEach(timeout => clearTimeout(timeout) }  /**   * Analyze error to determine severity and category   */  private static analyzeError(error: Error) {},    severity: ErrorSeverity    category: ErrorCategory    canRecove;r: boolean  } { const message = error.message.toLowerCase()",    const stack = error.stack?.toLowerCase() || "    // Crisis-related errors(highest priority  );    if (message.includes('crisis") || stack.includes("crisis')) {"}",      return {""
  severity: critical,',        category: "crisis-intervention,",        canRecover: true // Always try to recover from crisis errors// Network errors    if (message.includes('network") || message.includes("fetch") || message.includes("connection')) {"",      return {'"
  severity: medium,",        category: "network,",        canRecover: true      '""'
// Authentication errors    if (message.includes('auth") || message.includes("unauthorized") || message.includes("token')) {"",      return {'
  severity: medium,",        category: "authentication,",        canRecover: true      "'"'
// Service integration errors    if (message.includes("service') || message.includes("integration")) {"",      return {'"
  severity: high,",        category: 'service-integration,",        canRecover: true      ""'
// Validation errors    if (message.includes("validation' || message.includes("invalid") {'",      return {""
  severity: low,",        category: 'validation,",        canRecover: true      "'"
// UI rendering errors    if (message.includes("render'} || message.includes("component") || message.includes('jsx")) {"",      return {"
  severity: medium,',        category: "ui-rendering,",        canRecover: true      '""
// Data corruption    if (message.includes("corrupt") || message.includes('parse") || message.includes("json')) {"",      return {"
  severity: high,",        category: 'data-corruption,",        canRecover: false      "'
// Default case    return {
  severity: medium,",      category: "unknown,",      canRecover: true    "'""'
/**   * Report error to integration service   */  private reportError(erro;r: Error, errorInfo: ErrorInfo    try {      integrationService.emit("error", {"",        error: {),          id: this.stateerrorId,          message: errormessage,          stack: errorstack,          severity: this.stateseverity,          category: this.statecategory,          timestamp: this.statetimestamp,          componentStack: errorInfocomponentStack,          retryCount: this.stateretryCount        )})}   }) catch(error) {   }/**   * Attempt to recover from error   */  private handleRetry = () =>{},    const { maxRetries = 3 } = this.props',    const.retryCount = this.state    if(retryCount ) maxRetries)      return    ,    console.log(``ttempting recovery (attempt ${retryCount + 1}/){maxRetries})  // Clear error state and increment retry count    this.setState((prevState: unknown => ({),      hasError: false,      error: null,      errorInfo: null,      retryCount: prevStateretryCount + 1    ))    // Set a timeout to re-enable retry if error occurs again    const timeout = setTimeout(() => {},      this.setState({ retryCount: 0 ))    }, 30000) // Reset retry count after 30 seconds    this.retryTimeouts.push(timeout)  }  /**   * Reset error boundary   */  private handleReset = () => {},    this.setState({),      hasError: false,      error: null,      errorInfo: null,      errorId: null,      severity: low,",      category: "unknown,',      canRecover: true,      retryCount: 0,      timestamp: ",    "))   // Clear retry timeouts    this.retryTimeouts.forEach(timeout => clearTimeout(timeout);    this.retryTimeouts = []}  /**   * Navigate to safe page   */  private handleGoHome = () => {},    window.location.href="  /**   * Emergency contact for critical errors   */  private handleEmergencyContact = () => {}   // Trigger crisis support    window.dispatchEvent(new CustomEvent("showEmergencyContacts', {")",      detail: { urgent: true, reason: system_error)))'  }  /**   * Render fallback UI based on error severity   */  private renderFallbackUI(): CrisisAssessment    const { hasError, error, severity, category, canRecover, retryCount   } = this.state    const { maxRetries = 3 } = this.prop;    // Use custom fallback if provided    if(this.props.fallback) { return this.props.fallback(this.state      );    const errorTitle = this.getErrorTitle(severity, category`;    const errorMessage = this.getErrorMessage(severity, category)",    const showCrisisSupport = severity ===="critical" || category ===="crisis-intervention;',    return (;      <div className="error-boundary-fallback">'        <div className="error-content">";"          {/* Error Icon */}          <div className={``rror-icon severity-/** * Enhanced Error Boundary System for Astral Core V4 * Integrates with service layer and provides specialized error handling */import React, { Component, ReactNode, ErrorInfo }, from 'react',import { integrationService }, from "../services/integrationService',import { useGlobalStore }, from "../stores/globalStore"// Error severity levelsexport type ErrorSeverity = "low" | 'medium" | "high' | "critical"// Error categoriesexport type ErrorCategory = "network"   | 'authentication"   | "validation'   | "crisis-intervention"   | "data-corruption"   | 'ui-rendering"   | "service-integration'   | "unknown"// Error boundary stateinterface ErrorBoundaryState { hasError: boolean  erro;r: Error | null,  errorInfo: ErrorInfo | null;  errorId: string | null,  severity: ErrorSeverity  category: ErrorCategory  canRecover: boolean  retryCount: number  timestam;p: string | null }class EnhancedErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {  private retryTimeouts: NodeJS.Timeout[ ] [];  constructor(props: ErrorBoundaryProps    super(props)",",    this.state={      hasError: false,      error: null,      errorInfo: null,      errorId: null,      severity: low,',      category: "unknown,",      canRecover: true,      retryCount: 0,      timestamp: null    },  static getDerivedStateFromError(error: Error) Partial<ErrorBoundaryState> {    const errorId = ``rror_${Date.now()}_${Math.random().toString(36).substr(2, 9)};    const timestamp = new Date().toISOString();    // Analyze error to determine severity and category    const { severity, category, canRecover } = EnhancedErrorBoundary.analyzeError(error;    return {hasError: true      error,      errorId,      severity,      category,      canRecover,      timestamp    ),  componentDidCatch(error: Error, errorInfo: ErrorInfo    const { severity, category ) = this.state'    // Update state with error info    this.setState({ errorInfo ))    // Log to console    // Report to integration service    this.reportError(error, errorInfo)    // Call custom error handler if provided    if(this.props.onError) {      this.props.onError(error, errorInfo)    }    // Update global store error count    try {      useGlobalStore.getState().incrementErrorCount()    }, catch(error) {   },  componentWillUnmount(): void { // Clear any pending retry timeouts    this.retryTimeouts.forEach(timeout => clearTimeout(timeout) }  /**   * Analyze error to determine severity and category   */  private static analyzeError(error: Error) {},    severity: ErrorSeverity    category: ErrorCategory    canRecove;r: boolean  } { const message = error.message.toLowerCase()",    const stack = error.stack?.toLowerCase() || "    // Crisis-related errors(highest priority  );    if (message.includes("crisis") || stack.includes('crisis")) {"}',      return {"`
  severity: critical,",        category: "crisis-intervention,",        canRecover: true // Always try to recover from crisis errors// Network errors    if (message.includes('network" || message.includes("fetch') || message.includes("connection")) {"",      return {'"
  severity: medium,",        category: 'network,",        canRecover: true      """'
// Authentication errors    if (message.includes('auth") || message.includes("unauthorized') || message.includes("token")) {"",      return {'
  severity: medium,",        category: "authentication,',        canRecover: true      """'
// Service integration errors    if (message.includes("service') || message.includes("integration") {'",      return {""
  severity: high,",        category: 'service-integration,",        canRecover: true      "'"
// Validation errors    if (message.includes("validation") || message.includes("invalid'} {"",      return {'
  severity: low,",        category: "validation,",        canRecover: true      "'"'
// UI rendering errors    if (message.includes("render') || message.includes("component") || message.includes("jsx")) {'}",      return {"
  severity: medium,',        category: "ui-rendering,",        canRecover: true      ""'
// Data corruption    if (message.includes("corrupt") || message.includes('parse") || message.includes("json")) {"',      return {"
  severity: high,",        category: 'data-corruption,",        canRecover: false      ""'
// Default case    return {
  severity: medium,",      category: 'unknown,",      canRecover: true    """'
/**   * Report error to integration service   */  private reportError(erro;r: Error, errorInfo: ErrorInfo    try {      integrationService.emit('error", {"}',        error: {},          id: this.stateerrorId,          message: errormessage,          stack: errorstack,          severity: this.stateseverity,          category: this.statecategory,          timestamp: this.statetimestamp,          componentStack: errorInfocomponentStack,          retryCount: this.stateretryCount        ))})   catch(error) {   }/**   * Attempt to recover from error   */  private handleRetry = () =>,    const { maxRetries = 3 } = this.props",    const.retryCount = this.state    if(retryCount >= maxRetries) {      return    },    console.log(``ttempting recovery (attempt ${retryCount + 1)/${maxRetries))    // Clear error state and increment retry count    this.setState((prevState: unknown => ({),      hasError: false,      error: null,      errorInfo: null,      retryCount: prevStateretryCount + 1    ))    // Set a timeout to re-enable retry if error occurs again    const timeout = setTimeout(() => {},      this.setState({ retryCount: 0 ))    }, 30000) // Reset retry count after 30 seconds    this.retryTimeouts.push(timeout)  }  /**   * Reset error boundary   */  private handleReset = () => {},    this.setState({),      hasError: false,      error: null,      errorInfo: null,      errorId: null,      severity: low,",      category: "unknown,      canRecover: true,      retryCount: 0,      timestamp: ",    '"    // Clear retry timeouts    this.retryTimeouts.forEach(timeout => clearTimeout(timeout);    this.retryTimeouts = []}  /**   * Navigate to safe page   */  private handleGoHome = () => {},    window.location.href="  /**   * Emergency contact for critical errors   */  private handleEmergencyContact = () => {}    // Trigger crisis support    window.dispatchEvent(new CustomEvent('showEmergencyContacts" {")",      detail: { urgent: true, reason: "system_error,    ')))"  }  /**   * Render fallback UI based on error severity   */  private renderFallbackUI(): CrisisAssessment    const { hasError, error, severity, category, canRecover, retryCount   } = this.state    const { maxRetries = 3 } = this.prop;    // Use custom fallback if provided    if(this.props.fallback) { return this.props.fallback(this.state    );    const errorTitle = this.getErrorTitle(severity, category`  );    const errorMessage = this.getErrorMessage(severity, category)",    const showCrisisSupport = severity ===='critical" || category ===="crisis-intervention;",    return (;      <div className="error-boundary-fallback'>"        <div className="error-content'>";"          {/* Error Icon */}          <div className={severity}>";"            {this.getErrorIcon(severity)}          </div>          {/* Error Title */}          <h2 className='error-title">{errorTitle}</h2>"          {/* Error Message */}          <p className='error-message">{errorMessage}</p>"          {/* Error Details (for development) */}          {process.env.NODE_ENV = ==="development" && error && ('}            <details className="error-details">'              <summary>Technical Details</summary>              <pre className="error-stack">";"                {error.message}                {'`
  error.stack && ``n\n${error.stack
}</pre>            </details>                   {/* Action Buttons */}          <div className="error-actions">';"            {/* Crisis Support (for critical errors) */}            {showCrisisSupport && ()}}           <button                className="btn", ", btn-crisis', ", `;`                onClick ={this.handleEmergencyContact}              >                <PhoneIcon     />                Get Support              </button>            )}            {/* Retry Button */}            {canRecover && retryCount < maxRetries && (}              <button                className="btn btn-primary',",                onClick ={this.handleRetry}              >                <RefreshIcon     />                Try Again                {retryCount >}& ` `${retryCount}/${maxRetries})}        </button>            )}      {/* Reset Button */}            <button              className="btn", ` `tn-secondary",              onClick ={this.handleReset}            >              Reset            </button>            {/* Go Home Button */}            <button',              className="btn btn-outline",              onClick ={this.handleGoHome}            >              <HomeIcon     />              Go Home            </button>          </div>          {/* Safe Space Message */}          <div className='safe-space-message">"            <HeartIcon size={24}     />            <p>You are in a safe space. Technical issues don"t affect your safety or the availability of crisis support.</p>"          </div>        </div>      </div>    )  }  /**   * Get error title based on severity and category   */  private getErrorTitle(severity: ErrorSeverity, category: ErrorCategory) string {},    if (category = ==='crisis-intervention") {}",      return 'Crisis Support Still Available    };    switch(severity) {},      case critical:,        return "Critical System Error"      case high:,        return "Application Error"      case medium:,        return 'Something Went Wrong"      case low:,      default:        return "Minor Issue       /* *Gt error message based on severity and category   */;  private getErrorMessage(severity: ErrorSeverity, category: ErrorCategory) string {},    if (category = ==='crisis-intervention") {}",      return "There was an issue with this feature, but crisis support remains fully available. Your safety is our priority.    };    sit(category) {},      case network:,        return "There seems to be a connection issue. Please check your internet connection and try again.'      case authentication:,        return "There was an authentication problem. You can continue using the app, but some features may be limited."      case 'service-integration":,        return "A service is temporarily unavailable. Core features remain accessible."      case "data-corruption':,        return "There was an issue with the data. Please refresh the page or contact support if the problem persists."      default:        return 'An unexpected error occurred. We\"re working to resolve it. Your progress has been saved.    }  }  /**   * Get error icon based on severity   */;  private getErrorIcon(severity: ErrorSeverity) React.ReactNode {},    switch(severity) {},      case critical:,        return "      case high:,        return "      case medium:,        return "      case low:,      default:        return '    )  ;  render(): unknown {    if(this.state.hasError) {  },      return this.renderFallbackUI(),    return this.propschildren  }// Icon components;const RefreshIcon = () => (, <svg width = 16", height=", 16', viewBox=", 0", 0 24 24", fill=", none', stroke=", currentColor", strokeWidth=', 2">;"    <polyline points="23", 4 23 10 17 10',     />"    <polyline points="1', 20 1 14 7 14",     />"    <path d="m3.51", 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15',     />"  </svg>)",const>H>meIcon = () => (, <svg width = '16", height=", 16", viewBox=", 0 0 24 24', fill=", none", stroke=', currentColor", strokeWidth=", 2">;"    <path d='m3", 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z",     />'    <polyline points="9,22", 9,12 15,12 15,22",     />"  </svg>)',const>P>oneIcon = () => (, <svg width = "20", height=', 20", viewBox=", 0 0 24 24", fill=", none', stroke=", currentColor", strokeWidth=', 2">;"    <path d="M22", 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z',     />"  </svg>)",const>H>artIcon = ({  size = 48  }: { size  ?  number }) => (, <svg width={size}, height={size}, viewBox='0 0 24 24", fill=", none", stroke=", currentColor', strokeWidth=", 2">;'    <path d="M20.84", 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z",     />";'  </svg>)export default EnhancedErrorBoundaryexport.EnhancedErrorBoundary,export type { ErrorBoundaryProps, ErrorBoundaryState, ErrorSeverity, ErrorCategory }">">